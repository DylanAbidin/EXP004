[{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T21:43:00.127Z","tree_hash":"5b344832977d233ca51b0d8759623f4bf3c96c3f72bf8239ce5a61cb2397df61","added":[{"path":".cursorindexingignore","size":110,"mtime":1765316565707,"ext":""}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:20:06.888Z","tree_hash":"5b344832977d233ca51b0d8759623f4bf3c96c3f72bf8239ce5a61cb2397df61","added":[],"modified":[],"removed":[{"path":"mini-project-3-team-tiger","size":0,"mtime":0,"ext":"","content":null}],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:20:36.900Z","tree_hash":"5b344832977d233ca51b0d8759623f4bf3c96c3f72bf8239ce5a61cb2397df61","added":[],"modified":[],"removed":[{"path":"mini-project-3-team-tiger","size":0,"mtime":0,"ext":"","content":null}],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:20:41.899Z","tree_hash":"5b344832977d233ca51b0d8759623f4bf3c96c3f72bf8239ce5a61cb2397df61","added":[],"modified":[],"removed":[{"path":"mini-project-3-team-tiger","size":0,"mtime":0,"ext":"","content":null}],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:23:11.997Z","tree_hash":"8ca25ef7e95d86a2547d24252b31cfa16cf48913c0d7c7984c3e1120b988f331","added":[{"path":"mini-project-3-team-tiger/.github/.keep","size":0,"mtime":1765318988809,"ext":""},{"path":"mini-project-3-team-tiger/README.md","size":202,"mtime":1765318988809,"ext":"md","content":"[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:27:52.193Z","tree_hash":"29f4347fd4f008bd06c15aa626e61620dc07860f0705e793a9b08d3c481b3726","added":[{"path":"mini-project-3-team-tiger/assets/map.png","size":110650,"mtime":1765319267335,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/ride_hailing.xlsx","size":49230,"mtime":1765319267338,"ext":"xlsx"},{"path":"mini-project-3-team-tiger/assets/plates/AE2DUT0.png","size":120363,"mtime":1765319267342,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/A8EFRA5.png","size":138824,"mtime":1765319267341,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/ALQWNF8.png","size":140989,"mtime":1765319267342,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/B4BR8T.png","size":119963,"mtime":1765319267342,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/B5RMPS.png","size":138505,"mtime":1765319267343,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/B7F5T1Y.png","size":248043,"mtime":1765319267343,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/BC9EGM.png","size":121179,"mtime":1765319267344,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/BQD3QCC.png","size":139180,"mtime":1765319267344,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/BUHUC1.png","size":117532,"mtime":1765319267345,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/C2F6VN.png","size":138807,"mtime":1765319267345,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/C7010N.png","size":85146,"mtime":1765319267346,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/C83S708.png","size":251088,"mtime":1765319267346,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/CDBEJB.png","size":174697,"mtime":1765319267349,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/CP5Q4M.png","size":89363,"mtime":1765319267349,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/CSUAPXD.png","size":186309,"mtime":1765319267351,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/CUQM88J.png","size":249810,"mtime":1765319267352,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/D2FBZ7.png","size":135162,"mtime":1765319267352,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/D7CN6Q.png","size":141521,"mtime":1765319267353,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/DA7WK8.png","size":243177,"mtime":1765319267353,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/DD0BVK.png","size":231367,"mtime":1765319267355,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/DHSQKAQ.png","size":119529,"mtime":1765319267356,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/DV1K2Z.png","size":177258,"mtime":1765319267356,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/E45LPU.png","size":134295,"mtime":1765319267357,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/ENV245.png","size":136741,"mtime":1765319267357,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/EU11YZ5.png","size":86458,"mtime":1765319267358,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/EYELGK.png","size":83642,"mtime":1765319267358,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/F2NJ2W.png","size":118100,"mtime":1765319267359,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/F5SHUBE.png","size":119962,"mtime":1765319267360,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/FEEN6D3.png","size":235557,"mtime":1765319267361,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/FWZU4BU.png","size":139706,"mtime":1765319267362,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/GIX3162.png","size":184369,"mtime":1765319267363,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/GP93NR.png","size":140661,"mtime":1765319267364,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/H3NFDTN.png","size":245068,"mtime":1765319267365,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/H5BFXQR.png","size":120260,"mtime":1765319267365,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/HLTLM1.png","size":130915,"mtime":1765319267366,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/J1ZPXN.png","size":136545,"mtime":1765319267366,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/J2GUWH8.png","size":121270,"mtime":1765319267368,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/JAS3UW.png","size":139414,"mtime":1765319267368,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/JN2DF6.png","size":136942,"mtime":1765319267369,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/JUMX3RJ.png","size":248185,"mtime":1765319267370,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/JXPN4TF.png","size":137857,"mtime":1765319267370,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/K5RM40X.png","size":184771,"mtime":1765319267372,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/KG6EW2.png","size":89461,"mtime":1765319267372,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/KGYDFK.png","size":85354,"mtime":1765319267373,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/KK5UTE0.png","size":137813,"mtime":1765319267373,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/KTDPNX4.png","size":87454,"mtime":1765319267374,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/LLTYXL4.png","size":249205,"mtime":1765319267374,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/LPJW7B.png","size":118817,"mtime":1765319267376,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/LWPM9VY.png","size":253706,"mtime":1765319267378,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/M1FNYM.png","size":83630,"mtime":1765319267379,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/M2GC6BR.png","size":142782,"mtime":1765319267379,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/MGGNAV.png","size":86897,"mtime":1765319267380,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/MH6YC8.png","size":89091,"mtime":1765319267380,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/MHKVP5.png","size":120192,"mtime":1765319267381,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/NADRE5G.png","size":120813,"mtime":1765319267382,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/NCEUQ4.png","size":244976,"mtime":1765319267382,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/NNLXDFC.png","size":238455,"mtime":1765319267383,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/NSTQGMR.png","size":184318,"mtime":1765319267385,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/NVXWSP.png","size":245427,"mtime":1765319267385,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/PCNHBH.png","size":231520,"mtime":1765319267386,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/PFB594.png","size":232538,"mtime":1765319267388,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/PJ5RM4.png","size":120211,"mtime":1765319267389,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/PKS29HK.png","size":242629,"mtime":1765319267389,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/PPX97K.png","size":139610,"mtime":1765319267390,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/PXAVN0E.png","size":184193,"mtime":1765319267390,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/Q75Q706.png","size":88704,"mtime":1765319267392,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/QEM62SJ.png","size":121752,"mtime":1765319267393,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/R53DE3X.png","size":248527,"mtime":1765319267393,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/RHSDQR.png","size":139565,"mtime":1765319267394,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/S1CWQEC.png","size":89498,"mtime":1765319267394,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/S3R7YP8.png","size":244654,"mtime":1765319267396,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/SPQBUSK.png","size":120662,"mtime":1765319267397,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/SQUCQ1.png","size":140293,"mtime":1765319267398,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/T9GUBH.png","size":232263,"mtime":1765319267398,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/U7R1JP.png","size":175690,"mtime":1765319267400,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/ULSXU1N.png","size":182443,"mtime":1765319267401,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/UPS7402.png","size":186223,"mtime":1765319267401,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/UUNJPK1.png","size":136920,"mtime":1765319267402,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/UY767S.png","size":138706,"mtime":1765319267402,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/V73Q8J2.png","size":143920,"mtime":1765319267404,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/VBTXTM.png","size":178067,"mtime":1765319267406,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/VEWCKJ.png","size":119745,"mtime":1765319267406,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/VS1CZZ6.png","size":184604,"mtime":1765319267406,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/WASDD1C.png","size":184748,"mtime":1765319267407,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/WB28BTE.png","size":88148,"mtime":1765319267407,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/WEBGFW1.png","size":86011,"mtime":1765319267408,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/WV610AS.png","size":251834,"mtime":1765319267409,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/X7M262S.png","size":143047,"mtime":1765319267409,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/X9A1NUG.png","size":89290,"mtime":1765319267409,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/XB8PYW.png","size":139192,"mtime":1765319267410,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/XFCWC9.png","size":180415,"mtime":1765319267412,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/XLCPAU8.png","size":252970,"mtime":1765319267413,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/XNC6FCM.png","size":242314,"mtime":1765319267414,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/XP82WDL.png","size":243721,"mtime":1765319267415,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/YGYHQM3.png","size":242183,"mtime":1765319267415,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/YY1PS2.png","size":236611,"mtime":1765319267417,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/ZGYDJ5C.png","size":89532,"mtime":1765319267417,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/ZJE033.png","size":239133,"mtime":1765319267418,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/ZPR5EQ.png","size":240261,"mtime":1765319267419,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/FE0MYMN.png","size":119098,"mtime":1765319267361,"ext":"png"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:27:57.222Z","tree_hash":"92065ff5a01c4edde43f329381031481ddb0f9782354cd8cfdcfc432b4144987","added":[{"path":"mini-project-3-team-tiger/.gitignore","size":312,"mtime":1765319273109,"ext":""}],"modified":[{"path":"mini-project-3-team-tiger/.gitignore","size":312,"mtime":1765319273109,"ext":""}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:28:02.194Z","tree_hash":"5c674cd83b7707ab7a513cfbb9a012d2bc73619f9177cd9612377b592b19467c","added":[],"modified":[{"path":"mini-project-3-team-tiger/.gitignore","size":312,"mtime":1765319281015,"ext":""}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:28:12.204Z","tree_hash":"c824d480c7e5baab16697a4c6819cffd56c3575713de9e55427f5ed700f0cc2b","added":[{"path":"mini-project-3-team-tiger/backend/requirements.txt","size":76,"mtime":1765319288804,"ext":"txt","content":"flask==3.0.0\nflask-cors==4.0.0\npandas==2.1.3\nnumpy==1.26.2\nopenpyxl==3.1.2\n\n"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:28:47.221Z","tree_hash":"e0036213581824bc379aecc6b7f5261f7ae8793890bafdbc8fb64205b4313279","added":[{"path":"mini-project-3-team-tiger/backend/app.py","size":10057,"mtime":1765319324627,"ext":"py","content":"\"\"\"\nBackend API for Ride-Hailing Display/Dashboard at Sky Harbor Airport\nTechnical Lead: Data processing and API routing\n\"\"\"\n\nfrom flask import Flask, jsonify, request\nfrom flask_cors import CORS\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport os\n\napp = Flask(__name__)\nCORS(app)  # Enable CORS for frontend\n\n# Path to data file\nDATA_FILE = os.path.join(os.path.dirname(__file__), '..', 'assets', 'ride_hailing.xlsx')\n\n# Terminal to pickup zone mapping\nTERMINAL_ZONES = {\n    'Terminal 3': {\n        'zone': 'Zone A',\n        'walking_time_minutes': 3,\n        'pickup_coords': {'x': 300, 'y': 200}  # Approximate zone location\n    },\n    'Terminal 4': {\n        'zone': 'Zone B',\n        'walking_time_minutes': 5,\n        'pickup_coords': {'x': 500, 'y': 300}  # Approximate zone location\n    }\n}\n\n# Load and cache data\ndef load_data():\n    \"\"\"Load ride hailing data from Excel file\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Global data cache\n_data_cache = None\n\ndef get_data():\n    \"\"\"Get cached data or load fresh\"\"\"\n    global _data_cache\n    if _data_cache is None:\n        _data_cache = load_data()\n    return _data_cache.copy()\n\n@app.route('/api/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({'status': 'healthy', 'message': 'Backend API is running'})\n\n@app.route('/api/data/current', methods=['GET'])\ndef get_current_data():\n    \"\"\"Get current ride data\"\"\"\n    df = get_data()\n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots (with valid positions)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    result = {\n        'timestamp': latest_time.isoformat(),\n        'total_slots': len(current_data),\n        'active_slots': len(active_slots),\n        'slots': active_slots.to_dict('records')\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/terminal/guidance', methods=['GET'])\ndef get_terminal_guidance():\n    \"\"\"Get terminal-aware pickup guidance\"\"\"\n    terminal = request.args.get('terminal', 'Terminal 3')\n    \n    if terminal not in TERMINAL_ZONES:\n        return jsonify({'error': f'Terminal {terminal} not found'}), 400\n    \n    terminal_info = TERMINAL_ZONES[terminal]\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots in the terminal's zone\n    zone_coords = terminal_info['pickup_coords']\n    zone_x, zone_y = zone_coords['x'], zone_coords['y']\n    \n    # Find nearest available slots (within reasonable distance)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    if len(active_slots) > 0:\n        # Calculate distances to zone\n        active_slots['distance'] = np.sqrt(\n            (active_slots['x'] - zone_x)**2 + (active_slots['y'] - zone_y)**2\n        )\n        # Find nearest available slot\n        nearest_slot = active_slots.loc[active_slots['distance'].idxmin()]\n        \n        # Estimate ETA (walking time + wait time)\n        # Wait time based on number of available slots (more slots = less wait)\n        available_count = len(active_slots)\n        estimated_wait_minutes = max(2, 10 - (available_count // 5))  # Simple heuristic\n        \n        total_minutes = terminal_info['walking_time_minutes'] + estimated_wait_minutes\n        \n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': estimated_wait_minutes,\n            'total_minutes': total_minutes,\n            'available_slots': len(active_slots),\n            'nearest_slot_id': int(nearest_slot['slot_id']),\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {total_minutes} minutes.\"\n        }\n    else:\n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': 15,  # Default if no slots\n            'total_minutes': terminal_info['walking_time_minutes'] + 15,\n            'available_slots': 0,\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {terminal_info['walking_time_minutes'] + 15} minutes.\"\n        }\n    \n    return jsonify(result)\n\n@app.route('/api/forecast/price-wait', methods=['GET'])\ndef get_price_wait_forecast():\n    \"\"\"Get price and wait time forecast (15-30 min horizon)\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    \n    # Get data from last 30 minutes for rolling average\n    time_window = timedelta(minutes=30)\n    historical_data = df[df['current_time'] >= (latest_time - time_window)].copy()\n    \n    # Calculate metrics over time windows\n    time_buckets = []\n    for i in range(6):  # 6 buckets of 5 minutes each = 30 minutes\n        bucket_start = latest_time - timedelta(minutes=(6-i)*5)\n        bucket_end = latest_time - timedelta(minutes=(5-i)*5) if i < 5 else latest_time\n        bucket_data = historical_data[\n            (historical_data['current_time'] >= bucket_start) & \n            (historical_data['current_time'] < bucket_end)\n        ]\n        \n        active_slots = bucket_data[\n            bucket_data['x'].notna() & bucket_data['y'].notna()\n        ]\n        \n        # Simulate price based on demand (fewer slots = higher price)\n        # Base price + surge multiplier\n        base_price = 15.0\n        availability_ratio = len(active_slots) / len(bucket_data) if len(bucket_data) > 0 else 0\n        surge_multiplier = max(1.0, 2.0 - availability_ratio)\n        price = base_price * surge_multiplier\n        \n        # Wait time based on availability\n        wait_time = max(2, 15 - (len(active_slots) // 3))\n        \n        time_buckets.append({\n            'time': bucket_start.isoformat(),\n            'price': round(price, 2),\n            'wait_time': wait_time,\n            'availability': len(active_slots)\n        })\n    \n    # Calculate rolling averages and trends\n    prices = [b['price'] for b in time_buckets]\n    wait_times = [b['wait_time'] for b in time_buckets]\n    \n    # Rolling average (last 3 buckets)\n    recent_prices = prices[-3:] if len(prices) >= 3 else prices\n    recent_waits = wait_times[-3:] if len(wait_times) >= 3 else wait_times\n    \n    avg_price = np.mean(recent_prices)\n    avg_wait = np.mean(recent_waits)\n    \n    # Calculate slope/trend (linear regression on last 3 points)\n    if len(recent_prices) >= 2:\n        x = np.arange(len(recent_prices))\n        price_slope = np.polyfit(x, recent_prices, 1)[0]\n        wait_slope = np.polyfit(x, recent_waits, 1)[0]\n    else:\n        price_slope = 0\n        wait_slope = 0\n    \n    # Determine trend direction\n    def get_trend(slope, threshold=0.1):\n        if slope > threshold:\n            return 'up'\n        elif slope < -threshold:\n            return 'down'\n        else:\n            return 'flat'\n    \n    price_trend = get_trend(price_slope, threshold=0.5)\n    wait_trend = get_trend(wait_slope, threshold=0.5)\n    \n    # Forecast for next 15-30 minutes\n    forecast_horizon = 20  # minutes\n    forecast_price = avg_price + (price_slope * 4)  # Extrapolate\n    forecast_wait = avg_wait + (wait_slope * 4)\n    \n    # Ensure reasonable bounds\n    forecast_price = max(10.0, min(50.0, forecast_price))\n    forecast_wait = max(2, min(30, int(forecast_wait)))\n    \n    result = {\n        'current': {\n            'price': round(prices[-1] if prices else avg_price, 2),\n            'wait_time': wait_times[-1] if wait_times else int(avg_wait),\n            'timestamp': latest_time.isoformat()\n        },\n        'forecast': {\n            'price': round(forecast_price, 2),\n            'wait_time': forecast_wait,\n            'horizon_minutes': forecast_horizon\n        },\n        'trends': {\n            'price': {\n                'direction': price_trend,\n                'slope': round(price_slope, 3)\n            },\n            'wait_time': {\n                'direction': wait_trend,\n                'slope': round(wait_slope, 3)\n            }\n        },\n        'historical': time_buckets,\n        'sparkline_data': {\n            'prices': prices,\n            'wait_times': wait_times\n        }\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/data/timeseries', methods=['GET'])\ndef get_timeseries_data():\n    \"\"\"Get time series data for visualization\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get unique timestamps\n    unique_times = sorted(df['current_time'].unique())\n    \n    # Aggregate data by timestamp\n    timeseries = []\n    for timestamp in unique_times:\n        time_data = df[df['current_time'] == timestamp]\n        active_slots = time_data[\n            time_data['x'].notna() & time_data['y'].notna()\n        ]\n        \n        timeseries.append({\n            'timestamp': timestamp.isoformat(),\n            'active_slots': len(active_slots),\n            'total_slots': len(time_data)\n        })\n    \n    return jsonify({\n        'timeseries': timeseries,\n        'total_points': len(timeseries)\n    })\n\nif __name__ == '__main__':\n    print(\"Starting Backend API Server...\")\n    print(f\"Data file: {DATA_FILE}\")\n    app.run(debug=True, port=5000, host='0.0.0.0')\n\n"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:29:12.239Z","tree_hash":"90cce350bc2a4d366a74ecc1db528367dd83b8f85c8f50d19cbcfd9fc6e85e49","added":[{"path":"mini-project-3-team-tiger/frontend/index.html","size":5656,"mtime":1765319350826,"ext":"html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Sky Harbor Airport - Ride-Hailing Dashboard</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <!-- Header -->\n        <header class=\"header\">\n            <h1>‚úàÔ∏è Sky Harbor Airport</h1>\n            <h2>Ride-Hailing Display Dashboard</h2>\n        </header>\n\n        <!-- Terminal Selection Tabs -->\n        <div class=\"terminal-tabs\">\n            <button class=\"tab-button active\" data-terminal=\"Terminal 3\">Terminal 3</button>\n            <button class=\"tab-button\" data-terminal=\"Terminal 4\">Terminal 4</button>\n        </div>\n\n        <!-- Terminal Guidance Banner -->\n        <div id=\"guidance-banner\" class=\"guidance-banner\">\n            <div class=\"banner-content\">\n                <span class=\"banner-icon\">üìç</span>\n                <span id=\"guidance-message\" class=\"guidance-message\">Loading guidance...</span>\n            </div>\n            <div class=\"banner-details\">\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Zone:</span>\n                    <span id=\"zone-name\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Walking Time:</span>\n                    <span id=\"walking-time\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Estimated Wait:</span>\n                    <span id=\"estimated-wait\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Available Slots:</span>\n                    <span id=\"available-slots\" class=\"detail-value\">-</span>\n                </div>\n            </div>\n        </div>\n\n        <!-- Price & Wait Forecast Section -->\n        <div class=\"forecast-section\">\n            <h3>Price & Wait Forecast (15-30 min horizon)</h3>\n            \n            <div class=\"forecast-cards\">\n                <!-- Price Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">üí∞</span>\n                        <span class=\"card-title\">Price Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"price-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"price-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Wait Time Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">‚è±Ô∏è</span>\n                        <span class=\"card-title\">Wait Time Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"wait-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"wait-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- Map Visualization -->\n        <div class=\"map-section\">\n            <h3>Live Map View</h3>\n            <div class=\"map-container\">\n                <img id=\"map-image\" src=\"../assets/map.png\" alt=\"Airport Map\" class=\"map-image\">\n                <canvas id=\"map-overlay\" class=\"map-overlay\"></canvas>\n            </div>\n        </div>\n\n        <!-- Status Footer -->\n        <footer class=\"status-footer\">\n            <div class=\"status-item\">\n                <span class=\"status-label\">Last Updated:</span>\n                <span id=\"last-updated\" class=\"status-value\">-</span>\n            </div>\n            <div class=\"status-item\">\n                <span class=\"status-label\">API Status:</span>\n                <span id=\"api-status\" class=\"status-value\">Checking...</span>\n            </div>\n        </footer>\n    </div>\n\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:29:57.272Z","tree_hash":"88bac288d04857332caff9e4f9d131c8ee6e9a53f923873a144e7a0923885225","added":[{"path":"mini-project-3-team-tiger/frontend/styles.css","size":6854,"mtime":1765319392754,"ext":"css","content":"/* Sky Harbor Airport Ride-Hailing Dashboard Styles */\n/* UI/UX Specialist: Responsive and visually appealing interface */\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1400px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 20px;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\n    overflow: hidden;\n}\n\n/* Header */\n.header {\n    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);\n    color: white;\n    padding: 30px;\n    text-align: center;\n}\n\n.header h1 {\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n    font-weight: 700;\n}\n\n.header h2 {\n    font-size: 1.3rem;\n    font-weight: 300;\n    opacity: 0.9;\n}\n\n/* Terminal Tabs */\n.terminal-tabs {\n    display: flex;\n    gap: 10px;\n    padding: 20px;\n    background: #f5f5f5;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.tab-button {\n    flex: 1;\n    padding: 15px 30px;\n    font-size: 1.1rem;\n    font-weight: 600;\n    border: none;\n    border-radius: 10px;\n    background: white;\n    color: #666;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.tab-button:hover {\n    background: #e3f2fd;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);\n}\n\n.tab-button.active {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);\n}\n\n/* Guidance Banner */\n.guidance-banner {\n    margin: 20px;\n    padding: 25px;\n    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);\n    border-radius: 15px;\n    color: white;\n    box-shadow: 0 5px 20px rgba(79, 172, 254, 0.3);\n    animation: slideIn 0.5s ease;\n}\n\n@keyframes slideIn {\n    from {\n        opacity: 0;\n        transform: translateY(-20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.banner-content {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    margin-bottom: 15px;\n}\n\n.banner-icon {\n    font-size: 2rem;\n}\n\n.guidance-message {\n    font-size: 1.4rem;\n    font-weight: 600;\n    flex: 1;\n}\n\n.banner-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n    gap: 15px;\n    margin-top: 15px;\n    padding-top: 15px;\n    border-top: 1px solid rgba(255, 255, 255, 0.3);\n}\n\n.detail-item {\n    display: flex;\n    flex-direction: column;\n    gap: 5px;\n}\n\n.detail-label {\n    font-size: 0.9rem;\n    opacity: 0.9;\n}\n\n.detail-value {\n    font-size: 1.2rem;\n    font-weight: 700;\n}\n\n/* Forecast Section */\n.forecast-section {\n    padding: 30px;\n    background: #fafafa;\n}\n\n.forecast-section h3 {\n    font-size: 1.8rem;\n    margin-bottom: 25px;\n    color: #333;\n    text-align: center;\n}\n\n.forecast-cards {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 25px;\n}\n\n.forecast-card {\n    background: white;\n    border-radius: 15px;\n    padding: 25px;\n    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n    transition: transform 0.3s ease, box-shadow 0.3s ease;\n}\n\n.forecast-card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);\n}\n\n.card-header {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #f0f0f0;\n}\n\n.card-icon {\n    font-size: 1.8rem;\n}\n\n.card-title {\n    font-size: 1.3rem;\n    font-weight: 600;\n    color: #333;\n}\n\n.card-content {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n}\n\n.current-value, .forecast-value {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.value-label {\n    font-size: 0.95rem;\n    color: #666;\n}\n\n.value-amount {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: #2a5298;\n}\n\n/* Trend Badge */\n.trend-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px 15px;\n    border-radius: 20px;\n    font-weight: 600;\n    font-size: 0.9rem;\n    width: fit-content;\n}\n\n.trend-badge.flat {\n    background: #e0e0e0;\n    color: #666;\n}\n\n.trend-badge.up {\n    background: #ffebee;\n    color: #c62828;\n}\n\n.trend-badge.down {\n    background: #e8f5e9;\n    color: #2e7d32;\n}\n\n.trend-icon {\n    font-size: 1.2rem;\n}\n\n.trend-badge.up .trend-icon::before {\n    content: \"‚Üë\";\n}\n\n.trend-badge.down .trend-icon::before {\n    content: \"‚Üì\";\n}\n\n.trend-badge.flat .trend-icon::before {\n    content: \"‚Üí\";\n}\n\n/* Sparkline Container */\n.sparkline-container {\n    margin-top: 10px;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n/* Map Section */\n.map-section {\n    padding: 30px;\n    background: white;\n}\n\n.map-section h3 {\n    font-size: 1.8rem;\n    margin-bottom: 20px;\n    color: #333;\n    text-align: center;\n}\n\n.map-container {\n    position: relative;\n    width: 100%;\n    max-width: 1000px;\n    margin: 0 auto;\n    border-radius: 15px;\n    overflow: hidden;\n    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);\n}\n\n.map-image {\n    width: 100%;\n    height: auto;\n    display: block;\n}\n\n.map-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n}\n\n/* Status Footer */\n.status-footer {\n    display: flex;\n    justify-content: space-around;\n    padding: 20px;\n    background: #f5f5f5;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n    gap: 20px;\n}\n\n.status-item {\n    display: flex;\n    gap: 10px;\n    align-items: center;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #666;\n}\n\n.status-value {\n    color: #333;\n    font-weight: 500;\n}\n\n.status-value.success {\n    color: #2e7d32;\n}\n\n.status-value.error {\n    color: #c62828;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 1.8rem;\n    }\n\n    .header h2 {\n        font-size: 1rem;\n    }\n\n    .guidance-message {\n        font-size: 1.1rem;\n    }\n\n    .forecast-cards {\n        grid-template-columns: 1fr;\n    }\n\n    .banner-details {\n        grid-template-columns: 1fr;\n    }\n\n    .terminal-tabs {\n        flex-direction: column;\n    }\n\n    .tab-button {\n        width: 100%;\n    }\n}\n\n@media (max-width: 480px) {\n    body {\n        padding: 10px;\n    }\n\n    .container {\n        border-radius: 10px;\n    }\n\n    .header {\n        padding: 20px;\n    }\n\n    .forecast-section,\n    .map-section {\n        padding: 20px;\n    }\n}\n\n/* Loading Animation */\n@keyframes pulse {\n    0%, 100% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0.5;\n    }\n}\n\n.loading {\n    animation: pulse 1.5s ease-in-out infinite;\n}\n\n"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:30:32.280Z","tree_hash":"0cab01fecf15b1d3439c626769f51891e890101021bab231c1549ee8f674a21f","added":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":9483,"mtime":1765319428378,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5000/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    checkAPIHealth();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected');\n        console.error('API health check failed:', error);\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Please try again.';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Update map visualization\nasync function updateMapVisualization() {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n});\n\n"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:30:57.302Z","tree_hash":"eadcb8bafe0d1de1f5ae273cf673aff3ab7adf930ef9a1c4ce11bd66d79880a0","added":[],"modified":[{"path":"mini-project-3-team-tiger/README.md","size":4661,"mtime":1765319456274,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Create a virtual environment (recommended):\n   ```bash\n   python3 -m venv venv\n   source venv/bin/activate  # On Windows: venv\\Scripts\\activate\n   ```\n\n3. Install dependencies:\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n4. Start the backend server:\n   ```bash\n   python app.py\n   ```\n\n   The API will be available at `http://localhost:5000`\n\n### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. Open `frontend/index.html` in a web browser, or use a local server:\n\n   **Option A: Python HTTP Server**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Direct File Open**\n   - Simply open `frontend/index.html` in your browser (note: CORS may prevent API calls)\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Open the frontend in a browser (see Frontend Setup)\n3. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n4. View the guidance banner with pickup instructions\n5. Monitor price and wait time forecasts with trend indicators\n6. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:31:32.330Z","tree_hash":"35e2c83cab572dfc46f441a3567447fa6f691e76f7cb56fd754c390932098785","added":[],"modified":[{"path":"mini-project-3-team-tiger/.gitignore","size":312,"mtime":1765319489603,"ext":""},{"path":"mini-project-3-team-tiger/README.md","size":4661,"mtime":1765319489579,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Create a virtual environment (recommended):\n   ```bash\n   python3 -m venv venv\n   source venv/bin/activate  # On Windows: venv\\Scripts\\activate\n   ```\n\n3. Install dependencies:\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n4. Start the backend server:\n   ```bash\n   python app.py\n   ```\n\n   The API will be available at `http://localhost:5000`\n\n### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. Open `frontend/index.html` in a web browser, or use a local server:\n\n   **Option A: Python HTTP Server**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Direct File Open**\n   - Simply open `frontend/index.html` in your browser (note: CORS may prevent API calls)\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Open the frontend in a browser (see Frontend Setup)\n3. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n4. View the guidance banner with pickup instructions\n5. Monitor price and wait time forecasts with trend indicators\n6. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"},{"path":"mini-project-3-team-tiger/backend/app.py","size":10057,"mtime":1765319489579,"ext":"py","content":"\"\"\"\nBackend API for Ride-Hailing Display/Dashboard at Sky Harbor Airport\nTechnical Lead: Data processing and API routing\n\"\"\"\n\nfrom flask import Flask, jsonify, request\nfrom flask_cors import CORS\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport os\n\napp = Flask(__name__)\nCORS(app)  # Enable CORS for frontend\n\n# Path to data file\nDATA_FILE = os.path.join(os.path.dirname(__file__), '..', 'assets', 'ride_hailing.xlsx')\n\n# Terminal to pickup zone mapping\nTERMINAL_ZONES = {\n    'Terminal 3': {\n        'zone': 'Zone A',\n        'walking_time_minutes': 3,\n        'pickup_coords': {'x': 300, 'y': 200}  # Approximate zone location\n    },\n    'Terminal 4': {\n        'zone': 'Zone B',\n        'walking_time_minutes': 5,\n        'pickup_coords': {'x': 500, 'y': 300}  # Approximate zone location\n    }\n}\n\n# Load and cache data\ndef load_data():\n    \"\"\"Load ride hailing data from Excel file\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Global data cache\n_data_cache = None\n\ndef get_data():\n    \"\"\"Get cached data or load fresh\"\"\"\n    global _data_cache\n    if _data_cache is None:\n        _data_cache = load_data()\n    return _data_cache.copy()\n\n@app.route('/api/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({'status': 'healthy', 'message': 'Backend API is running'})\n\n@app.route('/api/data/current', methods=['GET'])\ndef get_current_data():\n    \"\"\"Get current ride data\"\"\"\n    df = get_data()\n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots (with valid positions)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    result = {\n        'timestamp': latest_time.isoformat(),\n        'total_slots': len(current_data),\n        'active_slots': len(active_slots),\n        'slots': active_slots.to_dict('records')\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/terminal/guidance', methods=['GET'])\ndef get_terminal_guidance():\n    \"\"\"Get terminal-aware pickup guidance\"\"\"\n    terminal = request.args.get('terminal', 'Terminal 3')\n    \n    if terminal not in TERMINAL_ZONES:\n        return jsonify({'error': f'Terminal {terminal} not found'}), 400\n    \n    terminal_info = TERMINAL_ZONES[terminal]\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots in the terminal's zone\n    zone_coords = terminal_info['pickup_coords']\n    zone_x, zone_y = zone_coords['x'], zone_coords['y']\n    \n    # Find nearest available slots (within reasonable distance)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    if len(active_slots) > 0:\n        # Calculate distances to zone\n        active_slots['distance'] = np.sqrt(\n            (active_slots['x'] - zone_x)**2 + (active_slots['y'] - zone_y)**2\n        )\n        # Find nearest available slot\n        nearest_slot = active_slots.loc[active_slots['distance'].idxmin()]\n        \n        # Estimate ETA (walking time + wait time)\n        # Wait time based on number of available slots (more slots = less wait)\n        available_count = len(active_slots)\n        estimated_wait_minutes = max(2, 10 - (available_count // 5))  # Simple heuristic\n        \n        total_minutes = terminal_info['walking_time_minutes'] + estimated_wait_minutes\n        \n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': estimated_wait_minutes,\n            'total_minutes': total_minutes,\n            'available_slots': len(active_slots),\n            'nearest_slot_id': int(nearest_slot['slot_id']),\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {total_minutes} minutes.\"\n        }\n    else:\n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': 15,  # Default if no slots\n            'total_minutes': terminal_info['walking_time_minutes'] + 15,\n            'available_slots': 0,\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {terminal_info['walking_time_minutes'] + 15} minutes.\"\n        }\n    \n    return jsonify(result)\n\n@app.route('/api/forecast/price-wait', methods=['GET'])\ndef get_price_wait_forecast():\n    \"\"\"Get price and wait time forecast (15-30 min horizon)\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    \n    # Get data from last 30 minutes for rolling average\n    time_window = timedelta(minutes=30)\n    historical_data = df[df['current_time'] >= (latest_time - time_window)].copy()\n    \n    # Calculate metrics over time windows\n    time_buckets = []\n    for i in range(6):  # 6 buckets of 5 minutes each = 30 minutes\n        bucket_start = latest_time - timedelta(minutes=(6-i)*5)\n        bucket_end = latest_time - timedelta(minutes=(5-i)*5) if i < 5 else latest_time\n        bucket_data = historical_data[\n            (historical_data['current_time'] >= bucket_start) & \n            (historical_data['current_time'] < bucket_end)\n        ]\n        \n        active_slots = bucket_data[\n            bucket_data['x'].notna() & bucket_data['y'].notna()\n        ]\n        \n        # Simulate price based on demand (fewer slots = higher price)\n        # Base price + surge multiplier\n        base_price = 15.0\n        availability_ratio = len(active_slots) / len(bucket_data) if len(bucket_data) > 0 else 0\n        surge_multiplier = max(1.0, 2.0 - availability_ratio)\n        price = base_price * surge_multiplier\n        \n        # Wait time based on availability\n        wait_time = max(2, 15 - (len(active_slots) // 3))\n        \n        time_buckets.append({\n            'time': bucket_start.isoformat(),\n            'price': round(price, 2),\n            'wait_time': wait_time,\n            'availability': len(active_slots)\n        })\n    \n    # Calculate rolling averages and trends\n    prices = [b['price'] for b in time_buckets]\n    wait_times = [b['wait_time'] for b in time_buckets]\n    \n    # Rolling average (last 3 buckets)\n    recent_prices = prices[-3:] if len(prices) >= 3 else prices\n    recent_waits = wait_times[-3:] if len(wait_times) >= 3 else wait_times\n    \n    avg_price = np.mean(recent_prices)\n    avg_wait = np.mean(recent_waits)\n    \n    # Calculate slope/trend (linear regression on last 3 points)\n    if len(recent_prices) >= 2:\n        x = np.arange(len(recent_prices))\n        price_slope = np.polyfit(x, recent_prices, 1)[0]\n        wait_slope = np.polyfit(x, recent_waits, 1)[0]\n    else:\n        price_slope = 0\n        wait_slope = 0\n    \n    # Determine trend direction\n    def get_trend(slope, threshold=0.1):\n        if slope > threshold:\n            return 'up'\n        elif slope < -threshold:\n            return 'down'\n        else:\n            return 'flat'\n    \n    price_trend = get_trend(price_slope, threshold=0.5)\n    wait_trend = get_trend(wait_slope, threshold=0.5)\n    \n    # Forecast for next 15-30 minutes\n    forecast_horizon = 20  # minutes\n    forecast_price = avg_price + (price_slope * 4)  # Extrapolate\n    forecast_wait = avg_wait + (wait_slope * 4)\n    \n    # Ensure reasonable bounds\n    forecast_price = max(10.0, min(50.0, forecast_price))\n    forecast_wait = max(2, min(30, int(forecast_wait)))\n    \n    result = {\n        'current': {\n            'price': round(prices[-1] if prices else avg_price, 2),\n            'wait_time': wait_times[-1] if wait_times else int(avg_wait),\n            'timestamp': latest_time.isoformat()\n        },\n        'forecast': {\n            'price': round(forecast_price, 2),\n            'wait_time': forecast_wait,\n            'horizon_minutes': forecast_horizon\n        },\n        'trends': {\n            'price': {\n                'direction': price_trend,\n                'slope': round(price_slope, 3)\n            },\n            'wait_time': {\n                'direction': wait_trend,\n                'slope': round(wait_slope, 3)\n            }\n        },\n        'historical': time_buckets,\n        'sparkline_data': {\n            'prices': prices,\n            'wait_times': wait_times\n        }\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/data/timeseries', methods=['GET'])\ndef get_timeseries_data():\n    \"\"\"Get time series data for visualization\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get unique timestamps\n    unique_times = sorted(df['current_time'].unique())\n    \n    # Aggregate data by timestamp\n    timeseries = []\n    for timestamp in unique_times:\n        time_data = df[df['current_time'] == timestamp]\n        active_slots = time_data[\n            time_data['x'].notna() & time_data['y'].notna()\n        ]\n        \n        timeseries.append({\n            'timestamp': timestamp.isoformat(),\n            'active_slots': len(active_slots),\n            'total_slots': len(time_data)\n        })\n    \n    return jsonify({\n        'timeseries': timeseries,\n        'total_points': len(timeseries)\n    })\n\nif __name__ == '__main__':\n    print(\"Starting Backend API Server...\")\n    print(f\"Data file: {DATA_FILE}\")\n    app.run(debug=True, port=5000, host='0.0.0.0')\n\n"},{"path":"mini-project-3-team-tiger/backend/requirements.txt","size":76,"mtime":1765319489579,"ext":"txt","content":"flask==3.0.0\nflask-cors==4.0.0\npandas==2.1.3\nnumpy==1.26.2\nopenpyxl==3.1.2\n\n"},{"path":"mini-project-3-team-tiger/frontend/app.js","size":9483,"mtime":1765319489579,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5000/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    checkAPIHealth();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected');\n        console.error('API health check failed:', error);\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Please try again.';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Update map visualization\nasync function updateMapVisualization() {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n});\n\n"},{"path":"mini-project-3-team-tiger/frontend/index.html","size":5656,"mtime":1765319489579,"ext":"html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Sky Harbor Airport - Ride-Hailing Dashboard</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <!-- Header -->\n        <header class=\"header\">\n            <h1>‚úàÔ∏è Sky Harbor Airport</h1>\n            <h2>Ride-Hailing Display Dashboard</h2>\n        </header>\n\n        <!-- Terminal Selection Tabs -->\n        <div class=\"terminal-tabs\">\n            <button class=\"tab-button active\" data-terminal=\"Terminal 3\">Terminal 3</button>\n            <button class=\"tab-button\" data-terminal=\"Terminal 4\">Terminal 4</button>\n        </div>\n\n        <!-- Terminal Guidance Banner -->\n        <div id=\"guidance-banner\" class=\"guidance-banner\">\n            <div class=\"banner-content\">\n                <span class=\"banner-icon\">üìç</span>\n                <span id=\"guidance-message\" class=\"guidance-message\">Loading guidance...</span>\n            </div>\n            <div class=\"banner-details\">\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Zone:</span>\n                    <span id=\"zone-name\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Walking Time:</span>\n                    <span id=\"walking-time\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Estimated Wait:</span>\n                    <span id=\"estimated-wait\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Available Slots:</span>\n                    <span id=\"available-slots\" class=\"detail-value\">-</span>\n                </div>\n            </div>\n        </div>\n\n        <!-- Price & Wait Forecast Section -->\n        <div class=\"forecast-section\">\n            <h3>Price & Wait Forecast (15-30 min horizon)</h3>\n            \n            <div class=\"forecast-cards\">\n                <!-- Price Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">üí∞</span>\n                        <span class=\"card-title\">Price Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"price-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"price-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Wait Time Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">‚è±Ô∏è</span>\n                        <span class=\"card-title\">Wait Time Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"wait-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"wait-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- Map Visualization -->\n        <div class=\"map-section\">\n            <h3>Live Map View</h3>\n            <div class=\"map-container\">\n                <img id=\"map-image\" src=\"../assets/map.png\" alt=\"Airport Map\" class=\"map-image\">\n                <canvas id=\"map-overlay\" class=\"map-overlay\"></canvas>\n            </div>\n        </div>\n\n        <!-- Status Footer -->\n        <footer class=\"status-footer\">\n            <div class=\"status-item\">\n                <span class=\"status-label\">Last Updated:</span>\n                <span id=\"last-updated\" class=\"status-value\">-</span>\n            </div>\n            <div class=\"status-item\">\n                <span class=\"status-label\">API Status:</span>\n                <span id=\"api-status\" class=\"status-value\">Checking...</span>\n            </div>\n        </footer>\n    </div>\n\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n"},{"path":"mini-project-3-team-tiger/frontend/styles.css","size":6854,"mtime":1765319489579,"ext":"css","content":"/* Sky Harbor Airport Ride-Hailing Dashboard Styles */\n/* UI/UX Specialist: Responsive and visually appealing interface */\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1400px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 20px;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\n    overflow: hidden;\n}\n\n/* Header */\n.header {\n    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);\n    color: white;\n    padding: 30px;\n    text-align: center;\n}\n\n.header h1 {\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n    font-weight: 700;\n}\n\n.header h2 {\n    font-size: 1.3rem;\n    font-weight: 300;\n    opacity: 0.9;\n}\n\n/* Terminal Tabs */\n.terminal-tabs {\n    display: flex;\n    gap: 10px;\n    padding: 20px;\n    background: #f5f5f5;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.tab-button {\n    flex: 1;\n    padding: 15px 30px;\n    font-size: 1.1rem;\n    font-weight: 600;\n    border: none;\n    border-radius: 10px;\n    background: white;\n    color: #666;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.tab-button:hover {\n    background: #e3f2fd;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);\n}\n\n.tab-button.active {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);\n}\n\n/* Guidance Banner */\n.guidance-banner {\n    margin: 20px;\n    padding: 25px;\n    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);\n    border-radius: 15px;\n    color: white;\n    box-shadow: 0 5px 20px rgba(79, 172, 254, 0.3);\n    animation: slideIn 0.5s ease;\n}\n\n@keyframes slideIn {\n    from {\n        opacity: 0;\n        transform: translateY(-20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.banner-content {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    margin-bottom: 15px;\n}\n\n.banner-icon {\n    font-size: 2rem;\n}\n\n.guidance-message {\n    font-size: 1.4rem;\n    font-weight: 600;\n    flex: 1;\n}\n\n.banner-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n    gap: 15px;\n    margin-top: 15px;\n    padding-top: 15px;\n    border-top: 1px solid rgba(255, 255, 255, 0.3);\n}\n\n.detail-item {\n    display: flex;\n    flex-direction: column;\n    gap: 5px;\n}\n\n.detail-label {\n    font-size: 0.9rem;\n    opacity: 0.9;\n}\n\n.detail-value {\n    font-size: 1.2rem;\n    font-weight: 700;\n}\n\n/* Forecast Section */\n.forecast-section {\n    padding: 30px;\n    background: #fafafa;\n}\n\n.forecast-section h3 {\n    font-size: 1.8rem;\n    margin-bottom: 25px;\n    color: #333;\n    text-align: center;\n}\n\n.forecast-cards {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 25px;\n}\n\n.forecast-card {\n    background: white;\n    border-radius: 15px;\n    padding: 25px;\n    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n    transition: transform 0.3s ease, box-shadow 0.3s ease;\n}\n\n.forecast-card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);\n}\n\n.card-header {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #f0f0f0;\n}\n\n.card-icon {\n    font-size: 1.8rem;\n}\n\n.card-title {\n    font-size: 1.3rem;\n    font-weight: 600;\n    color: #333;\n}\n\n.card-content {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n}\n\n.current-value, .forecast-value {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.value-label {\n    font-size: 0.95rem;\n    color: #666;\n}\n\n.value-amount {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: #2a5298;\n}\n\n/* Trend Badge */\n.trend-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px 15px;\n    border-radius: 20px;\n    font-weight: 600;\n    font-size: 0.9rem;\n    width: fit-content;\n}\n\n.trend-badge.flat {\n    background: #e0e0e0;\n    color: #666;\n}\n\n.trend-badge.up {\n    background: #ffebee;\n    color: #c62828;\n}\n\n.trend-badge.down {\n    background: #e8f5e9;\n    color: #2e7d32;\n}\n\n.trend-icon {\n    font-size: 1.2rem;\n}\n\n.trend-badge.up .trend-icon::before {\n    content: \"‚Üë\";\n}\n\n.trend-badge.down .trend-icon::before {\n    content: \"‚Üì\";\n}\n\n.trend-badge.flat .trend-icon::before {\n    content: \"‚Üí\";\n}\n\n/* Sparkline Container */\n.sparkline-container {\n    margin-top: 10px;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n/* Map Section */\n.map-section {\n    padding: 30px;\n    background: white;\n}\n\n.map-section h3 {\n    font-size: 1.8rem;\n    margin-bottom: 20px;\n    color: #333;\n    text-align: center;\n}\n\n.map-container {\n    position: relative;\n    width: 100%;\n    max-width: 1000px;\n    margin: 0 auto;\n    border-radius: 15px;\n    overflow: hidden;\n    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);\n}\n\n.map-image {\n    width: 100%;\n    height: auto;\n    display: block;\n}\n\n.map-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n}\n\n/* Status Footer */\n.status-footer {\n    display: flex;\n    justify-content: space-around;\n    padding: 20px;\n    background: #f5f5f5;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n    gap: 20px;\n}\n\n.status-item {\n    display: flex;\n    gap: 10px;\n    align-items: center;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #666;\n}\n\n.status-value {\n    color: #333;\n    font-weight: 500;\n}\n\n.status-value.success {\n    color: #2e7d32;\n}\n\n.status-value.error {\n    color: #c62828;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 1.8rem;\n    }\n\n    .header h2 {\n        font-size: 1rem;\n    }\n\n    .guidance-message {\n        font-size: 1.1rem;\n    }\n\n    .forecast-cards {\n        grid-template-columns: 1fr;\n    }\n\n    .banner-details {\n        grid-template-columns: 1fr;\n    }\n\n    .terminal-tabs {\n        flex-direction: column;\n    }\n\n    .tab-button {\n        width: 100%;\n    }\n}\n\n@media (max-width: 480px) {\n    body {\n        padding: 10px;\n    }\n\n    .container {\n        border-radius: 10px;\n    }\n\n    .header {\n        padding: 20px;\n    }\n\n    .forecast-section,\n    .map-section {\n        padding: 20px;\n    }\n}\n\n/* Loading Animation */\n@keyframes pulse {\n    0%, 100% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0.5;\n    }\n}\n\n.loading {\n    animation: pulse 1.5s ease-in-out infinite;\n}\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:34:37.465Z","tree_hash":"18021e6a0f1be38d28563a252fc1d2f13d405f8e215506a0a554449e34d45be7","added":[{"path":"mini-project-3-team-tiger/backend/start_server.sh","size":302,"mtime":1765319674234,"ext":"sh","content":"#!/bin/bash\n# Backend server startup script\n\ncd \"$(dirname \"$0\")\"\necho \"Starting Backend API Server...\"\necho \"Data file: $(python3 -c \"from app import DATA_FILE; print(DATA_FILE)\")\"\necho \"Server will be available at http://localhost:5000\"\necho \"Press Ctrl+C to stop the server\"\necho \"\"\npython3 app.py\n\n"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:35:12.491Z","tree_hash":"608b1da9a10d93d1ea48e05779651bf9c38e2e2e320a8dbc9c71f3b9da04b668","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":10267,"mtime":1765319711737,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5000/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    checkAPIHealth();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Update map visualization\nasync function updateMapVisualization() {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:35:47.518Z","tree_hash":"1a127580b8a6d62b1b547d39c27f4de4b9f6b10a3657798fac7f61922c613213","added":[],"modified":[{"path":"mini-project-3-team-tiger/README.md","size":6599,"mtime":1765319743521,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   Or use the startup script:\n   ```bash\n   ./start_server.sh\n   ```\n\n   The API will be available at `http://localhost:5000`\n   \n   **Important:** Keep this terminal window open while using the dashboard!\n\n### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5000\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000`\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5000/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nIf port 5000 is already in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5001, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:36:27.550Z","tree_hash":"9c4c3005a9a4c54d343d1a1aff9d480737fb2bd6d89ec457ce16887642d3419d","added":[],"modified":[{"path":"mini-project-3-team-tiger/backend/start_server.sh","size":302,"mtime":1765319785849,"ext":"sh","content":"#!/bin/bash\n# Backend server startup script\n\ncd \"$(dirname \"$0\")\"\necho \"Starting Backend API Server...\"\necho \"Data file: $(python3 -c \"from app import DATA_FILE; print(DATA_FILE)\")\"\necho \"Server will be available at http://localhost:5000\"\necho \"Press Ctrl+C to stop the server\"\necho \"\"\npython3 app.py\n\n"},{"path":"mini-project-3-team-tiger/README.md","size":6599,"mtime":1765319785849,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   Or use the startup script:\n   ```bash\n   ./start_server.sh\n   ```\n\n   The API will be available at `http://localhost:5000`\n   \n   **Important:** Keep this terminal window open while using the dashboard!\n\n### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5000\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000`\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5000/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nIf port 5000 is already in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5001, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"},{"path":"mini-project-3-team-tiger/frontend/app.js","size":10267,"mtime":1765319785849,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5000/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    checkAPIHealth();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Update map visualization\nasync function updateMapVisualization() {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:37:37.615Z","tree_hash":"01eb8cb9e8418603ced3da2061f041954edc86cce1e7d9c9a09b687506baf6e4","added":[],"modified":[{"path":"mini-project-3-team-tiger/backend/app.py","size":10136,"mtime":1765319854959,"ext":"py","content":"\"\"\"\nBackend API for Ride-Hailing Display/Dashboard at Sky Harbor Airport\nTechnical Lead: Data processing and API routing\n\"\"\"\n\nfrom flask import Flask, jsonify, request\nfrom flask_cors import CORS\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport os\n\napp = Flask(__name__)\nCORS(app)  # Enable CORS for frontend\n\n# Path to data file\nDATA_FILE = os.path.join(os.path.dirname(__file__), '..', 'assets', 'ride_hailing.xlsx')\n\n# Terminal to pickup zone mapping\nTERMINAL_ZONES = {\n    'Terminal 3': {\n        'zone': 'Zone A',\n        'walking_time_minutes': 3,\n        'pickup_coords': {'x': 300, 'y': 200}  # Approximate zone location\n    },\n    'Terminal 4': {\n        'zone': 'Zone B',\n        'walking_time_minutes': 5,\n        'pickup_coords': {'x': 500, 'y': 300}  # Approximate zone location\n    }\n}\n\n# Load and cache data\ndef load_data():\n    \"\"\"Load ride hailing data from Excel file\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Global data cache\n_data_cache = None\n\ndef get_data():\n    \"\"\"Get cached data or load fresh\"\"\"\n    global _data_cache\n    if _data_cache is None:\n        _data_cache = load_data()\n    return _data_cache.copy()\n\n@app.route('/api/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({'status': 'healthy', 'message': 'Backend API is running'})\n\n@app.route('/api/data/current', methods=['GET'])\ndef get_current_data():\n    \"\"\"Get current ride data\"\"\"\n    df = get_data()\n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots (with valid positions)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    result = {\n        'timestamp': latest_time.isoformat(),\n        'total_slots': len(current_data),\n        'active_slots': len(active_slots),\n        'slots': active_slots.to_dict('records')\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/terminal/guidance', methods=['GET'])\ndef get_terminal_guidance():\n    \"\"\"Get terminal-aware pickup guidance\"\"\"\n    terminal = request.args.get('terminal', 'Terminal 3')\n    \n    if terminal not in TERMINAL_ZONES:\n        return jsonify({'error': f'Terminal {terminal} not found'}), 400\n    \n    terminal_info = TERMINAL_ZONES[terminal]\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots in the terminal's zone\n    zone_coords = terminal_info['pickup_coords']\n    zone_x, zone_y = zone_coords['x'], zone_coords['y']\n    \n    # Find nearest available slots (within reasonable distance)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    if len(active_slots) > 0:\n        # Calculate distances to zone\n        active_slots['distance'] = np.sqrt(\n            (active_slots['x'] - zone_x)**2 + (active_slots['y'] - zone_y)**2\n        )\n        # Find nearest available slot\n        nearest_slot = active_slots.loc[active_slots['distance'].idxmin()]\n        \n        # Estimate ETA (walking time + wait time)\n        # Wait time based on number of available slots (more slots = less wait)\n        available_count = len(active_slots)\n        estimated_wait_minutes = max(2, 10 - (available_count // 5))  # Simple heuristic\n        \n        total_minutes = terminal_info['walking_time_minutes'] + estimated_wait_minutes\n        \n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': estimated_wait_minutes,\n            'total_minutes': total_minutes,\n            'available_slots': len(active_slots),\n            'nearest_slot_id': int(nearest_slot['slot_id']),\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {total_minutes} minutes.\"\n        }\n    else:\n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': 15,  # Default if no slots\n            'total_minutes': terminal_info['walking_time_minutes'] + 15,\n            'available_slots': 0,\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {terminal_info['walking_time_minutes'] + 15} minutes.\"\n        }\n    \n    return jsonify(result)\n\n@app.route('/api/forecast/price-wait', methods=['GET'])\ndef get_price_wait_forecast():\n    \"\"\"Get price and wait time forecast (15-30 min horizon)\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    \n    # Get data from last 30 minutes for rolling average\n    time_window = timedelta(minutes=30)\n    historical_data = df[df['current_time'] >= (latest_time - time_window)].copy()\n    \n    # Calculate metrics over time windows\n    time_buckets = []\n    for i in range(6):  # 6 buckets of 5 minutes each = 30 minutes\n        bucket_start = latest_time - timedelta(minutes=(6-i)*5)\n        bucket_end = latest_time - timedelta(minutes=(5-i)*5) if i < 5 else latest_time\n        bucket_data = historical_data[\n            (historical_data['current_time'] >= bucket_start) & \n            (historical_data['current_time'] < bucket_end)\n        ]\n        \n        active_slots = bucket_data[\n            bucket_data['x'].notna() & bucket_data['y'].notna()\n        ]\n        \n        # Simulate price based on demand (fewer slots = higher price)\n        # Base price + surge multiplier\n        base_price = 15.0\n        availability_ratio = len(active_slots) / len(bucket_data) if len(bucket_data) > 0 else 0\n        surge_multiplier = max(1.0, 2.0 - availability_ratio)\n        price = base_price * surge_multiplier\n        \n        # Wait time based on availability\n        wait_time = max(2, 15 - (len(active_slots) // 3))\n        \n        time_buckets.append({\n            'time': bucket_start.isoformat(),\n            'price': round(price, 2),\n            'wait_time': wait_time,\n            'availability': len(active_slots)\n        })\n    \n    # Calculate rolling averages and trends\n    prices = [b['price'] for b in time_buckets]\n    wait_times = [b['wait_time'] for b in time_buckets]\n    \n    # Rolling average (last 3 buckets)\n    recent_prices = prices[-3:] if len(prices) >= 3 else prices\n    recent_waits = wait_times[-3:] if len(wait_times) >= 3 else wait_times\n    \n    avg_price = np.mean(recent_prices)\n    avg_wait = np.mean(recent_waits)\n    \n    # Calculate slope/trend (linear regression on last 3 points)\n    if len(recent_prices) >= 2:\n        x = np.arange(len(recent_prices))\n        price_slope = np.polyfit(x, recent_prices, 1)[0]\n        wait_slope = np.polyfit(x, recent_waits, 1)[0]\n    else:\n        price_slope = 0\n        wait_slope = 0\n    \n    # Determine trend direction\n    def get_trend(slope, threshold=0.1):\n        if slope > threshold:\n            return 'up'\n        elif slope < -threshold:\n            return 'down'\n        else:\n            return 'flat'\n    \n    price_trend = get_trend(price_slope, threshold=0.5)\n    wait_trend = get_trend(wait_slope, threshold=0.5)\n    \n    # Forecast for next 15-30 minutes\n    forecast_horizon = 20  # minutes\n    forecast_price = avg_price + (price_slope * 4)  # Extrapolate\n    forecast_wait = avg_wait + (wait_slope * 4)\n    \n    # Ensure reasonable bounds\n    forecast_price = max(10.0, min(50.0, forecast_price))\n    forecast_wait = max(2, min(30, int(forecast_wait)))\n    \n    result = {\n        'current': {\n            'price': round(prices[-1] if prices else avg_price, 2),\n            'wait_time': wait_times[-1] if wait_times else int(avg_wait),\n            'timestamp': latest_time.isoformat()\n        },\n        'forecast': {\n            'price': round(forecast_price, 2),\n            'wait_time': forecast_wait,\n            'horizon_minutes': forecast_horizon\n        },\n        'trends': {\n            'price': {\n                'direction': price_trend,\n                'slope': round(price_slope, 3)\n            },\n            'wait_time': {\n                'direction': wait_trend,\n                'slope': round(wait_slope, 3)\n            }\n        },\n        'historical': time_buckets,\n        'sparkline_data': {\n            'prices': prices,\n            'wait_times': wait_times\n        }\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/data/timeseries', methods=['GET'])\ndef get_timeseries_data():\n    \"\"\"Get time series data for visualization\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get unique timestamps\n    unique_times = sorted(df['current_time'].unique())\n    \n    # Aggregate data by timestamp\n    timeseries = []\n    for timestamp in unique_times:\n        time_data = df[df['current_time'] == timestamp]\n        active_slots = time_data[\n            time_data['x'].notna() & time_data['y'].notna()\n        ]\n        \n        timeseries.append({\n            'timestamp': timestamp.isoformat(),\n            'active_slots': len(active_slots),\n            'total_slots': len(time_data)\n        })\n    \n    return jsonify({\n        'timeseries': timeseries,\n        'total_points': len(timeseries)\n    })\n\nif __name__ == '__main__':\n    print(\"Starting Backend API Server...\")\n    print(f\"Data file: {DATA_FILE}\")\n    # Use port 5001 to avoid conflict with macOS AirPlay Receiver on port 5000\n    app.run(debug=True, port=5001, host='0.0.0.0')\n\n"},{"path":"mini-project-3-team-tiger/frontend/app.js","size":10267,"mtime":1765319855776,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    checkAPIHealth();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Update map visualization\nasync function updateMapVisualization() {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n});\n\n"},{"path":"mini-project-3-team-tiger/README.md","size":6698,"mtime":1765319857016,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   Or use the startup script:\n   ```bash\n   ./start_server.sh\n   ```\n\n   The API will be available at `http://localhost:5001`\n   \n   **Note:** Port 5001 is used instead of 5000 to avoid conflicts with macOS AirPlay Receiver.\n   \n   **Important:** Keep this terminal window open while using the dashboard!\n\n### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5000\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000`\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5000/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nIf port 5000 is already in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5001, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:37:42.613Z","tree_hash":"cad45db2f6d176c92c750940effefa9627b9c43a2eb4364d0737f013a90e5df1","added":[],"modified":[{"path":"mini-project-3-team-tiger/README.md","size":6698,"mtime":1765319859223,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   Or use the startup script:\n   ```bash\n   ./start_server.sh\n   ```\n\n   The API will be available at `http://localhost:5001`\n   \n   **Note:** Port 5001 is used instead of 5000 to avoid conflicts with macOS AirPlay Receiver.\n   \n   **Important:** Keep this terminal window open while using the dashboard!\n\n### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5001\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000`\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5001/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nIf port 5000 is already in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5001, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:37:47.613Z","tree_hash":"c3735b283b3c4f0f5f72db8d6f763f1079947597f2cafdc8b540e4fec9dd92fe","added":[],"modified":[{"path":"mini-project-3-team-tiger/README.md","size":6804,"mtime":1765319863371,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   Or use the startup script:\n   ```bash\n   ./start_server.sh\n   ```\n\n   The API will be available at `http://localhost:5001`\n   \n   **Note:** Port 5001 is used instead of 5000 to avoid conflicts with macOS AirPlay Receiver.\n   \n   **Important:** Keep this terminal window open while using the dashboard!\n\n### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5001\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000`\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5001/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nThe backend uses port 5001 by default to avoid conflicts with macOS AirPlay Receiver (which uses port 5000). If port 5001 is also in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5002, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:37:57.691Z","tree_hash":"84921dfe8020eddad3148c70ce2577728a023c55f8ab425dfe11a5834cb1061e","added":[],"modified":[{"path":"mini-project-3-team-tiger/README.md","size":6804,"mtime":1765319873665,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   Or use the startup script:\n   ```bash\n   ./start_server.sh\n   ```\n\n   The API will be available at `http://localhost:5001`\n   \n   **Note:** Port 5001 is used instead of 5000 to avoid conflicts with macOS AirPlay Receiver.\n   \n   **Important:** Keep this terminal window open while using the dashboard!\n\n### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5001\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000`\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5001/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nThe backend uses port 5001 by default to avoid conflicts with macOS AirPlay Receiver (which uses port 5000). If port 5001 is also in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5002, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"},{"path":"mini-project-3-team-tiger/backend/app.py","size":10136,"mtime":1765319873665,"ext":"py","content":"\"\"\"\nBackend API for Ride-Hailing Display/Dashboard at Sky Harbor Airport\nTechnical Lead: Data processing and API routing\n\"\"\"\n\nfrom flask import Flask, jsonify, request\nfrom flask_cors import CORS\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport os\n\napp = Flask(__name__)\nCORS(app)  # Enable CORS for frontend\n\n# Path to data file\nDATA_FILE = os.path.join(os.path.dirname(__file__), '..', 'assets', 'ride_hailing.xlsx')\n\n# Terminal to pickup zone mapping\nTERMINAL_ZONES = {\n    'Terminal 3': {\n        'zone': 'Zone A',\n        'walking_time_minutes': 3,\n        'pickup_coords': {'x': 300, 'y': 200}  # Approximate zone location\n    },\n    'Terminal 4': {\n        'zone': 'Zone B',\n        'walking_time_minutes': 5,\n        'pickup_coords': {'x': 500, 'y': 300}  # Approximate zone location\n    }\n}\n\n# Load and cache data\ndef load_data():\n    \"\"\"Load ride hailing data from Excel file\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Global data cache\n_data_cache = None\n\ndef get_data():\n    \"\"\"Get cached data or load fresh\"\"\"\n    global _data_cache\n    if _data_cache is None:\n        _data_cache = load_data()\n    return _data_cache.copy()\n\n@app.route('/api/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({'status': 'healthy', 'message': 'Backend API is running'})\n\n@app.route('/api/data/current', methods=['GET'])\ndef get_current_data():\n    \"\"\"Get current ride data\"\"\"\n    df = get_data()\n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots (with valid positions)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    result = {\n        'timestamp': latest_time.isoformat(),\n        'total_slots': len(current_data),\n        'active_slots': len(active_slots),\n        'slots': active_slots.to_dict('records')\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/terminal/guidance', methods=['GET'])\ndef get_terminal_guidance():\n    \"\"\"Get terminal-aware pickup guidance\"\"\"\n    terminal = request.args.get('terminal', 'Terminal 3')\n    \n    if terminal not in TERMINAL_ZONES:\n        return jsonify({'error': f'Terminal {terminal} not found'}), 400\n    \n    terminal_info = TERMINAL_ZONES[terminal]\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots in the terminal's zone\n    zone_coords = terminal_info['pickup_coords']\n    zone_x, zone_y = zone_coords['x'], zone_coords['y']\n    \n    # Find nearest available slots (within reasonable distance)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    if len(active_slots) > 0:\n        # Calculate distances to zone\n        active_slots['distance'] = np.sqrt(\n            (active_slots['x'] - zone_x)**2 + (active_slots['y'] - zone_y)**2\n        )\n        # Find nearest available slot\n        nearest_slot = active_slots.loc[active_slots['distance'].idxmin()]\n        \n        # Estimate ETA (walking time + wait time)\n        # Wait time based on number of available slots (more slots = less wait)\n        available_count = len(active_slots)\n        estimated_wait_minutes = max(2, 10 - (available_count // 5))  # Simple heuristic\n        \n        total_minutes = terminal_info['walking_time_minutes'] + estimated_wait_minutes\n        \n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': estimated_wait_minutes,\n            'total_minutes': total_minutes,\n            'available_slots': len(active_slots),\n            'nearest_slot_id': int(nearest_slot['slot_id']),\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {total_minutes} minutes.\"\n        }\n    else:\n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': 15,  # Default if no slots\n            'total_minutes': terminal_info['walking_time_minutes'] + 15,\n            'available_slots': 0,\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {terminal_info['walking_time_minutes'] + 15} minutes.\"\n        }\n    \n    return jsonify(result)\n\n@app.route('/api/forecast/price-wait', methods=['GET'])\ndef get_price_wait_forecast():\n    \"\"\"Get price and wait time forecast (15-30 min horizon)\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    \n    # Get data from last 30 minutes for rolling average\n    time_window = timedelta(minutes=30)\n    historical_data = df[df['current_time'] >= (latest_time - time_window)].copy()\n    \n    # Calculate metrics over time windows\n    time_buckets = []\n    for i in range(6):  # 6 buckets of 5 minutes each = 30 minutes\n        bucket_start = latest_time - timedelta(minutes=(6-i)*5)\n        bucket_end = latest_time - timedelta(minutes=(5-i)*5) if i < 5 else latest_time\n        bucket_data = historical_data[\n            (historical_data['current_time'] >= bucket_start) & \n            (historical_data['current_time'] < bucket_end)\n        ]\n        \n        active_slots = bucket_data[\n            bucket_data['x'].notna() & bucket_data['y'].notna()\n        ]\n        \n        # Simulate price based on demand (fewer slots = higher price)\n        # Base price + surge multiplier\n        base_price = 15.0\n        availability_ratio = len(active_slots) / len(bucket_data) if len(bucket_data) > 0 else 0\n        surge_multiplier = max(1.0, 2.0 - availability_ratio)\n        price = base_price * surge_multiplier\n        \n        # Wait time based on availability\n        wait_time = max(2, 15 - (len(active_slots) // 3))\n        \n        time_buckets.append({\n            'time': bucket_start.isoformat(),\n            'price': round(price, 2),\n            'wait_time': wait_time,\n            'availability': len(active_slots)\n        })\n    \n    # Calculate rolling averages and trends\n    prices = [b['price'] for b in time_buckets]\n    wait_times = [b['wait_time'] for b in time_buckets]\n    \n    # Rolling average (last 3 buckets)\n    recent_prices = prices[-3:] if len(prices) >= 3 else prices\n    recent_waits = wait_times[-3:] if len(wait_times) >= 3 else wait_times\n    \n    avg_price = np.mean(recent_prices)\n    avg_wait = np.mean(recent_waits)\n    \n    # Calculate slope/trend (linear regression on last 3 points)\n    if len(recent_prices) >= 2:\n        x = np.arange(len(recent_prices))\n        price_slope = np.polyfit(x, recent_prices, 1)[0]\n        wait_slope = np.polyfit(x, recent_waits, 1)[0]\n    else:\n        price_slope = 0\n        wait_slope = 0\n    \n    # Determine trend direction\n    def get_trend(slope, threshold=0.1):\n        if slope > threshold:\n            return 'up'\n        elif slope < -threshold:\n            return 'down'\n        else:\n            return 'flat'\n    \n    price_trend = get_trend(price_slope, threshold=0.5)\n    wait_trend = get_trend(wait_slope, threshold=0.5)\n    \n    # Forecast for next 15-30 minutes\n    forecast_horizon = 20  # minutes\n    forecast_price = avg_price + (price_slope * 4)  # Extrapolate\n    forecast_wait = avg_wait + (wait_slope * 4)\n    \n    # Ensure reasonable bounds\n    forecast_price = max(10.0, min(50.0, forecast_price))\n    forecast_wait = max(2, min(30, int(forecast_wait)))\n    \n    result = {\n        'current': {\n            'price': round(prices[-1] if prices else avg_price, 2),\n            'wait_time': wait_times[-1] if wait_times else int(avg_wait),\n            'timestamp': latest_time.isoformat()\n        },\n        'forecast': {\n            'price': round(forecast_price, 2),\n            'wait_time': forecast_wait,\n            'horizon_minutes': forecast_horizon\n        },\n        'trends': {\n            'price': {\n                'direction': price_trend,\n                'slope': round(price_slope, 3)\n            },\n            'wait_time': {\n                'direction': wait_trend,\n                'slope': round(wait_slope, 3)\n            }\n        },\n        'historical': time_buckets,\n        'sparkline_data': {\n            'prices': prices,\n            'wait_times': wait_times\n        }\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/data/timeseries', methods=['GET'])\ndef get_timeseries_data():\n    \"\"\"Get time series data for visualization\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get unique timestamps\n    unique_times = sorted(df['current_time'].unique())\n    \n    # Aggregate data by timestamp\n    timeseries = []\n    for timestamp in unique_times:\n        time_data = df[df['current_time'] == timestamp]\n        active_slots = time_data[\n            time_data['x'].notna() & time_data['y'].notna()\n        ]\n        \n        timeseries.append({\n            'timestamp': timestamp.isoformat(),\n            'active_slots': len(active_slots),\n            'total_slots': len(time_data)\n        })\n    \n    return jsonify({\n        'timeseries': timeseries,\n        'total_points': len(timeseries)\n    })\n\nif __name__ == '__main__':\n    print(\"Starting Backend API Server...\")\n    print(f\"Data file: {DATA_FILE}\")\n    # Use port 5001 to avoid conflict with macOS AirPlay Receiver on port 5000\n    app.run(debug=True, port=5001, host='0.0.0.0')\n\n"},{"path":"mini-project-3-team-tiger/frontend/app.js","size":10267,"mtime":1765319873665,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    checkAPIHealth();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Update map visualization\nasync function updateMapVisualization() {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:40:27.734Z","tree_hash":"58d41691b5320b4354171bdcc28b5ddabf9e4f8fd87a589873d5e0343664a2ba","added":[],"modified":[{"path":"mini-project-3-team-tiger/backend/app.py","size":12082,"mtime":1765320025899,"ext":"py","content":"\"\"\"\nBackend API for Ride-Hailing Display/Dashboard at Sky Harbor Airport\nTechnical Lead: Data processing and API routing\n\"\"\"\n\nfrom flask import Flask, jsonify, request\nfrom flask_cors import CORS\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport os\n\napp = Flask(__name__)\nCORS(app)  # Enable CORS for frontend\n\n# Path to data file\nDATA_FILE = os.path.join(os.path.dirname(__file__), '..', 'assets', 'ride_hailing.xlsx')\n\n# Terminal to pickup zone mapping\nTERMINAL_ZONES = {\n    'Terminal 3': {\n        'zone': 'Zone A',\n        'walking_time_minutes': 3,\n        'pickup_coords': {'x': 300, 'y': 200}  # Approximate zone location\n    },\n    'Terminal 4': {\n        'zone': 'Zone B',\n        'walking_time_minutes': 5,\n        'pickup_coords': {'x': 500, 'y': 300}  # Approximate zone location\n    }\n}\n\n# Load and cache data\ndef load_data():\n    \"\"\"Load ride hailing data from Excel file\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Global data cache\n_data_cache = None\n\ndef get_data():\n    \"\"\"Get cached data or load fresh\"\"\"\n    global _data_cache\n    if _data_cache is None:\n        _data_cache = load_data()\n    return _data_cache.copy()\n\n@app.route('/api/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({'status': 'healthy', 'message': 'Backend API is running'})\n\n@app.route('/api/data/current', methods=['GET'])\ndef get_current_data():\n    \"\"\"Get current ride data\"\"\"\n    df = get_data()\n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots (with valid positions)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    result = {\n        'timestamp': latest_time.isoformat(),\n        'total_slots': len(current_data),\n        'active_slots': len(active_slots),\n        'slots': active_slots.to_dict('records')\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/terminal/guidance', methods=['GET'])\ndef get_terminal_guidance():\n    \"\"\"Get terminal-aware pickup guidance\"\"\"\n    terminal = request.args.get('terminal', 'Terminal 3')\n    \n    if terminal not in TERMINAL_ZONES:\n        return jsonify({'error': f'Terminal {terminal} not found'}), 400\n    \n    terminal_info = TERMINAL_ZONES[terminal]\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots in the terminal's zone\n    zone_coords = terminal_info['pickup_coords']\n    zone_x, zone_y = zone_coords['x'], zone_coords['y']\n    \n    # Find nearest available slots (within reasonable distance)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    if len(active_slots) > 0:\n        # Calculate distances to zone\n        active_slots['distance'] = np.sqrt(\n            (active_slots['x'] - zone_x)**2 + (active_slots['y'] - zone_y)**2\n        )\n        # Find nearest available slot\n        nearest_slot = active_slots.loc[active_slots['distance'].idxmin()]\n        \n        # Estimate ETA (walking time + wait time)\n        # Wait time based on number of available slots (more slots = less wait)\n        available_count = len(active_slots)\n        estimated_wait_minutes = max(2, 10 - (available_count // 5))  # Simple heuristic\n        \n        total_minutes = terminal_info['walking_time_minutes'] + estimated_wait_minutes\n        \n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': estimated_wait_minutes,\n            'total_minutes': total_minutes,\n            'available_slots': len(active_slots),\n            'nearest_slot_id': int(nearest_slot['slot_id']),\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {total_minutes} minutes.\"\n        }\n    else:\n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': 15,  # Default if no slots\n            'total_minutes': terminal_info['walking_time_minutes'] + 15,\n            'available_slots': 0,\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {terminal_info['walking_time_minutes'] + 15} minutes.\"\n        }\n    \n    return jsonify(result)\n\n@app.route('/api/forecast/price-wait', methods=['GET'])\ndef get_price_wait_forecast():\n    \"\"\"Get price and wait time forecast (15-30 min horizon)\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    \n    # Get data from last 30 minutes for rolling average\n    time_window = timedelta(minutes=30)\n    historical_data = df[df['current_time'] >= (latest_time - time_window)].copy()\n    \n    # Calculate metrics over time windows\n    time_buckets = []\n    for i in range(6):  # 6 buckets of 5 minutes each = 30 minutes\n        bucket_start = latest_time - timedelta(minutes=(6-i)*5)\n        bucket_end = latest_time - timedelta(minutes=(5-i)*5) if i < 5 else latest_time\n        bucket_data = historical_data[\n            (historical_data['current_time'] >= bucket_start) & \n            (historical_data['current_time'] < bucket_end)\n        ]\n        \n        active_slots = bucket_data[\n            bucket_data['x'].notna() & bucket_data['y'].notna()\n        ]\n        \n        # Simulate price based on demand (fewer slots = higher price)\n        # Base price + surge multiplier\n        base_price = 15.0\n        availability_ratio = len(active_slots) / len(bucket_data) if len(bucket_data) > 0 else 0\n        surge_multiplier = max(1.0, 2.0 - availability_ratio)\n        price = base_price * surge_multiplier\n        \n        # Wait time based on availability\n        wait_time = max(2, 15 - (len(active_slots) // 3))\n        \n        time_buckets.append({\n            'time': bucket_start.isoformat(),\n            'price': round(price, 2),\n            'wait_time': wait_time,\n            'availability': len(active_slots)\n        })\n    \n    # Calculate rolling averages and trends\n    prices = [b['price'] for b in time_buckets]\n    wait_times = [b['wait_time'] for b in time_buckets]\n    \n    # Rolling average (last 3 buckets)\n    recent_prices = prices[-3:] if len(prices) >= 3 else prices\n    recent_waits = wait_times[-3:] if len(wait_times) >= 3 else wait_times\n    \n    avg_price = np.mean(recent_prices)\n    avg_wait = np.mean(recent_waits)\n    \n    # Calculate slope/trend (linear regression on last 3 points)\n    if len(recent_prices) >= 2:\n        x = np.arange(len(recent_prices))\n        price_slope = np.polyfit(x, recent_prices, 1)[0]\n        wait_slope = np.polyfit(x, recent_waits, 1)[0]\n    else:\n        price_slope = 0\n        wait_slope = 0\n    \n    # Determine trend direction\n    def get_trend(slope, threshold=0.1):\n        if slope > threshold:\n            return 'up'\n        elif slope < -threshold:\n            return 'down'\n        else:\n            return 'flat'\n    \n    price_trend = get_trend(price_slope, threshold=0.5)\n    wait_trend = get_trend(wait_slope, threshold=0.5)\n    \n    # Forecast for next 15-30 minutes\n    forecast_horizon = 20  # minutes\n    forecast_price = avg_price + (price_slope * 4)  # Extrapolate\n    forecast_wait = avg_wait + (wait_slope * 4)\n    \n    # Ensure reasonable bounds\n    forecast_price = max(10.0, min(50.0, forecast_price))\n    forecast_wait = max(2, min(30, int(forecast_wait)))\n    \n    result = {\n        'current': {\n            'price': round(prices[-1] if prices else avg_price, 2),\n            'wait_time': wait_times[-1] if wait_times else int(avg_wait),\n            'timestamp': latest_time.isoformat()\n        },\n        'forecast': {\n            'price': round(forecast_price, 2),\n            'wait_time': forecast_wait,\n            'horizon_minutes': forecast_horizon\n        },\n        'trends': {\n            'price': {\n                'direction': price_trend,\n                'slope': round(price_slope, 3)\n            },\n            'wait_time': {\n                'direction': wait_trend,\n                'slope': round(wait_slope, 3)\n            }\n        },\n        'historical': time_buckets,\n        'sparkline_data': {\n            'prices': prices,\n            'wait_times': wait_times\n        }\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/data/timeseries', methods=['GET'])\ndef get_timeseries_data():\n    \"\"\"Get time series data for visualization\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get unique timestamps\n    unique_times = sorted(df['current_time'].unique())\n    \n    # Aggregate data by timestamp\n    timeseries = []\n    for timestamp in unique_times:\n        time_data = df[df['current_time'] == timestamp]\n        active_slots = time_data[\n            time_data['x'].notna() & time_data['y'].notna()\n        ]\n        \n        timeseries.append({\n            'timestamp': timestamp.isoformat(),\n            'active_slots': len(active_slots),\n            'total_slots': len(time_data)\n        })\n    \n    return jsonify({\n        'timeseries': timeseries,\n        'total_points': len(timeseries)\n    })\n\n@app.route('/api/data/time/<timestamp>', methods=['GET'])\ndef get_data_by_time(timestamp):\n    \"\"\"Get ride data for a specific timestamp\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    try:\n        # Parse timestamp (accept ISO format or simple format)\n        try:\n            target_time = pd.to_datetime(timestamp)\n        except:\n            # Try parsing as ISO string\n            target_time = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))\n        \n        # Find closest timestamp (exact match preferred)\n        time_data = df[df['current_time'] == target_time].copy()\n        \n        if len(time_data) == 0:\n            # Find closest timestamp\n            unique_times = sorted(df['current_time'].unique())\n            closest_time = min(unique_times, key=lambda x: abs((x - target_time).total_seconds()))\n            time_data = df[df['current_time'] == closest_time].copy()\n            target_time = closest_time\n        \n        # Filter active slots\n        active_slots = time_data[\n            time_data['x'].notna() & time_data['y'].notna()\n        ].copy()\n        \n        result = {\n            'timestamp': target_time.isoformat(),\n            'total_slots': len(time_data),\n            'active_slots': len(active_slots),\n            'slots': active_slots.to_dict('records')\n        }\n        \n        return jsonify(result)\n    except Exception as e:\n        return jsonify({'error': f'Invalid timestamp: {str(e)}'}), 400\n\n@app.route('/api/data/timestamps', methods=['GET'])\ndef get_available_timestamps():\n    \"\"\"Get list of all available timestamps\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    unique_times = sorted(df['current_time'].unique())\n    \n    return jsonify({\n        'timestamps': [t.isoformat() for t in unique_times],\n        'count': len(unique_times)\n    })\n\nif __name__ == '__main__':\n    print(\"Starting Backend API Server...\")\n    print(f\"Data file: {DATA_FILE}\")\n    # Use port 5001 to avoid conflict with macOS AirPlay Receiver on port 5000\n    app.run(debug=True, port=5001, host='0.0.0.0')\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:40:37.747Z","tree_hash":"3e13eeaa1661dd645645f0241fa6498820071c977e8fa0678e47f2657601b269","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/index.html","size":6340,"mtime":1765320033157,"ext":"html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Sky Harbor Airport - Ride-Hailing Dashboard</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <!-- Header -->\n        <header class=\"header\">\n            <h1>‚úàÔ∏è Sky Harbor Airport</h1>\n            <h2>Ride-Hailing Display Dashboard</h2>\n        </header>\n\n        <!-- Terminal Selection Tabs -->\n        <div class=\"terminal-tabs\">\n            <button class=\"tab-button active\" data-terminal=\"Terminal 3\">Terminal 3</button>\n            <button class=\"tab-button\" data-terminal=\"Terminal 4\">Terminal 4</button>\n        </div>\n\n        <!-- Terminal Guidance Banner -->\n        <div id=\"guidance-banner\" class=\"guidance-banner\">\n            <div class=\"banner-content\">\n                <span class=\"banner-icon\">üìç</span>\n                <span id=\"guidance-message\" class=\"guidance-message\">Loading guidance...</span>\n            </div>\n            <div class=\"banner-details\">\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Zone:</span>\n                    <span id=\"zone-name\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Walking Time:</span>\n                    <span id=\"walking-time\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Estimated Wait:</span>\n                    <span id=\"estimated-wait\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Available Slots:</span>\n                    <span id=\"available-slots\" class=\"detail-value\">-</span>\n                </div>\n            </div>\n        </div>\n\n        <!-- Price & Wait Forecast Section -->\n        <div class=\"forecast-section\">\n            <h3>Price & Wait Forecast (15-30 min horizon)</h3>\n            \n            <div class=\"forecast-cards\">\n                <!-- Price Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">üí∞</span>\n                        <span class=\"card-title\">Price Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"price-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"price-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Wait Time Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">‚è±Ô∏è</span>\n                        <span class=\"card-title\">Wait Time Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"wait-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"wait-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- Map Visualization -->\n        <div class=\"map-section\">\n            <div class=\"map-header\">\n                <h3>Live Map View</h3>\n                <div class=\"animation-controls\">\n                    <button id=\"play-pause-btn\" class=\"control-btn\">‚è∏Ô∏è Pause</button>\n                    <button id=\"speed-down-btn\" class=\"control-btn\">‚è™ Slow</button>\n                    <span id=\"speed-indicator\" class=\"speed-indicator\">1x</span>\n                    <button id=\"speed-up-btn\" class=\"control-btn\">‚è© Fast</button>\n                    <button id=\"reset-btn\" class=\"control-btn\">üîÑ Reset</button>\n                </div>\n            </div>\n            <div class=\"time-display\">\n                <span id=\"current-time-display\">Time: --:--:--</span>\n            </div>\n            <div class=\"map-container\">\n                <img id=\"map-image\" src=\"../assets/map.png\" alt=\"Airport Map\" class=\"map-image\">\n                <canvas id=\"map-overlay\" class=\"map-overlay\"></canvas>\n            </div>\n        </div>\n\n        <!-- Status Footer -->\n        <footer class=\"status-footer\">\n            <div class=\"status-item\">\n                <span class=\"status-label\">Last Updated:</span>\n                <span id=\"last-updated\" class=\"status-value\">-</span>\n            </div>\n            <div class=\"status-item\">\n                <span class=\"status-label\">API Status:</span>\n                <span id=\"api-status\" class=\"status-value\">Checking...</span>\n            </div>\n        </footer>\n    </div>\n\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n"},{"path":"mini-project-3-team-tiger/frontend/app.js","size":10548,"mtime":1765320036069,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: true,\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Update map visualization\nasync function updateMapVisualization() {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:41:12.765Z","tree_hash":"06a048047bda238ec29b9e75dbde2eba6a9a4c7d65195b1c529c6fe48d8e30ae","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":18077,"mtime":1765320071929,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: true,\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        const data = await response.json();\n        \n        if (data.error || !data.timestamps) return;\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Start animation if playing\n        if (animationState.isPlaying) {\n            startAnimation();\n        } else {\n            // Just load current frame\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        for (const slot of data.slots) {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Load and draw license plate image if available\n                if (slot.plate_number) {\n                    const plateImg = await loadPlateImage(slot.plate_number);\n                    if (plateImg) {\n                        // Draw license plate image\n                        const plateSize = slotSize * 0.9;\n                        mapContext.drawImage(\n                            plateImg,\n                            x - plateSize / 2,\n                            y - plateSize / 2,\n                            plateSize,\n                            plateSize\n                        );\n                    }\n                }\n                \n                // Draw slot ID label\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        }\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:41:17.764Z","tree_hash":"30f92dae7d20e780697c82b3d7e3b19431883bc79750c458d29e775a1049d9e3","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":18098,"mtime":1765320073917,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: true,\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        const data = await response.json();\n        \n        if (data.error || !data.timestamps) return;\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Start animation if playing\n        if (animationState.isPlaying) {\n            startAnimation();\n        } else {\n            // Just load current frame\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        for (const slot of data.slots) {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Load and draw license plate image if available\n                if (slot.plate_number) {\n                    const plateImg = await loadPlateImage(slot.plate_number);\n                    if (plateImg) {\n                        // Draw license plate image\n                        const plateSize = slotSize * 0.9;\n                        mapContext.drawImage(\n                            plateImg,\n                            x - plateSize / 2,\n                            y - plateSize / 2,\n                            plateSize,\n                            plateSize\n                        );\n                    }\n                }\n                \n                // Draw slot ID label\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        }\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:41:22.766Z","tree_hash":"fb56f2d28765970b386f9c1678a5552d26f95ef21b6368b996d6a5e26db8ebde","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/styles.css","size":7938,"mtime":1765320079717,"ext":"css","content":"/* Sky Harbor Airport Ride-Hailing Dashboard Styles */\n/* UI/UX Specialist: Responsive and visually appealing interface */\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1400px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 20px;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\n    overflow: hidden;\n}\n\n/* Header */\n.header {\n    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);\n    color: white;\n    padding: 30px;\n    text-align: center;\n}\n\n.header h1 {\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n    font-weight: 700;\n}\n\n.header h2 {\n    font-size: 1.3rem;\n    font-weight: 300;\n    opacity: 0.9;\n}\n\n/* Terminal Tabs */\n.terminal-tabs {\n    display: flex;\n    gap: 10px;\n    padding: 20px;\n    background: #f5f5f5;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.tab-button {\n    flex: 1;\n    padding: 15px 30px;\n    font-size: 1.1rem;\n    font-weight: 600;\n    border: none;\n    border-radius: 10px;\n    background: white;\n    color: #666;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.tab-button:hover {\n    background: #e3f2fd;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);\n}\n\n.tab-button.active {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);\n}\n\n/* Guidance Banner */\n.guidance-banner {\n    margin: 20px;\n    padding: 25px;\n    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);\n    border-radius: 15px;\n    color: white;\n    box-shadow: 0 5px 20px rgba(79, 172, 254, 0.3);\n    animation: slideIn 0.5s ease;\n}\n\n@keyframes slideIn {\n    from {\n        opacity: 0;\n        transform: translateY(-20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.banner-content {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    margin-bottom: 15px;\n}\n\n.banner-icon {\n    font-size: 2rem;\n}\n\n.guidance-message {\n    font-size: 1.4rem;\n    font-weight: 600;\n    flex: 1;\n}\n\n.banner-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n    gap: 15px;\n    margin-top: 15px;\n    padding-top: 15px;\n    border-top: 1px solid rgba(255, 255, 255, 0.3);\n}\n\n.detail-item {\n    display: flex;\n    flex-direction: column;\n    gap: 5px;\n}\n\n.detail-label {\n    font-size: 0.9rem;\n    opacity: 0.9;\n}\n\n.detail-value {\n    font-size: 1.2rem;\n    font-weight: 700;\n}\n\n/* Forecast Section */\n.forecast-section {\n    padding: 30px;\n    background: #fafafa;\n}\n\n.forecast-section h3 {\n    font-size: 1.8rem;\n    margin-bottom: 25px;\n    color: #333;\n    text-align: center;\n}\n\n.forecast-cards {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 25px;\n}\n\n.forecast-card {\n    background: white;\n    border-radius: 15px;\n    padding: 25px;\n    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n    transition: transform 0.3s ease, box-shadow 0.3s ease;\n}\n\n.forecast-card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);\n}\n\n.card-header {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #f0f0f0;\n}\n\n.card-icon {\n    font-size: 1.8rem;\n}\n\n.card-title {\n    font-size: 1.3rem;\n    font-weight: 600;\n    color: #333;\n}\n\n.card-content {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n}\n\n.current-value, .forecast-value {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.value-label {\n    font-size: 0.95rem;\n    color: #666;\n}\n\n.value-amount {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: #2a5298;\n}\n\n/* Trend Badge */\n.trend-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px 15px;\n    border-radius: 20px;\n    font-weight: 600;\n    font-size: 0.9rem;\n    width: fit-content;\n}\n\n.trend-badge.flat {\n    background: #e0e0e0;\n    color: #666;\n}\n\n.trend-badge.up {\n    background: #ffebee;\n    color: #c62828;\n}\n\n.trend-badge.down {\n    background: #e8f5e9;\n    color: #2e7d32;\n}\n\n.trend-icon {\n    font-size: 1.2rem;\n}\n\n.trend-badge.up .trend-icon::before {\n    content: \"‚Üë\";\n}\n\n.trend-badge.down .trend-icon::before {\n    content: \"‚Üì\";\n}\n\n.trend-badge.flat .trend-icon::before {\n    content: \"‚Üí\";\n}\n\n/* Sparkline Container */\n.sparkline-container {\n    margin-top: 10px;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n/* Map Section */\n.map-section {\n    padding: 30px;\n    background: white;\n}\n\n.map-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 15px;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.map-section h3 {\n    font-size: 1.8rem;\n    margin: 0;\n    color: #333;\n}\n\n.animation-controls {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.control-btn {\n    padding: 8px 16px;\n    font-size: 0.9rem;\n    font-weight: 600;\n    border: none;\n    border-radius: 8px;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.control-btn:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 10px rgba(102, 126, 234, 0.3);\n}\n\n.control-btn:active {\n    transform: translateY(0);\n}\n\n.speed-indicator {\n    padding: 8px 12px;\n    font-weight: 700;\n    color: #333;\n    background: #f0f0f0;\n    border-radius: 8px;\n    min-width: 40px;\n    text-align: center;\n}\n\n.time-display {\n    text-align: center;\n    margin-bottom: 15px;\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: #2a5298;\n    padding: 10px;\n    background: #e3f2fd;\n    border-radius: 8px;\n}\n\n.map-container {\n    position: relative;\n    width: 100%;\n    max-width: 1000px;\n    margin: 0 auto;\n    border-radius: 15px;\n    overflow: hidden;\n    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);\n}\n\n.map-image {\n    width: 100%;\n    height: auto;\n    display: block;\n}\n\n.map-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n}\n\n/* Status Footer */\n.status-footer {\n    display: flex;\n    justify-content: space-around;\n    padding: 20px;\n    background: #f5f5f5;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n    gap: 20px;\n}\n\n.status-item {\n    display: flex;\n    gap: 10px;\n    align-items: center;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #666;\n}\n\n.status-value {\n    color: #333;\n    font-weight: 500;\n}\n\n.status-value.success {\n    color: #2e7d32;\n}\n\n.status-value.error {\n    color: #c62828;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 1.8rem;\n    }\n\n    .header h2 {\n        font-size: 1rem;\n    }\n\n    .guidance-message {\n        font-size: 1.1rem;\n    }\n\n    .forecast-cards {\n        grid-template-columns: 1fr;\n    }\n\n    .banner-details {\n        grid-template-columns: 1fr;\n    }\n\n    .terminal-tabs {\n        flex-direction: column;\n    }\n\n    .tab-button {\n        width: 100%;\n    }\n}\n\n@media (max-width: 480px) {\n    body {\n        padding: 10px;\n    }\n\n    .container {\n        border-radius: 10px;\n    }\n\n    .header {\n        padding: 20px;\n    }\n\n    .forecast-section,\n    .map-section {\n        padding: 20px;\n    }\n}\n\n/* Loading Animation */\n@keyframes pulse {\n    0%, 100% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0.5;\n    }\n}\n\n.loading {\n    animation: pulse 1.5s ease-in-out infinite;\n}\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:41:37.772Z","tree_hash":"7977fb6bab41619eeda45d9f4a59fb70d9ecac8bdc3a878ea99e37a66af1e699","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":18332,"mtime":1765320093341,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: true,\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        const data = await response.json();\n        \n        if (data.error || !data.timestamps) return;\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Start animation if playing\n        if (animationState.isPlaying) {\n            startAnimation();\n        } else {\n            // Just load current frame\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        // First, draw all slot borders and labels\n        for (const slot of data.slots) {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Draw slot ID label\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        }\n        \n        // Then load and draw license plate images (async)\n        for (const slot of data.slots) {\n            if (slot.x != null && slot.y != null && slot.plate_number) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY);\n                \n                const plateImg = await loadPlateImage(slot.plate_number);\n                if (plateImg) {\n                    // Draw license plate image\n                    const plateSize = slotSize * 0.9;\n                    mapContext.drawImage(\n                        plateImg,\n                        x - plateSize / 2,\n                        y - plateSize / 2,\n                        plateSize,\n                        plateSize\n                    );\n                }\n            }\n        }\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:42:17.804Z","tree_hash":"73e0192bfdef27ffb1e635ecdb6365841f4118ee5532124eedaab7b4ff6733cd","added":[],"modified":[{"path":"mini-project-3-team-tiger/backend/app.py","size":12082,"mtime":1765320135386,"ext":"py","content":"\"\"\"\nBackend API for Ride-Hailing Display/Dashboard at Sky Harbor Airport\nTechnical Lead: Data processing and API routing\n\"\"\"\n\nfrom flask import Flask, jsonify, request\nfrom flask_cors import CORS\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport os\n\napp = Flask(__name__)\nCORS(app)  # Enable CORS for frontend\n\n# Path to data file\nDATA_FILE = os.path.join(os.path.dirname(__file__), '..', 'assets', 'ride_hailing.xlsx')\n\n# Terminal to pickup zone mapping\nTERMINAL_ZONES = {\n    'Terminal 3': {\n        'zone': 'Zone A',\n        'walking_time_minutes': 3,\n        'pickup_coords': {'x': 300, 'y': 200}  # Approximate zone location\n    },\n    'Terminal 4': {\n        'zone': 'Zone B',\n        'walking_time_minutes': 5,\n        'pickup_coords': {'x': 500, 'y': 300}  # Approximate zone location\n    }\n}\n\n# Load and cache data\ndef load_data():\n    \"\"\"Load ride hailing data from Excel file\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Global data cache\n_data_cache = None\n\ndef get_data():\n    \"\"\"Get cached data or load fresh\"\"\"\n    global _data_cache\n    if _data_cache is None:\n        _data_cache = load_data()\n    return _data_cache.copy()\n\n@app.route('/api/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({'status': 'healthy', 'message': 'Backend API is running'})\n\n@app.route('/api/data/current', methods=['GET'])\ndef get_current_data():\n    \"\"\"Get current ride data\"\"\"\n    df = get_data()\n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots (with valid positions)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    result = {\n        'timestamp': latest_time.isoformat(),\n        'total_slots': len(current_data),\n        'active_slots': len(active_slots),\n        'slots': active_slots.to_dict('records')\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/terminal/guidance', methods=['GET'])\ndef get_terminal_guidance():\n    \"\"\"Get terminal-aware pickup guidance\"\"\"\n    terminal = request.args.get('terminal', 'Terminal 3')\n    \n    if terminal not in TERMINAL_ZONES:\n        return jsonify({'error': f'Terminal {terminal} not found'}), 400\n    \n    terminal_info = TERMINAL_ZONES[terminal]\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots in the terminal's zone\n    zone_coords = terminal_info['pickup_coords']\n    zone_x, zone_y = zone_coords['x'], zone_coords['y']\n    \n    # Find nearest available slots (within reasonable distance)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    if len(active_slots) > 0:\n        # Calculate distances to zone\n        active_slots['distance'] = np.sqrt(\n            (active_slots['x'] - zone_x)**2 + (active_slots['y'] - zone_y)**2\n        )\n        # Find nearest available slot\n        nearest_slot = active_slots.loc[active_slots['distance'].idxmin()]\n        \n        # Estimate ETA (walking time + wait time)\n        # Wait time based on number of available slots (more slots = less wait)\n        available_count = len(active_slots)\n        estimated_wait_minutes = max(2, 10 - (available_count // 5))  # Simple heuristic\n        \n        total_minutes = terminal_info['walking_time_minutes'] + estimated_wait_minutes\n        \n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': estimated_wait_minutes,\n            'total_minutes': total_minutes,\n            'available_slots': len(active_slots),\n            'nearest_slot_id': int(nearest_slot['slot_id']),\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {total_minutes} minutes.\"\n        }\n    else:\n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': 15,  # Default if no slots\n            'total_minutes': terminal_info['walking_time_minutes'] + 15,\n            'available_slots': 0,\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {terminal_info['walking_time_minutes'] + 15} minutes.\"\n        }\n    \n    return jsonify(result)\n\n@app.route('/api/forecast/price-wait', methods=['GET'])\ndef get_price_wait_forecast():\n    \"\"\"Get price and wait time forecast (15-30 min horizon)\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    \n    # Get data from last 30 minutes for rolling average\n    time_window = timedelta(minutes=30)\n    historical_data = df[df['current_time'] >= (latest_time - time_window)].copy()\n    \n    # Calculate metrics over time windows\n    time_buckets = []\n    for i in range(6):  # 6 buckets of 5 minutes each = 30 minutes\n        bucket_start = latest_time - timedelta(minutes=(6-i)*5)\n        bucket_end = latest_time - timedelta(minutes=(5-i)*5) if i < 5 else latest_time\n        bucket_data = historical_data[\n            (historical_data['current_time'] >= bucket_start) & \n            (historical_data['current_time'] < bucket_end)\n        ]\n        \n        active_slots = bucket_data[\n            bucket_data['x'].notna() & bucket_data['y'].notna()\n        ]\n        \n        # Simulate price based on demand (fewer slots = higher price)\n        # Base price + surge multiplier\n        base_price = 15.0\n        availability_ratio = len(active_slots) / len(bucket_data) if len(bucket_data) > 0 else 0\n        surge_multiplier = max(1.0, 2.0 - availability_ratio)\n        price = base_price * surge_multiplier\n        \n        # Wait time based on availability\n        wait_time = max(2, 15 - (len(active_slots) // 3))\n        \n        time_buckets.append({\n            'time': bucket_start.isoformat(),\n            'price': round(price, 2),\n            'wait_time': wait_time,\n            'availability': len(active_slots)\n        })\n    \n    # Calculate rolling averages and trends\n    prices = [b['price'] for b in time_buckets]\n    wait_times = [b['wait_time'] for b in time_buckets]\n    \n    # Rolling average (last 3 buckets)\n    recent_prices = prices[-3:] if len(prices) >= 3 else prices\n    recent_waits = wait_times[-3:] if len(wait_times) >= 3 else wait_times\n    \n    avg_price = np.mean(recent_prices)\n    avg_wait = np.mean(recent_waits)\n    \n    # Calculate slope/trend (linear regression on last 3 points)\n    if len(recent_prices) >= 2:\n        x = np.arange(len(recent_prices))\n        price_slope = np.polyfit(x, recent_prices, 1)[0]\n        wait_slope = np.polyfit(x, recent_waits, 1)[0]\n    else:\n        price_slope = 0\n        wait_slope = 0\n    \n    # Determine trend direction\n    def get_trend(slope, threshold=0.1):\n        if slope > threshold:\n            return 'up'\n        elif slope < -threshold:\n            return 'down'\n        else:\n            return 'flat'\n    \n    price_trend = get_trend(price_slope, threshold=0.5)\n    wait_trend = get_trend(wait_slope, threshold=0.5)\n    \n    # Forecast for next 15-30 minutes\n    forecast_horizon = 20  # minutes\n    forecast_price = avg_price + (price_slope * 4)  # Extrapolate\n    forecast_wait = avg_wait + (wait_slope * 4)\n    \n    # Ensure reasonable bounds\n    forecast_price = max(10.0, min(50.0, forecast_price))\n    forecast_wait = max(2, min(30, int(forecast_wait)))\n    \n    result = {\n        'current': {\n            'price': round(prices[-1] if prices else avg_price, 2),\n            'wait_time': wait_times[-1] if wait_times else int(avg_wait),\n            'timestamp': latest_time.isoformat()\n        },\n        'forecast': {\n            'price': round(forecast_price, 2),\n            'wait_time': forecast_wait,\n            'horizon_minutes': forecast_horizon\n        },\n        'trends': {\n            'price': {\n                'direction': price_trend,\n                'slope': round(price_slope, 3)\n            },\n            'wait_time': {\n                'direction': wait_trend,\n                'slope': round(wait_slope, 3)\n            }\n        },\n        'historical': time_buckets,\n        'sparkline_data': {\n            'prices': prices,\n            'wait_times': wait_times\n        }\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/data/timeseries', methods=['GET'])\ndef get_timeseries_data():\n    \"\"\"Get time series data for visualization\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get unique timestamps\n    unique_times = sorted(df['current_time'].unique())\n    \n    # Aggregate data by timestamp\n    timeseries = []\n    for timestamp in unique_times:\n        time_data = df[df['current_time'] == timestamp]\n        active_slots = time_data[\n            time_data['x'].notna() & time_data['y'].notna()\n        ]\n        \n        timeseries.append({\n            'timestamp': timestamp.isoformat(),\n            'active_slots': len(active_slots),\n            'total_slots': len(time_data)\n        })\n    \n    return jsonify({\n        'timeseries': timeseries,\n        'total_points': len(timeseries)\n    })\n\n@app.route('/api/data/time/<timestamp>', methods=['GET'])\ndef get_data_by_time(timestamp):\n    \"\"\"Get ride data for a specific timestamp\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    try:\n        # Parse timestamp (accept ISO format or simple format)\n        try:\n            target_time = pd.to_datetime(timestamp)\n        except:\n            # Try parsing as ISO string\n            target_time = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))\n        \n        # Find closest timestamp (exact match preferred)\n        time_data = df[df['current_time'] == target_time].copy()\n        \n        if len(time_data) == 0:\n            # Find closest timestamp\n            unique_times = sorted(df['current_time'].unique())\n            closest_time = min(unique_times, key=lambda x: abs((x - target_time).total_seconds()))\n            time_data = df[df['current_time'] == closest_time].copy()\n            target_time = closest_time\n        \n        # Filter active slots\n        active_slots = time_data[\n            time_data['x'].notna() & time_data['y'].notna()\n        ].copy()\n        \n        result = {\n            'timestamp': target_time.isoformat(),\n            'total_slots': len(time_data),\n            'active_slots': len(active_slots),\n            'slots': active_slots.to_dict('records')\n        }\n        \n        return jsonify(result)\n    except Exception as e:\n        return jsonify({'error': f'Invalid timestamp: {str(e)}'}), 400\n\n@app.route('/api/data/timestamps', methods=['GET'])\ndef get_available_timestamps():\n    \"\"\"Get list of all available timestamps\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    unique_times = sorted(df['current_time'].unique())\n    \n    return jsonify({\n        'timestamps': [t.isoformat() for t in unique_times],\n        'count': len(unique_times)\n    })\n\nif __name__ == '__main__':\n    print(\"Starting Backend API Server...\")\n    print(f\"Data file: {DATA_FILE}\")\n    # Use port 5001 to avoid conflict with macOS AirPlay Receiver on port 5000\n    app.run(debug=True, port=5001, host='0.0.0.0')\n\n"},{"path":"mini-project-3-team-tiger/frontend/app.js","size":18332,"mtime":1765320135386,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: true,\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        const data = await response.json();\n        \n        if (data.error || !data.timestamps) return;\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Start animation if playing\n        if (animationState.isPlaying) {\n            startAnimation();\n        } else {\n            // Just load current frame\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        // First, draw all slot borders and labels\n        for (const slot of data.slots) {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Draw slot ID label\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        }\n        \n        // Then load and draw license plate images (async)\n        for (const slot of data.slots) {\n            if (slot.x != null && slot.y != null && slot.plate_number) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY);\n                \n                const plateImg = await loadPlateImage(slot.plate_number);\n                if (plateImg) {\n                    // Draw license plate image\n                    const plateSize = slotSize * 0.9;\n                    mapContext.drawImage(\n                        plateImg,\n                        x - plateSize / 2,\n                        y - plateSize / 2,\n                        plateSize,\n                        plateSize\n                    );\n                }\n            }\n        }\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"},{"path":"mini-project-3-team-tiger/frontend/index.html","size":6340,"mtime":1765320135386,"ext":"html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Sky Harbor Airport - Ride-Hailing Dashboard</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <!-- Header -->\n        <header class=\"header\">\n            <h1>‚úàÔ∏è Sky Harbor Airport</h1>\n            <h2>Ride-Hailing Display Dashboard</h2>\n        </header>\n\n        <!-- Terminal Selection Tabs -->\n        <div class=\"terminal-tabs\">\n            <button class=\"tab-button active\" data-terminal=\"Terminal 3\">Terminal 3</button>\n            <button class=\"tab-button\" data-terminal=\"Terminal 4\">Terminal 4</button>\n        </div>\n\n        <!-- Terminal Guidance Banner -->\n        <div id=\"guidance-banner\" class=\"guidance-banner\">\n            <div class=\"banner-content\">\n                <span class=\"banner-icon\">üìç</span>\n                <span id=\"guidance-message\" class=\"guidance-message\">Loading guidance...</span>\n            </div>\n            <div class=\"banner-details\">\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Zone:</span>\n                    <span id=\"zone-name\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Walking Time:</span>\n                    <span id=\"walking-time\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Estimated Wait:</span>\n                    <span id=\"estimated-wait\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Available Slots:</span>\n                    <span id=\"available-slots\" class=\"detail-value\">-</span>\n                </div>\n            </div>\n        </div>\n\n        <!-- Price & Wait Forecast Section -->\n        <div class=\"forecast-section\">\n            <h3>Price & Wait Forecast (15-30 min horizon)</h3>\n            \n            <div class=\"forecast-cards\">\n                <!-- Price Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">üí∞</span>\n                        <span class=\"card-title\">Price Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"price-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"price-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Wait Time Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">‚è±Ô∏è</span>\n                        <span class=\"card-title\">Wait Time Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"wait-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"wait-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- Map Visualization -->\n        <div class=\"map-section\">\n            <div class=\"map-header\">\n                <h3>Live Map View</h3>\n                <div class=\"animation-controls\">\n                    <button id=\"play-pause-btn\" class=\"control-btn\">‚è∏Ô∏è Pause</button>\n                    <button id=\"speed-down-btn\" class=\"control-btn\">‚è™ Slow</button>\n                    <span id=\"speed-indicator\" class=\"speed-indicator\">1x</span>\n                    <button id=\"speed-up-btn\" class=\"control-btn\">‚è© Fast</button>\n                    <button id=\"reset-btn\" class=\"control-btn\">üîÑ Reset</button>\n                </div>\n            </div>\n            <div class=\"time-display\">\n                <span id=\"current-time-display\">Time: --:--:--</span>\n            </div>\n            <div class=\"map-container\">\n                <img id=\"map-image\" src=\"../assets/map.png\" alt=\"Airport Map\" class=\"map-image\">\n                <canvas id=\"map-overlay\" class=\"map-overlay\"></canvas>\n            </div>\n        </div>\n\n        <!-- Status Footer -->\n        <footer class=\"status-footer\">\n            <div class=\"status-item\">\n                <span class=\"status-label\">Last Updated:</span>\n                <span id=\"last-updated\" class=\"status-value\">-</span>\n            </div>\n            <div class=\"status-item\">\n                <span class=\"status-label\">API Status:</span>\n                <span id=\"api-status\" class=\"status-value\">Checking...</span>\n            </div>\n        </footer>\n    </div>\n\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n"},{"path":"mini-project-3-team-tiger/frontend/styles.css","size":7938,"mtime":1765320135386,"ext":"css","content":"/* Sky Harbor Airport Ride-Hailing Dashboard Styles */\n/* UI/UX Specialist: Responsive and visually appealing interface */\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1400px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 20px;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\n    overflow: hidden;\n}\n\n/* Header */\n.header {\n    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);\n    color: white;\n    padding: 30px;\n    text-align: center;\n}\n\n.header h1 {\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n    font-weight: 700;\n}\n\n.header h2 {\n    font-size: 1.3rem;\n    font-weight: 300;\n    opacity: 0.9;\n}\n\n/* Terminal Tabs */\n.terminal-tabs {\n    display: flex;\n    gap: 10px;\n    padding: 20px;\n    background: #f5f5f5;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.tab-button {\n    flex: 1;\n    padding: 15px 30px;\n    font-size: 1.1rem;\n    font-weight: 600;\n    border: none;\n    border-radius: 10px;\n    background: white;\n    color: #666;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.tab-button:hover {\n    background: #e3f2fd;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);\n}\n\n.tab-button.active {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);\n}\n\n/* Guidance Banner */\n.guidance-banner {\n    margin: 20px;\n    padding: 25px;\n    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);\n    border-radius: 15px;\n    color: white;\n    box-shadow: 0 5px 20px rgba(79, 172, 254, 0.3);\n    animation: slideIn 0.5s ease;\n}\n\n@keyframes slideIn {\n    from {\n        opacity: 0;\n        transform: translateY(-20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.banner-content {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    margin-bottom: 15px;\n}\n\n.banner-icon {\n    font-size: 2rem;\n}\n\n.guidance-message {\n    font-size: 1.4rem;\n    font-weight: 600;\n    flex: 1;\n}\n\n.banner-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n    gap: 15px;\n    margin-top: 15px;\n    padding-top: 15px;\n    border-top: 1px solid rgba(255, 255, 255, 0.3);\n}\n\n.detail-item {\n    display: flex;\n    flex-direction: column;\n    gap: 5px;\n}\n\n.detail-label {\n    font-size: 0.9rem;\n    opacity: 0.9;\n}\n\n.detail-value {\n    font-size: 1.2rem;\n    font-weight: 700;\n}\n\n/* Forecast Section */\n.forecast-section {\n    padding: 30px;\n    background: #fafafa;\n}\n\n.forecast-section h3 {\n    font-size: 1.8rem;\n    margin-bottom: 25px;\n    color: #333;\n    text-align: center;\n}\n\n.forecast-cards {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 25px;\n}\n\n.forecast-card {\n    background: white;\n    border-radius: 15px;\n    padding: 25px;\n    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n    transition: transform 0.3s ease, box-shadow 0.3s ease;\n}\n\n.forecast-card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);\n}\n\n.card-header {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #f0f0f0;\n}\n\n.card-icon {\n    font-size: 1.8rem;\n}\n\n.card-title {\n    font-size: 1.3rem;\n    font-weight: 600;\n    color: #333;\n}\n\n.card-content {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n}\n\n.current-value, .forecast-value {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.value-label {\n    font-size: 0.95rem;\n    color: #666;\n}\n\n.value-amount {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: #2a5298;\n}\n\n/* Trend Badge */\n.trend-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px 15px;\n    border-radius: 20px;\n    font-weight: 600;\n    font-size: 0.9rem;\n    width: fit-content;\n}\n\n.trend-badge.flat {\n    background: #e0e0e0;\n    color: #666;\n}\n\n.trend-badge.up {\n    background: #ffebee;\n    color: #c62828;\n}\n\n.trend-badge.down {\n    background: #e8f5e9;\n    color: #2e7d32;\n}\n\n.trend-icon {\n    font-size: 1.2rem;\n}\n\n.trend-badge.up .trend-icon::before {\n    content: \"‚Üë\";\n}\n\n.trend-badge.down .trend-icon::before {\n    content: \"‚Üì\";\n}\n\n.trend-badge.flat .trend-icon::before {\n    content: \"‚Üí\";\n}\n\n/* Sparkline Container */\n.sparkline-container {\n    margin-top: 10px;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n/* Map Section */\n.map-section {\n    padding: 30px;\n    background: white;\n}\n\n.map-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 15px;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.map-section h3 {\n    font-size: 1.8rem;\n    margin: 0;\n    color: #333;\n}\n\n.animation-controls {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.control-btn {\n    padding: 8px 16px;\n    font-size: 0.9rem;\n    font-weight: 600;\n    border: none;\n    border-radius: 8px;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.control-btn:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 10px rgba(102, 126, 234, 0.3);\n}\n\n.control-btn:active {\n    transform: translateY(0);\n}\n\n.speed-indicator {\n    padding: 8px 12px;\n    font-weight: 700;\n    color: #333;\n    background: #f0f0f0;\n    border-radius: 8px;\n    min-width: 40px;\n    text-align: center;\n}\n\n.time-display {\n    text-align: center;\n    margin-bottom: 15px;\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: #2a5298;\n    padding: 10px;\n    background: #e3f2fd;\n    border-radius: 8px;\n}\n\n.map-container {\n    position: relative;\n    width: 100%;\n    max-width: 1000px;\n    margin: 0 auto;\n    border-radius: 15px;\n    overflow: hidden;\n    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);\n}\n\n.map-image {\n    width: 100%;\n    height: auto;\n    display: block;\n}\n\n.map-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n}\n\n/* Status Footer */\n.status-footer {\n    display: flex;\n    justify-content: space-around;\n    padding: 20px;\n    background: #f5f5f5;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n    gap: 20px;\n}\n\n.status-item {\n    display: flex;\n    gap: 10px;\n    align-items: center;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #666;\n}\n\n.status-value {\n    color: #333;\n    font-weight: 500;\n}\n\n.status-value.success {\n    color: #2e7d32;\n}\n\n.status-value.error {\n    color: #c62828;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 1.8rem;\n    }\n\n    .header h2 {\n        font-size: 1rem;\n    }\n\n    .guidance-message {\n        font-size: 1.1rem;\n    }\n\n    .forecast-cards {\n        grid-template-columns: 1fr;\n    }\n\n    .banner-details {\n        grid-template-columns: 1fr;\n    }\n\n    .terminal-tabs {\n        flex-direction: column;\n    }\n\n    .tab-button {\n        width: 100%;\n    }\n}\n\n@media (max-width: 480px) {\n    body {\n        padding: 10px;\n    }\n\n    .container {\n        border-radius: 10px;\n    }\n\n    .header {\n        padding: 20px;\n    }\n\n    .forecast-section,\n    .map-section {\n        padding: 20px;\n    }\n}\n\n/* Loading Animation */\n@keyframes pulse {\n    0%, 100% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0.5;\n    }\n}\n\n.loading {\n    animation: pulse 1.5s ease-in-out infinite;\n}\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:45:52.955Z","tree_hash":"b400bf36c7f08ead0fcb073c8c93a207af68b98923825cc168da37ee78de10cb","added":[{"path":"mini-project-3-team-tiger/dashboard.py","size":12021,"mtime":1765320352324,"ext":"py","content":"\"\"\"\nStreamlit Dashboard for Ride-Hailing Display at Sky Harbor Airport\nTime series visualization of parking lot status from 6:00 PM to 6:59 PM\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport numpy as np\nfrom datetime import datetime, time\nimport os\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Sky Harbor Airport - Ride-Hailing Dashboard\",\n    page_icon=\"‚úàÔ∏è\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Paths\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\nDATA_FILE = os.path.join(BASE_DIR, 'assets', 'ride_hailing.xlsx')\nMAP_FILE = os.path.join(BASE_DIR, 'assets', 'map.png')\nPLATES_DIR = os.path.join(BASE_DIR, 'assets', 'plates')\n\n# Load data\n@st.cache_data\ndef load_data():\n    \"\"\"Load the ride_hailing dataset from the first sheet\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        st.error(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Load background image\n@st.cache_data\ndef load_map():\n    \"\"\"Load the map background image\"\"\"\n    try:\n        img = Image.open(MAP_FILE)\n        return img, img.size\n    except Exception as e:\n        st.error(f\"Error loading map: {e}\")\n        return None, None\n\n# Load plate image\ndef load_plate_image(plate_number):\n    \"\"\"Load license plate image if available\"\"\"\n    if pd.isna(plate_number) or plate_number is None:\n        return None\n    plate_path = os.path.join(PLATES_DIR, f\"{str(plate_number).strip()}.png\")\n    if os.path.exists(plate_path):\n        try:\n            return Image.open(plate_path)\n        except:\n            return None\n    return None\n\n# Initialize session state\nif 'is_playing' not in st.session_state:\n    st.session_state.is_playing = False\nif 'current_time_index' not in st.session_state:\n    st.session_state.current_time_index = 0\nif 'reset_flag' not in st.session_state:\n    st.session_state.reset_flag = False\n\n# Load data\ndf = load_data()\nmap_img, map_size = load_map()\n\nif df.empty or map_img is None:\n    st.error(\"Failed to load data or map image. Please check the files.\")\n    st.stop()\n\n# Get map dimensions for scaling\nif map_size:\n    map_width, map_height = map_size\nelse:\n    map_width, map_height = 1000, 1000  # Default dimensions\n\n# Process time column - extract time component\ndf['time_only'] = df['current_time'].dt.time\n\n# Filter data for 6:00 PM to 6:59 PM\nstart_time = time(18, 0)  # 6:00 PM\nend_time = time(18, 59)   # 6:59 PM\n\ndf_filtered = df[\n    (df['time_only'] >= start_time) & \n    (df['time_only'] <= end_time)\n].copy()\n\nif df_filtered.empty:\n    st.warning(\"No data found for 6:00 PM to 6:59 PM\")\n    st.write(\"Sample data:\", df.head())\n    st.stop()\n\n# Sort by time\ndf_filtered = df_filtered.sort_values('current_time').reset_index(drop=True)\n\n# Get unique times for slider (one per minute)\nunique_times = sorted(df_filtered['time_only'].unique())\nunique_datetimes = sorted(df_filtered['current_time'].unique())\n\n# Main layout\nst.title(\"‚úàÔ∏è Sky Harbor Airport - Ride-Hailing Dashboard\")\nst.markdown(\"**Time Range: 6:00 PM - 6:59 PM**\")\n\n# Sidebar for controls and ride details\nwith st.sidebar:\n    st.header(\"üéÆ Controls\")\n    \n    # Time slider\n    if len(unique_times) > 0:\n        # Create time labels for display\n        time_labels = [t.strftime('%H:%M') for t in unique_times]\n        \n        time_index = st.slider(\n            \"Select Time (Minutes)\",\n            min_value=0,\n            max_value=len(unique_times) - 1,\n            value=st.session_state.current_time_index,\n            format=\"%s\",\n            help=f\"Time range: {unique_times[0].strftime('%H:%M')} to {unique_times[-1].strftime('%H:%M')}\"\n        )\n        st.session_state.current_time_index = time_index\n        \n        # Display selected time\n        selected_time = unique_times[time_index]\n        st.write(f\"**Selected Time:** {selected_time.strftime('%H:%M:%S')}\")\n    else:\n        st.warning(\"No time data available\")\n        time_index = 0\n    \n    st.divider()\n    \n    # Control buttons\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        if st.button(\"‚ñ∂Ô∏è Start\", use_container_width=True, type=\"primary\"):\n            st.session_state.is_playing = True\n            st.rerun()\n    \n    with col2:\n        if st.button(\"‚è∏Ô∏è Stop\", use_container_width=True):\n            st.session_state.is_playing = False\n            st.rerun()\n    \n    if st.button(\"üîÑ Reset\", use_container_width=True):\n        st.session_state.current_time_index = 0\n        st.session_state.is_playing = False\n        st.session_state.reset_flag = True\n        st.rerun()\n    \n    st.divider()\n    \n    # Display current time metric\n    if len(unique_times) > 0 and time_index < len(unique_times):\n        current_time = unique_times[time_index]\n        st.metric(\"Current Time\", current_time.strftime(\"%H:%M:%S\"))\n    \n    st.divider()\n    st.header(\"üìã Ride Details\")\n    \n    # Get current time data\n    if len(unique_times) > 0 and time_index < len(unique_times):\n        current_time = unique_times[time_index]\n        current_data = df_filtered[df_filtered['time_only'] == current_time]\n        \n        # Filter out rows with NaN positions (empty slots)\n        current_data_active = current_data[\n            current_data['x'].notna() & current_data['y'].notna()\n        ].copy()\n        \n        st.metric(\"Active Slots\", len(current_data_active))\n        st.metric(\"Total Slots\", len(current_data))\n        \n        # Display ride details\n        if len(current_data_active) > 0:\n            for idx, row in current_data_active.iterrows():\n                with st.expander(f\"üöó Slot {int(row['slot_id'])}\", expanded=False):\n                    # Basic information\n                    st.write(f\"**Time:** {row['time_only'].strftime('%H:%M:%S')}\")\n                    st.write(f\"**Slot ID:** {int(row['slot_id'])}\")\n                    st.write(f\"**Position:** ({row['x']:.1f}, {row['y']:.1f})\")\n                    \n                    # License plate image\n                    if pd.notna(row.get('plate_number')):\n                        plate_number = str(row['plate_number']).strip()\n                        plate_img = load_plate_image(plate_number)\n                        if plate_img:\n                            st.image(plate_img, caption=f\"License Plate: {plate_number}\", width=200)\n                        else:\n                            st.write(f\"**License Plate:** {plate_number}\")\n                    \n                    # Additional ride information\n                    if pd.notna(row.get('reservation_id')):\n                        st.write(f\"**Reservation ID:** {row['reservation_id']}\")\n                    if pd.notna(row.get('rider_id')):\n                        st.write(f\"**Rider ID:** {row['rider_id']}\")\n                    if pd.notna(row.get('driver_id')):\n                        st.write(f\"**Driver ID:** {row['driver_id']}\")\n                    if pd.notna(row.get('service')):\n                        st.write(f\"**Service:** {row['service']}\")\n        else:\n            st.info(\"No active slots at this time\")\n\n# Main visualization area\nif len(unique_times) > 0 and time_index < len(unique_times):\n    current_time = unique_times[time_index]\n    current_data = df_filtered[df_filtered['time_only'] == current_time]\n    \n    # Filter active slots (with valid positions)\n    current_data_active = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    # Create visualization\n    fig, ax = plt.subplots(figsize=(14, 12))\n    \n    # Display background map\n    if map_img:\n        ax.imshow(map_img, extent=[0, map_width, map_height, 0], \n                 aspect='auto', alpha=1.0, origin='upper', interpolation='nearest')\n    \n    # Plot parking slots with license plates\n    if len(current_data_active) > 0:\n        for idx, row in current_data_active.iterrows():\n            slot_id = int(row['slot_id'])\n            x = float(row['x'])\n            y = float(row['y'])\n            \n            # Draw parking slot border (scaled based on map size)\n            slot_size = min(map_width, map_height) / 40  # Adaptive slot size\n            \n            # Load license plate image\n            plate_img = None\n            if pd.notna(row.get('plate_number')):\n                plate_number = str(row['plate_number']).strip()\n                plate_img = load_plate_image(plate_number)\n            \n            # Draw border\n            rect = Rectangle((x - slot_size/2, y - slot_size/2), \n                           slot_size, slot_size,\n                           linewidth=2, edgecolor='#FF4444', \n                           facecolor='none', alpha=1.0)\n            ax.add_patch(rect)\n            \n            # Draw license plate image if available\n            if plate_img:\n                # Calculate plate size in data coordinates\n                plate_size_data = slot_size * 0.95\n                \n                # Resize plate image for quality\n                target_pixels = 200\n                plate_img_resized = plate_img.copy()\n                plate_img_resized.thumbnail((target_pixels, target_pixels), Image.Resampling.LANCZOS)\n                \n                # Convert to numpy array\n                plate_array = np.array(plate_img_resized)\n                \n                # Calculate extent for imshow\n                left = x - plate_size_data / 2\n                right = x + plate_size_data / 2\n                bottom = y - plate_size_data / 2\n                top = y + plate_size_data / 2\n                \n                # Display the plate image\n                ax.imshow(plate_array, extent=[left, right, bottom, top], \n                         aspect='auto', alpha=1.0, interpolation='nearest', \n                         origin='upper', zorder=5)\n            \n            # Add slot ID label\n            font_size = max(8, min(map_width, map_height) / 120)\n            label_x = x - slot_size/2 + 3\n            label_y = y - slot_size/2 + 3\n            ax.text(label_x, label_y, str(slot_id), ha='left', va='top', \n                   fontsize=font_size, fontweight='bold', \n                   color='white', rotation=0,\n                   bbox=dict(boxstyle='round,pad=0.2', \n                   facecolor='black', alpha=1.0, edgecolor='red', linewidth=1),\n                   zorder=100)\n    \n    # Set axis limits based on map dimensions\n    ax.set_xlim(0, map_width)\n    ax.set_ylim(map_height, 0)  # Invert Y-axis to match image coordinates\n    \n    ax.set_title(f\"Parking Lot Status - {current_time.strftime('%H:%M:%S')}\", \n                fontsize=20, fontweight='bold', pad=20)\n    ax.set_xlabel(\"X Position\", fontsize=14)\n    ax.set_ylabel(\"Y Position\", fontsize=14)\n    ax.grid(True, alpha=0.2, linestyle='--', linewidth=0.5)\n    \n    # Add legend\n    from matplotlib.patches import Patch\n    legend_elements = [\n        Patch(facecolor='none', edgecolor='#FF4444', linewidth=2, label='Occupied Slot'),\n    ]\n    ax.legend(handles=legend_elements, loc='upper right', fontsize=11, framealpha=1.0)\n    \n    plt.tight_layout()\n    st.pyplot(fig, use_container_width=True)\n    \n    # Auto-play functionality\n    if st.session_state.is_playing:\n        if st.session_state.current_time_index < len(unique_times) - 1:\n            # Show playing status\n            status_placeholder = st.empty()\n            status_placeholder.info(\"‚è© Playing animation...\")\n            # Small delay before rerun\n            import time as time_module\n            time_module.sleep(0.5)  # 0.5 second delay between frames\n            st.session_state.current_time_index += 1\n            st.rerun()\n        else:\n            st.session_state.is_playing = False\n            st.success(\"‚úÖ Reached end of time range\")\n\nelse:\n    st.warning(\"No data available for visualization\")\n\n"}],"modified":[{"path":"mini-project-3-team-tiger/dashboard.py","size":12021,"mtime":1765320352324,"ext":"py","content":"\"\"\"\nStreamlit Dashboard for Ride-Hailing Display at Sky Harbor Airport\nTime series visualization of parking lot status from 6:00 PM to 6:59 PM\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport numpy as np\nfrom datetime import datetime, time\nimport os\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Sky Harbor Airport - Ride-Hailing Dashboard\",\n    page_icon=\"‚úàÔ∏è\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Paths\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\nDATA_FILE = os.path.join(BASE_DIR, 'assets', 'ride_hailing.xlsx')\nMAP_FILE = os.path.join(BASE_DIR, 'assets', 'map.png')\nPLATES_DIR = os.path.join(BASE_DIR, 'assets', 'plates')\n\n# Load data\n@st.cache_data\ndef load_data():\n    \"\"\"Load the ride_hailing dataset from the first sheet\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        st.error(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Load background image\n@st.cache_data\ndef load_map():\n    \"\"\"Load the map background image\"\"\"\n    try:\n        img = Image.open(MAP_FILE)\n        return img, img.size\n    except Exception as e:\n        st.error(f\"Error loading map: {e}\")\n        return None, None\n\n# Load plate image\ndef load_plate_image(plate_number):\n    \"\"\"Load license plate image if available\"\"\"\n    if pd.isna(plate_number) or plate_number is None:\n        return None\n    plate_path = os.path.join(PLATES_DIR, f\"{str(plate_number).strip()}.png\")\n    if os.path.exists(plate_path):\n        try:\n            return Image.open(plate_path)\n        except:\n            return None\n    return None\n\n# Initialize session state\nif 'is_playing' not in st.session_state:\n    st.session_state.is_playing = False\nif 'current_time_index' not in st.session_state:\n    st.session_state.current_time_index = 0\nif 'reset_flag' not in st.session_state:\n    st.session_state.reset_flag = False\n\n# Load data\ndf = load_data()\nmap_img, map_size = load_map()\n\nif df.empty or map_img is None:\n    st.error(\"Failed to load data or map image. Please check the files.\")\n    st.stop()\n\n# Get map dimensions for scaling\nif map_size:\n    map_width, map_height = map_size\nelse:\n    map_width, map_height = 1000, 1000  # Default dimensions\n\n# Process time column - extract time component\ndf['time_only'] = df['current_time'].dt.time\n\n# Filter data for 6:00 PM to 6:59 PM\nstart_time = time(18, 0)  # 6:00 PM\nend_time = time(18, 59)   # 6:59 PM\n\ndf_filtered = df[\n    (df['time_only'] >= start_time) & \n    (df['time_only'] <= end_time)\n].copy()\n\nif df_filtered.empty:\n    st.warning(\"No data found for 6:00 PM to 6:59 PM\")\n    st.write(\"Sample data:\", df.head())\n    st.stop()\n\n# Sort by time\ndf_filtered = df_filtered.sort_values('current_time').reset_index(drop=True)\n\n# Get unique times for slider (one per minute)\nunique_times = sorted(df_filtered['time_only'].unique())\nunique_datetimes = sorted(df_filtered['current_time'].unique())\n\n# Main layout\nst.title(\"‚úàÔ∏è Sky Harbor Airport - Ride-Hailing Dashboard\")\nst.markdown(\"**Time Range: 6:00 PM - 6:59 PM**\")\n\n# Sidebar for controls and ride details\nwith st.sidebar:\n    st.header(\"üéÆ Controls\")\n    \n    # Time slider\n    if len(unique_times) > 0:\n        # Create time labels for display\n        time_labels = [t.strftime('%H:%M') for t in unique_times]\n        \n        time_index = st.slider(\n            \"Select Time (Minutes)\",\n            min_value=0,\n            max_value=len(unique_times) - 1,\n            value=st.session_state.current_time_index,\n            format=\"%s\",\n            help=f\"Time range: {unique_times[0].strftime('%H:%M')} to {unique_times[-1].strftime('%H:%M')}\"\n        )\n        st.session_state.current_time_index = time_index\n        \n        # Display selected time\n        selected_time = unique_times[time_index]\n        st.write(f\"**Selected Time:** {selected_time.strftime('%H:%M:%S')}\")\n    else:\n        st.warning(\"No time data available\")\n        time_index = 0\n    \n    st.divider()\n    \n    # Control buttons\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        if st.button(\"‚ñ∂Ô∏è Start\", use_container_width=True, type=\"primary\"):\n            st.session_state.is_playing = True\n            st.rerun()\n    \n    with col2:\n        if st.button(\"‚è∏Ô∏è Stop\", use_container_width=True):\n            st.session_state.is_playing = False\n            st.rerun()\n    \n    if st.button(\"üîÑ Reset\", use_container_width=True):\n        st.session_state.current_time_index = 0\n        st.session_state.is_playing = False\n        st.session_state.reset_flag = True\n        st.rerun()\n    \n    st.divider()\n    \n    # Display current time metric\n    if len(unique_times) > 0 and time_index < len(unique_times):\n        current_time = unique_times[time_index]\n        st.metric(\"Current Time\", current_time.strftime(\"%H:%M:%S\"))\n    \n    st.divider()\n    st.header(\"üìã Ride Details\")\n    \n    # Get current time data\n    if len(unique_times) > 0 and time_index < len(unique_times):\n        current_time = unique_times[time_index]\n        current_data = df_filtered[df_filtered['time_only'] == current_time]\n        \n        # Filter out rows with NaN positions (empty slots)\n        current_data_active = current_data[\n            current_data['x'].notna() & current_data['y'].notna()\n        ].copy()\n        \n        st.metric(\"Active Slots\", len(current_data_active))\n        st.metric(\"Total Slots\", len(current_data))\n        \n        # Display ride details\n        if len(current_data_active) > 0:\n            for idx, row in current_data_active.iterrows():\n                with st.expander(f\"üöó Slot {int(row['slot_id'])}\", expanded=False):\n                    # Basic information\n                    st.write(f\"**Time:** {row['time_only'].strftime('%H:%M:%S')}\")\n                    st.write(f\"**Slot ID:** {int(row['slot_id'])}\")\n                    st.write(f\"**Position:** ({row['x']:.1f}, {row['y']:.1f})\")\n                    \n                    # License plate image\n                    if pd.notna(row.get('plate_number')):\n                        plate_number = str(row['plate_number']).strip()\n                        plate_img = load_plate_image(plate_number)\n                        if plate_img:\n                            st.image(plate_img, caption=f\"License Plate: {plate_number}\", width=200)\n                        else:\n                            st.write(f\"**License Plate:** {plate_number}\")\n                    \n                    # Additional ride information\n                    if pd.notna(row.get('reservation_id')):\n                        st.write(f\"**Reservation ID:** {row['reservation_id']}\")\n                    if pd.notna(row.get('rider_id')):\n                        st.write(f\"**Rider ID:** {row['rider_id']}\")\n                    if pd.notna(row.get('driver_id')):\n                        st.write(f\"**Driver ID:** {row['driver_id']}\")\n                    if pd.notna(row.get('service')):\n                        st.write(f\"**Service:** {row['service']}\")\n        else:\n            st.info(\"No active slots at this time\")\n\n# Main visualization area\nif len(unique_times) > 0 and time_index < len(unique_times):\n    current_time = unique_times[time_index]\n    current_data = df_filtered[df_filtered['time_only'] == current_time]\n    \n    # Filter active slots (with valid positions)\n    current_data_active = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    # Create visualization\n    fig, ax = plt.subplots(figsize=(14, 12))\n    \n    # Display background map\n    if map_img:\n        ax.imshow(map_img, extent=[0, map_width, map_height, 0], \n                 aspect='auto', alpha=1.0, origin='upper', interpolation='nearest')\n    \n    # Plot parking slots with license plates\n    if len(current_data_active) > 0:\n        for idx, row in current_data_active.iterrows():\n            slot_id = int(row['slot_id'])\n            x = float(row['x'])\n            y = float(row['y'])\n            \n            # Draw parking slot border (scaled based on map size)\n            slot_size = min(map_width, map_height) / 40  # Adaptive slot size\n            \n            # Load license plate image\n            plate_img = None\n            if pd.notna(row.get('plate_number')):\n                plate_number = str(row['plate_number']).strip()\n                plate_img = load_plate_image(plate_number)\n            \n            # Draw border\n            rect = Rectangle((x - slot_size/2, y - slot_size/2), \n                           slot_size, slot_size,\n                           linewidth=2, edgecolor='#FF4444', \n                           facecolor='none', alpha=1.0)\n            ax.add_patch(rect)\n            \n            # Draw license plate image if available\n            if plate_img:\n                # Calculate plate size in data coordinates\n                plate_size_data = slot_size * 0.95\n                \n                # Resize plate image for quality\n                target_pixels = 200\n                plate_img_resized = plate_img.copy()\n                plate_img_resized.thumbnail((target_pixels, target_pixels), Image.Resampling.LANCZOS)\n                \n                # Convert to numpy array\n                plate_array = np.array(plate_img_resized)\n                \n                # Calculate extent for imshow\n                left = x - plate_size_data / 2\n                right = x + plate_size_data / 2\n                bottom = y - plate_size_data / 2\n                top = y + plate_size_data / 2\n                \n                # Display the plate image\n                ax.imshow(plate_array, extent=[left, right, bottom, top], \n                         aspect='auto', alpha=1.0, interpolation='nearest', \n                         origin='upper', zorder=5)\n            \n            # Add slot ID label\n            font_size = max(8, min(map_width, map_height) / 120)\n            label_x = x - slot_size/2 + 3\n            label_y = y - slot_size/2 + 3\n            ax.text(label_x, label_y, str(slot_id), ha='left', va='top', \n                   fontsize=font_size, fontweight='bold', \n                   color='white', rotation=0,\n                   bbox=dict(boxstyle='round,pad=0.2', \n                   facecolor='black', alpha=1.0, edgecolor='red', linewidth=1),\n                   zorder=100)\n    \n    # Set axis limits based on map dimensions\n    ax.set_xlim(0, map_width)\n    ax.set_ylim(map_height, 0)  # Invert Y-axis to match image coordinates\n    \n    ax.set_title(f\"Parking Lot Status - {current_time.strftime('%H:%M:%S')}\", \n                fontsize=20, fontweight='bold', pad=20)\n    ax.set_xlabel(\"X Position\", fontsize=14)\n    ax.set_ylabel(\"Y Position\", fontsize=14)\n    ax.grid(True, alpha=0.2, linestyle='--', linewidth=0.5)\n    \n    # Add legend\n    from matplotlib.patches import Patch\n    legend_elements = [\n        Patch(facecolor='none', edgecolor='#FF4444', linewidth=2, label='Occupied Slot'),\n    ]\n    ax.legend(handles=legend_elements, loc='upper right', fontsize=11, framealpha=1.0)\n    \n    plt.tight_layout()\n    st.pyplot(fig, use_container_width=True)\n    \n    # Auto-play functionality\n    if st.session_state.is_playing:\n        if st.session_state.current_time_index < len(unique_times) - 1:\n            # Show playing status\n            status_placeholder = st.empty()\n            status_placeholder.info(\"‚è© Playing animation...\")\n            # Small delay before rerun\n            import time as time_module\n            time_module.sleep(0.5)  # 0.5 second delay between frames\n            st.session_state.current_time_index += 1\n            st.rerun()\n        else:\n            st.session_state.is_playing = False\n            st.success(\"‚úÖ Reached end of time range\")\n\nelse:\n    st.warning(\"No data available for visualization\")\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:45:57.962Z","tree_hash":"6d734c2dc7287fa5c0a6c93292676aaa37fea25ecdb151ec359cbc8243394952","added":[{"path":"mini-project-3-team-tiger/requirements.txt","size":96,"mtime":1765320354179,"ext":"txt","content":"streamlit==1.28.0\npandas==2.1.3\nnumpy==1.26.2\nopenpyxl==3.1.2\nmatplotlib==3.8.2\nPillow==10.1.0\n\n"}],"modified":[{"path":"mini-project-3-team-tiger/requirements.txt","size":96,"mtime":1765320354179,"ext":"txt","content":"streamlit==1.28.0\npandas==2.1.3\nnumpy==1.26.2\nopenpyxl==3.1.2\nmatplotlib==3.8.2\nPillow==10.1.0\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:46:27.989Z","tree_hash":"7ac2167ea82a2990b5173f0a9a2a73b6493f574922ad9a507d5aa5ebbc854039","added":[],"modified":[{"path":"mini-project-3-team-tiger/README.md","size":6936,"mtime":1765320386370,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ dashboard.py         # Streamlit dashboard (standalone)\n‚îú‚îÄ‚îÄ requirements.txt    # Python dependencies for Streamlit\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   Or use the startup script:\n   ```bash\n   ./start_server.sh\n   ```\n\n   The API will be available at `http://localhost:5001`\n   \n   **Note:** Port 5001 is used instead of 5000 to avoid conflicts with macOS AirPlay Receiver.\n   \n   **Important:** Keep this terminal window open while using the dashboard!\n\n### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5001\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000`\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5001/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nThe backend uses port 5001 by default to avoid conflicts with macOS AirPlay Receiver (which uses port 5000). If port 5001 is also in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5002, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:46:32.992Z","tree_hash":"ce486967cd1fc0c53ae9c3a9c73d6e143750fe6a35ab95a70b10541ab44b2b00","added":[],"modified":[{"path":"mini-project-3-team-tiger/README.md","size":7217,"mtime":1765320391742,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ dashboard.py         # Streamlit dashboard (standalone)\n‚îú‚îÄ‚îÄ requirements.txt    # Python dependencies for Streamlit\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Option 1: Streamlit Dashboard (Recommended - Standalone)\n\nThe Streamlit dashboard is a complete standalone solution that doesn't require separate backend/frontend setup.\n\n1. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n2. Run the Streamlit dashboard:\n   ```bash\n   streamlit run dashboard.py\n   ```\n   \n   The dashboard will automatically open in your browser at `http://localhost:8501`\n\n### Option 2: Flask Backend + HTML Frontend\n\nIf you prefer the separate backend/frontend architecture:\n\n#### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   The API will be available at `http://localhost:5001`\n\n#### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5001\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000`\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5001/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nThe backend uses port 5001 by default to avoid conflicts with macOS AirPlay Receiver (which uses port 5000). If port 5001 is also in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5002, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:46:37.997Z","tree_hash":"adaa423d6d6738fcc636a1d27d2b916f050a5956bfe5199ac2ed12f1467760dc","added":[],"modified":[{"path":"mini-project-3-team-tiger/README.md","size":7317,"mtime":1765320395942,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ dashboard.py         # Streamlit dashboard (standalone)\n‚îú‚îÄ‚îÄ requirements.txt    # Python dependencies for Streamlit\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Option 1: Streamlit Dashboard (Recommended - Standalone)\n\nThe Streamlit dashboard is a complete standalone solution that doesn't require separate backend/frontend setup.\n\n1. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n2. Run the Streamlit dashboard:\n   ```bash\n   streamlit run dashboard.py\n   ```\n   \n   The dashboard will automatically open in your browser at `http://localhost:8501`\n\n### Option 2: Flask Backend + HTML Frontend\n\nIf you prefer the separate backend/frontend architecture:\n\n#### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   The API will be available at `http://localhost:5001`\n\n#### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n### Streamlit Dashboard (Easiest)\n```bash\nstreamlit run dashboard.py\n```\n\n### Flask + HTML Frontend\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5001\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000`\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5001/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nThe backend uses port 5001 by default to avoid conflicts with macOS AirPlay Receiver (which uses port 5000). If port 5001 is also in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5002, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:46:53.010Z","tree_hash":"3fb28437b8c91153953ce05e023ee7a89ef49306bdd8d1f2b6dfec6fcf0bf95e","added":[],"modified":[{"path":"mini-project-3-team-tiger/README.md","size":7317,"mtime":1765320409997,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ dashboard.py         # Streamlit dashboard (standalone)\n‚îú‚îÄ‚îÄ requirements.txt    # Python dependencies for Streamlit\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Option 1: Streamlit Dashboard (Recommended - Standalone)\n\nThe Streamlit dashboard is a complete standalone solution that doesn't require separate backend/frontend setup.\n\n1. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n2. Run the Streamlit dashboard:\n   ```bash\n   streamlit run dashboard.py\n   ```\n   \n   The dashboard will automatically open in your browser at `http://localhost:8501`\n\n### Option 2: Flask Backend + HTML Frontend\n\nIf you prefer the separate backend/frontend architecture:\n\n#### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   The API will be available at `http://localhost:5001`\n\n#### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n### Streamlit Dashboard (Easiest)\n```bash\nstreamlit run dashboard.py\n```\n\n### Flask + HTML Frontend\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5001\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000`\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5001/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nThe backend uses port 5001 by default to avoid conflicts with macOS AirPlay Receiver (which uses port 5000). If port 5001 is also in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5002, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"},{"path":"mini-project-3-team-tiger/dashboard.py","size":12021,"mtime":1765320409997,"ext":"py","content":"\"\"\"\nStreamlit Dashboard for Ride-Hailing Display at Sky Harbor Airport\nTime series visualization of parking lot status from 6:00 PM to 6:59 PM\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport numpy as np\nfrom datetime import datetime, time\nimport os\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Sky Harbor Airport - Ride-Hailing Dashboard\",\n    page_icon=\"‚úàÔ∏è\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Paths\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\nDATA_FILE = os.path.join(BASE_DIR, 'assets', 'ride_hailing.xlsx')\nMAP_FILE = os.path.join(BASE_DIR, 'assets', 'map.png')\nPLATES_DIR = os.path.join(BASE_DIR, 'assets', 'plates')\n\n# Load data\n@st.cache_data\ndef load_data():\n    \"\"\"Load the ride_hailing dataset from the first sheet\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        st.error(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Load background image\n@st.cache_data\ndef load_map():\n    \"\"\"Load the map background image\"\"\"\n    try:\n        img = Image.open(MAP_FILE)\n        return img, img.size\n    except Exception as e:\n        st.error(f\"Error loading map: {e}\")\n        return None, None\n\n# Load plate image\ndef load_plate_image(plate_number):\n    \"\"\"Load license plate image if available\"\"\"\n    if pd.isna(plate_number) or plate_number is None:\n        return None\n    plate_path = os.path.join(PLATES_DIR, f\"{str(plate_number).strip()}.png\")\n    if os.path.exists(plate_path):\n        try:\n            return Image.open(plate_path)\n        except:\n            return None\n    return None\n\n# Initialize session state\nif 'is_playing' not in st.session_state:\n    st.session_state.is_playing = False\nif 'current_time_index' not in st.session_state:\n    st.session_state.current_time_index = 0\nif 'reset_flag' not in st.session_state:\n    st.session_state.reset_flag = False\n\n# Load data\ndf = load_data()\nmap_img, map_size = load_map()\n\nif df.empty or map_img is None:\n    st.error(\"Failed to load data or map image. Please check the files.\")\n    st.stop()\n\n# Get map dimensions for scaling\nif map_size:\n    map_width, map_height = map_size\nelse:\n    map_width, map_height = 1000, 1000  # Default dimensions\n\n# Process time column - extract time component\ndf['time_only'] = df['current_time'].dt.time\n\n# Filter data for 6:00 PM to 6:59 PM\nstart_time = time(18, 0)  # 6:00 PM\nend_time = time(18, 59)   # 6:59 PM\n\ndf_filtered = df[\n    (df['time_only'] >= start_time) & \n    (df['time_only'] <= end_time)\n].copy()\n\nif df_filtered.empty:\n    st.warning(\"No data found for 6:00 PM to 6:59 PM\")\n    st.write(\"Sample data:\", df.head())\n    st.stop()\n\n# Sort by time\ndf_filtered = df_filtered.sort_values('current_time').reset_index(drop=True)\n\n# Get unique times for slider (one per minute)\nunique_times = sorted(df_filtered['time_only'].unique())\nunique_datetimes = sorted(df_filtered['current_time'].unique())\n\n# Main layout\nst.title(\"‚úàÔ∏è Sky Harbor Airport - Ride-Hailing Dashboard\")\nst.markdown(\"**Time Range: 6:00 PM - 6:59 PM**\")\n\n# Sidebar for controls and ride details\nwith st.sidebar:\n    st.header(\"üéÆ Controls\")\n    \n    # Time slider\n    if len(unique_times) > 0:\n        # Create time labels for display\n        time_labels = [t.strftime('%H:%M') for t in unique_times]\n        \n        time_index = st.slider(\n            \"Select Time (Minutes)\",\n            min_value=0,\n            max_value=len(unique_times) - 1,\n            value=st.session_state.current_time_index,\n            format=\"%s\",\n            help=f\"Time range: {unique_times[0].strftime('%H:%M')} to {unique_times[-1].strftime('%H:%M')}\"\n        )\n        st.session_state.current_time_index = time_index\n        \n        # Display selected time\n        selected_time = unique_times[time_index]\n        st.write(f\"**Selected Time:** {selected_time.strftime('%H:%M:%S')}\")\n    else:\n        st.warning(\"No time data available\")\n        time_index = 0\n    \n    st.divider()\n    \n    # Control buttons\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        if st.button(\"‚ñ∂Ô∏è Start\", use_container_width=True, type=\"primary\"):\n            st.session_state.is_playing = True\n            st.rerun()\n    \n    with col2:\n        if st.button(\"‚è∏Ô∏è Stop\", use_container_width=True):\n            st.session_state.is_playing = False\n            st.rerun()\n    \n    if st.button(\"üîÑ Reset\", use_container_width=True):\n        st.session_state.current_time_index = 0\n        st.session_state.is_playing = False\n        st.session_state.reset_flag = True\n        st.rerun()\n    \n    st.divider()\n    \n    # Display current time metric\n    if len(unique_times) > 0 and time_index < len(unique_times):\n        current_time = unique_times[time_index]\n        st.metric(\"Current Time\", current_time.strftime(\"%H:%M:%S\"))\n    \n    st.divider()\n    st.header(\"üìã Ride Details\")\n    \n    # Get current time data\n    if len(unique_times) > 0 and time_index < len(unique_times):\n        current_time = unique_times[time_index]\n        current_data = df_filtered[df_filtered['time_only'] == current_time]\n        \n        # Filter out rows with NaN positions (empty slots)\n        current_data_active = current_data[\n            current_data['x'].notna() & current_data['y'].notna()\n        ].copy()\n        \n        st.metric(\"Active Slots\", len(current_data_active))\n        st.metric(\"Total Slots\", len(current_data))\n        \n        # Display ride details\n        if len(current_data_active) > 0:\n            for idx, row in current_data_active.iterrows():\n                with st.expander(f\"üöó Slot {int(row['slot_id'])}\", expanded=False):\n                    # Basic information\n                    st.write(f\"**Time:** {row['time_only'].strftime('%H:%M:%S')}\")\n                    st.write(f\"**Slot ID:** {int(row['slot_id'])}\")\n                    st.write(f\"**Position:** ({row['x']:.1f}, {row['y']:.1f})\")\n                    \n                    # License plate image\n                    if pd.notna(row.get('plate_number')):\n                        plate_number = str(row['plate_number']).strip()\n                        plate_img = load_plate_image(plate_number)\n                        if plate_img:\n                            st.image(plate_img, caption=f\"License Plate: {plate_number}\", width=200)\n                        else:\n                            st.write(f\"**License Plate:** {plate_number}\")\n                    \n                    # Additional ride information\n                    if pd.notna(row.get('reservation_id')):\n                        st.write(f\"**Reservation ID:** {row['reservation_id']}\")\n                    if pd.notna(row.get('rider_id')):\n                        st.write(f\"**Rider ID:** {row['rider_id']}\")\n                    if pd.notna(row.get('driver_id')):\n                        st.write(f\"**Driver ID:** {row['driver_id']}\")\n                    if pd.notna(row.get('service')):\n                        st.write(f\"**Service:** {row['service']}\")\n        else:\n            st.info(\"No active slots at this time\")\n\n# Main visualization area\nif len(unique_times) > 0 and time_index < len(unique_times):\n    current_time = unique_times[time_index]\n    current_data = df_filtered[df_filtered['time_only'] == current_time]\n    \n    # Filter active slots (with valid positions)\n    current_data_active = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    # Create visualization\n    fig, ax = plt.subplots(figsize=(14, 12))\n    \n    # Display background map\n    if map_img:\n        ax.imshow(map_img, extent=[0, map_width, map_height, 0], \n                 aspect='auto', alpha=1.0, origin='upper', interpolation='nearest')\n    \n    # Plot parking slots with license plates\n    if len(current_data_active) > 0:\n        for idx, row in current_data_active.iterrows():\n            slot_id = int(row['slot_id'])\n            x = float(row['x'])\n            y = float(row['y'])\n            \n            # Draw parking slot border (scaled based on map size)\n            slot_size = min(map_width, map_height) / 40  # Adaptive slot size\n            \n            # Load license plate image\n            plate_img = None\n            if pd.notna(row.get('plate_number')):\n                plate_number = str(row['plate_number']).strip()\n                plate_img = load_plate_image(plate_number)\n            \n            # Draw border\n            rect = Rectangle((x - slot_size/2, y - slot_size/2), \n                           slot_size, slot_size,\n                           linewidth=2, edgecolor='#FF4444', \n                           facecolor='none', alpha=1.0)\n            ax.add_patch(rect)\n            \n            # Draw license plate image if available\n            if plate_img:\n                # Calculate plate size in data coordinates\n                plate_size_data = slot_size * 0.95\n                \n                # Resize plate image for quality\n                target_pixels = 200\n                plate_img_resized = plate_img.copy()\n                plate_img_resized.thumbnail((target_pixels, target_pixels), Image.Resampling.LANCZOS)\n                \n                # Convert to numpy array\n                plate_array = np.array(plate_img_resized)\n                \n                # Calculate extent for imshow\n                left = x - plate_size_data / 2\n                right = x + plate_size_data / 2\n                bottom = y - plate_size_data / 2\n                top = y + plate_size_data / 2\n                \n                # Display the plate image\n                ax.imshow(plate_array, extent=[left, right, bottom, top], \n                         aspect='auto', alpha=1.0, interpolation='nearest', \n                         origin='upper', zorder=5)\n            \n            # Add slot ID label\n            font_size = max(8, min(map_width, map_height) / 120)\n            label_x = x - slot_size/2 + 3\n            label_y = y - slot_size/2 + 3\n            ax.text(label_x, label_y, str(slot_id), ha='left', va='top', \n                   fontsize=font_size, fontweight='bold', \n                   color='white', rotation=0,\n                   bbox=dict(boxstyle='round,pad=0.2', \n                   facecolor='black', alpha=1.0, edgecolor='red', linewidth=1),\n                   zorder=100)\n    \n    # Set axis limits based on map dimensions\n    ax.set_xlim(0, map_width)\n    ax.set_ylim(map_height, 0)  # Invert Y-axis to match image coordinates\n    \n    ax.set_title(f\"Parking Lot Status - {current_time.strftime('%H:%M:%S')}\", \n                fontsize=20, fontweight='bold', pad=20)\n    ax.set_xlabel(\"X Position\", fontsize=14)\n    ax.set_ylabel(\"Y Position\", fontsize=14)\n    ax.grid(True, alpha=0.2, linestyle='--', linewidth=0.5)\n    \n    # Add legend\n    from matplotlib.patches import Patch\n    legend_elements = [\n        Patch(facecolor='none', edgecolor='#FF4444', linewidth=2, label='Occupied Slot'),\n    ]\n    ax.legend(handles=legend_elements, loc='upper right', fontsize=11, framealpha=1.0)\n    \n    plt.tight_layout()\n    st.pyplot(fig, use_container_width=True)\n    \n    # Auto-play functionality\n    if st.session_state.is_playing:\n        if st.session_state.current_time_index < len(unique_times) - 1:\n            # Show playing status\n            status_placeholder = st.empty()\n            status_placeholder.info(\"‚è© Playing animation...\")\n            # Small delay before rerun\n            import time as time_module\n            time_module.sleep(0.5)  # 0.5 second delay between frames\n            st.session_state.current_time_index += 1\n            st.rerun()\n        else:\n            st.session_state.is_playing = False\n            st.success(\"‚úÖ Reached end of time range\")\n\nelse:\n    st.warning(\"No data available for visualization\")\n\n"},{"path":"mini-project-3-team-tiger/requirements.txt","size":96,"mtime":1765320409997,"ext":"txt","content":"streamlit==1.28.0\npandas==2.1.3\nnumpy==1.26.2\nopenpyxl==3.1.2\nmatplotlib==3.8.2\nPillow==10.1.0\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:48:58.136Z","tree_hash":"f68448e794fc3ae66898feefbd5589a64a83e80ced34922b091cffe4181d0313","added":[],"modified":[{"path":"mini-project-3-team-tiger/dashboard.py","size":12077,"mtime":1765320536772,"ext":"py","content":"\"\"\"\nStreamlit Dashboard for Ride-Hailing Display at Sky Harbor Airport\nTime series visualization of parking lot status from 6:00 PM to 6:59 PM\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.patches import Rectangle, Circle, Patch\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport numpy as np\nfrom datetime import datetime, time\nimport os\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Sky Harbor Airport - Ride-Hailing Dashboard\",\n    page_icon=\"‚úàÔ∏è\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Paths\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\nDATA_FILE = os.path.join(BASE_DIR, 'assets', 'ride_hailing.xlsx')\nMAP_FILE = os.path.join(BASE_DIR, 'assets', 'map.png')\nPLATES_DIR = os.path.join(BASE_DIR, 'assets', 'plates')\n\n# Load data\n@st.cache_data\ndef load_data():\n    \"\"\"Load the ride_hailing dataset from the first sheet\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        st.error(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Load background image\n@st.cache_data\ndef load_map():\n    \"\"\"Load the map background image\"\"\"\n    try:\n        img = Image.open(MAP_FILE)\n        return img, img.size\n    except Exception as e:\n        st.error(f\"Error loading map: {e}\")\n        return None, None\n\n# Load plate image\ndef load_plate_image(plate_number):\n    \"\"\"Load license plate image if available\"\"\"\n    if pd.isna(plate_number) or plate_number is None:\n        return None\n    plate_path = os.path.join(PLATES_DIR, f\"{str(plate_number).strip()}.png\")\n    if os.path.exists(plate_path):\n        try:\n            return Image.open(plate_path)\n        except:\n            return None\n    return None\n\n# Initialize session state\nif 'is_playing' not in st.session_state:\n    st.session_state.is_playing = False\nif 'current_time_index' not in st.session_state:\n    st.session_state.current_time_index = 0\nif 'reset_flag' not in st.session_state:\n    st.session_state.reset_flag = False\n\n# Load data\ndf = load_data()\nmap_img, map_size = load_map()\n\nif df.empty or map_img is None:\n    st.error(\"Failed to load data or map image. Please check the files.\")\n    st.stop()\n\n# Get map dimensions for scaling\nif map_size:\n    map_width, map_height = map_size\nelse:\n    map_width, map_height = 1000, 1000  # Default dimensions\n\n# Process time column - extract time component\ndf['time_only'] = df['current_time'].dt.time\n\n# Filter data for 6:00 PM to 6:59 PM\nstart_time = time(18, 0)  # 6:00 PM\nend_time = time(18, 59)   # 6:59 PM\n\ndf_filtered = df[\n    (df['time_only'] >= start_time) & \n    (df['time_only'] <= end_time)\n].copy()\n\nif df_filtered.empty:\n    st.warning(\"No data found for 6:00 PM to 6:59 PM\")\n    st.write(\"Sample data:\", df.head())\n    st.stop()\n\n# Sort by time\ndf_filtered = df_filtered.sort_values('current_time').reset_index(drop=True)\n\n# Get unique times for slider (one per minute)\nunique_times = sorted(df_filtered['time_only'].unique())\nunique_datetimes = sorted(df_filtered['current_time'].unique())\n\n# Main layout\nst.title(\"‚úàÔ∏è Sky Harbor Airport - Ride-Hailing Dashboard\")\nst.markdown(\"**Time Range: 6:00 PM - 6:59 PM**\")\n\n# Sidebar for controls and ride details\nwith st.sidebar:\n    st.header(\"üéÆ Controls\")\n    \n    # Time slider\n    if len(unique_times) > 0:\n        # Create time labels for display\n        time_labels = [t.strftime('%H:%M') for t in unique_times]\n        \n        time_index = st.slider(\n            \"Select Time (Minutes)\",\n            min_value=0,\n            max_value=len(unique_times) - 1,\n            value=st.session_state.current_time_index,\n            format=\"%s\",\n            help=f\"Time range: {unique_times[0].strftime('%H:%M')} to {unique_times[-1].strftime('%H:%M')}\"\n        )\n        st.session_state.current_time_index = time_index\n        \n        # Display selected time\n        selected_time = unique_times[time_index]\n        st.write(f\"**Selected Time:** {selected_time.strftime('%H:%M:%S')}\")\n    else:\n        st.warning(\"No time data available\")\n        time_index = 0\n    \n    st.divider()\n    \n    # Control buttons\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        if st.button(\"‚ñ∂Ô∏è Start\", use_container_width=True, type=\"primary\"):\n            st.session_state.is_playing = True\n            st.rerun()\n    \n    with col2:\n        if st.button(\"‚è∏Ô∏è Stop\", use_container_width=True):\n            st.session_state.is_playing = False\n            st.rerun()\n    \n    if st.button(\"üîÑ Reset\", use_container_width=True):\n        st.session_state.current_time_index = 0\n        st.session_state.is_playing = False\n        st.session_state.reset_flag = True\n        st.rerun()\n    \n    st.divider()\n    \n    # Display current time metric\n    if len(unique_times) > 0 and time_index < len(unique_times):\n        current_time = unique_times[time_index]\n        st.metric(\"Current Time\", current_time.strftime(\"%H:%M:%S\"))\n    \n    st.divider()\n    st.header(\"üìã Ride Details\")\n    \n    # Get current time data\n    if len(unique_times) > 0 and time_index < len(unique_times):\n        current_time = unique_times[time_index]\n        current_data = df_filtered[df_filtered['time_only'] == current_time]\n        \n        # Filter out rows with NaN positions (empty slots)\n        current_data_active = current_data[\n            current_data['x'].notna() & current_data['y'].notna()\n        ].copy()\n        \n        st.metric(\"Active Slots\", len(current_data_active))\n        st.metric(\"Total Slots\", len(current_data))\n        \n        # Display ride details\n        if len(current_data_active) > 0:\n            for idx, row in current_data_active.iterrows():\n                with st.expander(f\"üöó Slot {int(row['slot_id'])}\", expanded=False):\n                    # Basic information\n                    st.write(f\"**Time:** {row['time_only'].strftime('%H:%M:%S')}\")\n                    st.write(f\"**Slot ID:** {int(row['slot_id'])}\")\n                    st.write(f\"**Position:** ({row['x']:.1f}, {row['y']:.1f})\")\n                    \n                    # License plate image\n                    if pd.notna(row.get('plate_number')):\n                        plate_number = str(row['plate_number']).strip()\n                        plate_img = load_plate_image(plate_number)\n                        if plate_img:\n                            st.image(plate_img, caption=f\"License Plate: {plate_number}\", width=200)\n                        else:\n                            st.write(f\"**License Plate:** {plate_number}\")\n                    \n                    # Additional ride information\n                    if pd.notna(row.get('reservation_id')):\n                        st.write(f\"**Reservation ID:** {row['reservation_id']}\")\n                    if pd.notna(row.get('rider_id')):\n                        st.write(f\"**Rider ID:** {row['rider_id']}\")\n                    if pd.notna(row.get('driver_id')):\n                        st.write(f\"**Driver ID:** {row['driver_id']}\")\n                    if pd.notna(row.get('service')):\n                        st.write(f\"**Service:** {row['service']}\")\n        else:\n            st.info(\"No active slots at this time\")\n\n# Main visualization area\nif len(unique_times) > 0 and time_index < len(unique_times):\n    current_time = unique_times[time_index]\n    current_data = df_filtered[df_filtered['time_only'] == current_time]\n    \n    # Filter active slots (with valid positions)\n    current_data_active = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    # Create visualization\n    fig, ax = plt.subplots(figsize=(14, 12))\n    \n    # Display background map\n    if map_img:\n        ax.imshow(map_img, extent=[0, map_width, map_height, 0], \n                 aspect='auto', alpha=1.0, origin='upper', interpolation='nearest')\n    \n    # Plot parking slots with license plates\n    if len(current_data_active) > 0:\n        for idx, row in current_data_active.iterrows():\n            slot_id = int(row['slot_id'])\n            x = float(row['x'])\n            y = float(row['y'])\n            \n            # Draw parking slot border (scaled based on map size)\n            slot_size = min(map_width, map_height) / 40  # Adaptive slot size\n            \n            # Load license plate image\n            plate_img = None\n            if pd.notna(row.get('plate_number')):\n                plate_number = str(row['plate_number']).strip()\n                plate_img = load_plate_image(plate_number)\n            \n            # Draw border\n            rect = Rectangle((x - slot_size/2, y - slot_size/2), \n                           slot_size, slot_size,\n                           linewidth=2, edgecolor='#FF4444', \n                           facecolor='none', alpha=1.0)\n            ax.add_patch(rect)\n            \n            # Draw license plate image if available\n            if plate_img:\n                # Calculate plate size in data coordinates\n                plate_size_data = slot_size * 0.95\n                \n                # Resize plate image for quality\n                target_pixels = 200\n                plate_img_resized = plate_img.copy()\n                plate_img_resized.thumbnail((target_pixels, target_pixels), Image.Resampling.LANCZOS)\n                \n                # Convert to numpy array\n                plate_array = np.array(plate_img_resized)\n                \n                # Calculate extent for imshow\n                left = x - plate_size_data / 2\n                right = x + plate_size_data / 2\n                bottom = y - plate_size_data / 2\n                top = y + plate_size_data / 2\n                \n                # Display the plate image\n                ax.imshow(plate_array, extent=[left, right, bottom, top], \n                         aspect='auto', alpha=1.0, interpolation='nearest', \n                         origin='upper', zorder=5)\n            \n            # Add slot ID label\n            font_size = max(8, min(map_width, map_height) / 120)\n            label_x = x - slot_size/2 + 3\n            label_y = y - slot_size/2 + 3\n            ax.text(label_x, label_y, str(slot_id), ha='left', va='top', \n                   fontsize=font_size, fontweight='bold', \n                   color='white', rotation=0,\n                   bbox=dict(boxstyle='round,pad=0.2', \n                   facecolor='black', alpha=1.0, edgecolor='red', linewidth=1),\n                   zorder=100)\n    \n    # Set axis limits based on map dimensions\n    ax.set_xlim(0, map_width)\n    ax.set_ylim(map_height, 0)  # Invert Y-axis to match image coordinates\n    \n    ax.set_title(f\"Parking Lot Status - {current_time.strftime('%H:%M:%S')}\", \n                fontsize=20, fontweight='bold', pad=20)\n    ax.set_xlabel(\"X Position\", fontsize=14)\n    ax.set_ylabel(\"Y Position\", fontsize=14)\n    ax.grid(True, alpha=0.2, linestyle='--', linewidth=0.5)\n    \n    # Add legend\n    from matplotlib.patches import Patch\n    legend_elements = [\n        Patch(facecolor='none', edgecolor='#FF4444', linewidth=2, label='Occupied Slot'),\n    ]\n    ax.legend(handles=legend_elements, loc='upper right', fontsize=11, framealpha=1.0)\n    \n    plt.tight_layout()\n    st.pyplot(fig, use_container_width=True)\n    \n    # Auto-play functionality\n    if st.session_state.is_playing:\n        if st.session_state.current_time_index < len(unique_times) - 1:\n            # Show playing status\n            status_placeholder = st.empty()\n            status_placeholder.info(\"‚è© Playing animation...\")\n            # Small delay before rerun\n            import time as time_module\n            time_module.sleep(0.5)  # 0.5 second delay between frames\n            st.session_state.current_time_index += 1\n            st.rerun()\n        else:\n            st.session_state.is_playing = False\n            st.success(\"‚úÖ Reached end of time range\")\n\nelse:\n    st.warning(\"No data available for visualization\")\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:49:18.137Z","tree_hash":"64b539ce76355eea48e3f25771c37f207a55805ed4b4721b1a4dad6edc37f9fa","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":18265,"mtime":1765320554200,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: true,\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        const data = await response.json();\n        \n        if (data.error || !data.timestamps) return;\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Start animation if playing\n        if (animationState.isPlaying) {\n            startAnimation();\n        } else {\n            // Just load current frame\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        // Process all slots and draw them\n        const slotPromises = data.slots.map(async (slot) => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Load and draw license plate image if available\n                if (slot.plate_number) {\n                    const plateImg = await loadPlateImage(slot.plate_number);\n                    if (plateImg) {\n                        // Draw license plate image\n                        const plateSize = slotSize * 0.9;\n                        mapContext.drawImage(\n                            plateImg,\n                            x - plateSize / 2,\n                            y - plateSize / 2,\n                            plateSize,\n                            plateSize\n                        );\n                    }\n                }\n                \n                // Draw slot ID label (on top)\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        });\n        \n        // Wait for all slots to be drawn\n        await Promise.all(slotPromises);\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:49:23.136Z","tree_hash":"b8850890c88d5002f8c9f5852107609d3300aaf7b90f08aa6f9149557d39f157","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/index.html","size":6669,"mtime":1765320561897,"ext":"html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Sky Harbor Airport - Ride-Hailing Dashboard</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <!-- Header -->\n        <header class=\"header\">\n            <h1>‚úàÔ∏è Sky Harbor Airport</h1>\n            <h2>Ride-Hailing Display Dashboard</h2>\n        </header>\n\n        <!-- Terminal Selection Tabs -->\n        <div class=\"terminal-tabs\">\n            <button class=\"tab-button active\" data-terminal=\"Terminal 3\">Terminal 3</button>\n            <button class=\"tab-button\" data-terminal=\"Terminal 4\">Terminal 4</button>\n        </div>\n\n        <!-- Terminal Guidance Banner -->\n        <div id=\"guidance-banner\" class=\"guidance-banner\">\n            <div class=\"banner-content\">\n                <span class=\"banner-icon\">üìç</span>\n                <span id=\"guidance-message\" class=\"guidance-message\">Loading guidance...</span>\n            </div>\n            <div class=\"banner-details\">\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Zone:</span>\n                    <span id=\"zone-name\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Walking Time:</span>\n                    <span id=\"walking-time\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Estimated Wait:</span>\n                    <span id=\"estimated-wait\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Available Slots:</span>\n                    <span id=\"available-slots\" class=\"detail-value\">-</span>\n                </div>\n            </div>\n        </div>\n\n        <!-- Price & Wait Forecast Section -->\n        <div class=\"forecast-section\">\n            <h3>Price & Wait Forecast (15-30 min horizon)</h3>\n            \n            <div class=\"forecast-cards\">\n                <!-- Price Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">üí∞</span>\n                        <span class=\"card-title\">Price Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"price-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"price-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Wait Time Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">‚è±Ô∏è</span>\n                        <span class=\"card-title\">Wait Time Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"wait-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"wait-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- Map Visualization -->\n        <div class=\"map-section\">\n            <div class=\"map-header\">\n                <h3>Live Map View - Parking Lot Status (6:00 PM - 6:59 PM)</h3>\n                <div class=\"animation-controls\">\n                    <button id=\"play-pause-btn\" class=\"control-btn\">‚è∏Ô∏è Pause</button>\n                    <button id=\"speed-down-btn\" class=\"control-btn\">‚è™ Slow</button>\n                    <span id=\"speed-indicator\" class=\"speed-indicator\">1x</span>\n                    <button id=\"speed-up-btn\" class=\"control-btn\">‚è© Fast</button>\n                    <button id=\"reset-btn\" class=\"control-btn\">üîÑ Reset</button>\n                </div>\n            </div>\n            <div class=\"time-display\">\n                <span id=\"current-time-display\">Time: --:--:--</span>\n            </div>\n            <div class=\"time-slider-container\">\n                <label for=\"time-slider\">Select Time:</label>\n                <input type=\"range\" id=\"time-slider\" min=\"0\" max=\"59\" value=\"0\" class=\"time-slider\">\n                <span id=\"time-slider-value\">18:00</span>\n            </div>\n            <div class=\"map-container\">\n                <img id=\"map-image\" src=\"../assets/map.png\" alt=\"Airport Map\" class=\"map-image\">\n                <canvas id=\"map-overlay\" class=\"map-overlay\"></canvas>\n            </div>\n        </div>\n\n        <!-- Status Footer -->\n        <footer class=\"status-footer\">\n            <div class=\"status-item\">\n                <span class=\"status-label\">Last Updated:</span>\n                <span id=\"last-updated\" class=\"status-value\">-</span>\n            </div>\n            <div class=\"status-item\">\n                <span class=\"status-label\">API Status:</span>\n                <span id=\"api-status\" class=\"status-value\">Checking...</span>\n            </div>\n        </footer>\n    </div>\n\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:49:28.138Z","tree_hash":"3d1069989cd45bf65e13d8874c7524742dc505b66d6660365e63b9becc6a3988","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":19394,"mtime":1765320567414,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: true,\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        const data = await response.json();\n        \n        if (data.error || !data.timestamps) return;\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Start animation if playing\n        if (animationState.isPlaying) {\n            startAnimation();\n        } else {\n            // Just load current frame\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    timeSlider.addEventListener('input', (e) => {\n        const minute = parseInt(e.target.value);\n        const hour = 18; // 6 PM\n        const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        timeSliderValue.textContent = timeString;\n        \n        // Find matching timestamp\n        if (animationState.timestamps.length > 0) {\n            const targetTime = new Date(`2025-09-17T${timeString}:00`);\n            const closestIndex = animationState.timestamps.findIndex(ts => {\n                const tsDate = new Date(ts);\n                return tsDate.getHours() === hour && tsDate.getMinutes() === minute;\n            });\n            \n            if (closestIndex >= 0) {\n                animationState.currentTimeIndex = closestIndex;\n                updateMapVisualizationForTime(animationState.timestamps[closestIndex]);\n            }\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        // Process all slots and draw them\n        const slotPromises = data.slots.map(async (slot) => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Load and draw license plate image if available\n                if (slot.plate_number) {\n                    const plateImg = await loadPlateImage(slot.plate_number);\n                    if (plateImg) {\n                        // Draw license plate image\n                        const plateSize = slotSize * 0.9;\n                        mapContext.drawImage(\n                            plateImg,\n                            x - plateSize / 2,\n                            y - plateSize / 2,\n                            plateSize,\n                            plateSize\n                        );\n                    }\n                }\n                \n                // Draw slot ID label (on top)\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        });\n        \n        // Wait for all slots to be drawn\n        await Promise.all(slotPromises);\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:49:38.151Z","tree_hash":"cf2465ed0cee7b29268fa07e8bb9a2e2415e41863a596ff61fa39c602e63ca5e","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":20114,"mtime":1765320575075,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: true,\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        const data = await response.json();\n        \n        if (data.error || !data.timestamps) return;\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Start animation if playing\n        if (animationState.isPlaying) {\n            startAnimation();\n        } else {\n            // Just load current frame\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    timeSlider.addEventListener('input', (e) => {\n        const minute = parseInt(e.target.value);\n        const hour = 18; // 6 PM\n        const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        timeSliderValue.textContent = timeString;\n        \n        // Find matching timestamp\n        if (animationState.timestamps.length > 0) {\n            const targetTime = new Date(`2025-09-17T${timeString}:00`);\n            const closestIndex = animationState.timestamps.findIndex(ts => {\n                const tsDate = new Date(ts);\n                return tsDate.getHours() === hour && tsDate.getMinutes() === minute;\n            });\n            \n            if (closestIndex >= 0) {\n                animationState.currentTimeIndex = closestIndex;\n                updateMapVisualizationForTime(animationState.timestamps[closestIndex]);\n            }\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        // Process all slots and draw them\n        const slotPromises = data.slots.map(async (slot) => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Load and draw license plate image if available\n                if (slot.plate_number) {\n                    const plateImg = await loadPlateImage(slot.plate_number);\n                    if (plateImg) {\n                        // Draw license plate image\n                        const plateSize = slotSize * 0.9;\n                        mapContext.drawImage(\n                            plateImg,\n                            x - plateSize / 2,\n                            y - plateSize / 2,\n                            plateSize,\n                            plateSize\n                        );\n                    }\n                }\n                \n                // Draw slot ID label (on top)\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        });\n        \n        // Wait for all slots to be drawn\n        await Promise.all(slotPromises);\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:49:43.151Z","tree_hash":"69d6ac2bcf26b006ed3df980c4ca067f3936bb69a05d11aa12330d0c8d651ed1","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/styles.css","size":8977,"mtime":1765320581297,"ext":"css","content":"/* Sky Harbor Airport Ride-Hailing Dashboard Styles */\n/* UI/UX Specialist: Responsive and visually appealing interface */\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1400px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 20px;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\n    overflow: hidden;\n}\n\n/* Header */\n.header {\n    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);\n    color: white;\n    padding: 30px;\n    text-align: center;\n}\n\n.header h1 {\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n    font-weight: 700;\n}\n\n.header h2 {\n    font-size: 1.3rem;\n    font-weight: 300;\n    opacity: 0.9;\n}\n\n/* Terminal Tabs */\n.terminal-tabs {\n    display: flex;\n    gap: 10px;\n    padding: 20px;\n    background: #f5f5f5;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.tab-button {\n    flex: 1;\n    padding: 15px 30px;\n    font-size: 1.1rem;\n    font-weight: 600;\n    border: none;\n    border-radius: 10px;\n    background: white;\n    color: #666;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.tab-button:hover {\n    background: #e3f2fd;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);\n}\n\n.tab-button.active {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);\n}\n\n/* Guidance Banner */\n.guidance-banner {\n    margin: 20px;\n    padding: 25px;\n    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);\n    border-radius: 15px;\n    color: white;\n    box-shadow: 0 5px 20px rgba(79, 172, 254, 0.3);\n    animation: slideIn 0.5s ease;\n}\n\n@keyframes slideIn {\n    from {\n        opacity: 0;\n        transform: translateY(-20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.banner-content {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    margin-bottom: 15px;\n}\n\n.banner-icon {\n    font-size: 2rem;\n}\n\n.guidance-message {\n    font-size: 1.4rem;\n    font-weight: 600;\n    flex: 1;\n}\n\n.banner-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n    gap: 15px;\n    margin-top: 15px;\n    padding-top: 15px;\n    border-top: 1px solid rgba(255, 255, 255, 0.3);\n}\n\n.detail-item {\n    display: flex;\n    flex-direction: column;\n    gap: 5px;\n}\n\n.detail-label {\n    font-size: 0.9rem;\n    opacity: 0.9;\n}\n\n.detail-value {\n    font-size: 1.2rem;\n    font-weight: 700;\n}\n\n/* Forecast Section */\n.forecast-section {\n    padding: 30px;\n    background: #fafafa;\n}\n\n.forecast-section h3 {\n    font-size: 1.8rem;\n    margin-bottom: 25px;\n    color: #333;\n    text-align: center;\n}\n\n.forecast-cards {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 25px;\n}\n\n.forecast-card {\n    background: white;\n    border-radius: 15px;\n    padding: 25px;\n    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n    transition: transform 0.3s ease, box-shadow 0.3s ease;\n}\n\n.forecast-card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);\n}\n\n.card-header {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #f0f0f0;\n}\n\n.card-icon {\n    font-size: 1.8rem;\n}\n\n.card-title {\n    font-size: 1.3rem;\n    font-weight: 600;\n    color: #333;\n}\n\n.card-content {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n}\n\n.current-value, .forecast-value {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.value-label {\n    font-size: 0.95rem;\n    color: #666;\n}\n\n.value-amount {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: #2a5298;\n}\n\n/* Trend Badge */\n.trend-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px 15px;\n    border-radius: 20px;\n    font-weight: 600;\n    font-size: 0.9rem;\n    width: fit-content;\n}\n\n.trend-badge.flat {\n    background: #e0e0e0;\n    color: #666;\n}\n\n.trend-badge.up {\n    background: #ffebee;\n    color: #c62828;\n}\n\n.trend-badge.down {\n    background: #e8f5e9;\n    color: #2e7d32;\n}\n\n.trend-icon {\n    font-size: 1.2rem;\n}\n\n.trend-badge.up .trend-icon::before {\n    content: \"‚Üë\";\n}\n\n.trend-badge.down .trend-icon::before {\n    content: \"‚Üì\";\n}\n\n.trend-badge.flat .trend-icon::before {\n    content: \"‚Üí\";\n}\n\n/* Sparkline Container */\n.sparkline-container {\n    margin-top: 10px;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n/* Map Section */\n.map-section {\n    padding: 30px;\n    background: white;\n}\n\n.map-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 15px;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.map-section h3 {\n    font-size: 1.8rem;\n    margin: 0;\n    color: #333;\n}\n\n.animation-controls {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.control-btn {\n    padding: 8px 16px;\n    font-size: 0.9rem;\n    font-weight: 600;\n    border: none;\n    border-radius: 8px;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.control-btn:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 10px rgba(102, 126, 234, 0.3);\n}\n\n.control-btn:active {\n    transform: translateY(0);\n}\n\n.speed-indicator {\n    padding: 8px 12px;\n    font-weight: 700;\n    color: #333;\n    background: #f0f0f0;\n    border-radius: 8px;\n    min-width: 40px;\n    text-align: center;\n}\n\n.time-display {\n    text-align: center;\n    margin-bottom: 15px;\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: #2a5298;\n    padding: 10px;\n    background: #e3f2fd;\n    border-radius: 8px;\n}\n\n.time-slider-container {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    margin-bottom: 20px;\n    padding: 15px;\n    background: #f5f5f5;\n    border-radius: 8px;\n}\n\n.time-slider-container label {\n    font-weight: 600;\n    color: #333;\n}\n\n.time-slider {\n    flex: 1;\n    height: 8px;\n    border-radius: 5px;\n    background: #ddd;\n    outline: none;\n    -webkit-appearance: none;\n}\n\n.time-slider::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    appearance: none;\n    width: 20px;\n    height: 20px;\n    border-radius: 50%;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    cursor: pointer;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n}\n\n.time-slider::-moz-range-thumb {\n    width: 20px;\n    height: 20px;\n    border-radius: 50%;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    cursor: pointer;\n    border: none;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n}\n\n#time-slider-value {\n    font-weight: 700;\n    color: #2a5298;\n    min-width: 50px;\n    text-align: center;\n}\n\n.map-container {\n    position: relative;\n    width: 100%;\n    max-width: 1000px;\n    margin: 0 auto;\n    border-radius: 15px;\n    overflow: hidden;\n    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);\n}\n\n.map-image {\n    width: 100%;\n    height: auto;\n    display: block;\n}\n\n.map-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n}\n\n/* Status Footer */\n.status-footer {\n    display: flex;\n    justify-content: space-around;\n    padding: 20px;\n    background: #f5f5f5;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n    gap: 20px;\n}\n\n.status-item {\n    display: flex;\n    gap: 10px;\n    align-items: center;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #666;\n}\n\n.status-value {\n    color: #333;\n    font-weight: 500;\n}\n\n.status-value.success {\n    color: #2e7d32;\n}\n\n.status-value.error {\n    color: #c62828;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 1.8rem;\n    }\n\n    .header h2 {\n        font-size: 1rem;\n    }\n\n    .guidance-message {\n        font-size: 1.1rem;\n    }\n\n    .forecast-cards {\n        grid-template-columns: 1fr;\n    }\n\n    .banner-details {\n        grid-template-columns: 1fr;\n    }\n\n    .terminal-tabs {\n        flex-direction: column;\n    }\n\n    .tab-button {\n        width: 100%;\n    }\n}\n\n@media (max-width: 480px) {\n    body {\n        padding: 10px;\n    }\n\n    .container {\n        border-radius: 10px;\n    }\n\n    .header {\n        padding: 20px;\n    }\n\n    .forecast-section,\n    .map-section {\n        padding: 20px;\n    }\n}\n\n/* Loading Animation */\n@keyframes pulse {\n    0%, 100% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0.5;\n    }\n}\n\n.loading {\n    animation: pulse 1.5s ease-in-out infinite;\n}\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:49:58.642Z","tree_hash":"0910629aecd6926147410b60575dd970c832e674b60b21285e318b9c07baa5ce","added":[],"modified":[{"path":"mini-project-3-team-tiger/dashboard.py","size":12077,"mtime":1765320594690,"ext":"py","content":"\"\"\"\nStreamlit Dashboard for Ride-Hailing Display at Sky Harbor Airport\nTime series visualization of parking lot status from 6:00 PM to 6:59 PM\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.patches import Rectangle, Circle, Patch\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport numpy as np\nfrom datetime import datetime, time\nimport os\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Sky Harbor Airport - Ride-Hailing Dashboard\",\n    page_icon=\"‚úàÔ∏è\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Paths\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\nDATA_FILE = os.path.join(BASE_DIR, 'assets', 'ride_hailing.xlsx')\nMAP_FILE = os.path.join(BASE_DIR, 'assets', 'map.png')\nPLATES_DIR = os.path.join(BASE_DIR, 'assets', 'plates')\n\n# Load data\n@st.cache_data\ndef load_data():\n    \"\"\"Load the ride_hailing dataset from the first sheet\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        st.error(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Load background image\n@st.cache_data\ndef load_map():\n    \"\"\"Load the map background image\"\"\"\n    try:\n        img = Image.open(MAP_FILE)\n        return img, img.size\n    except Exception as e:\n        st.error(f\"Error loading map: {e}\")\n        return None, None\n\n# Load plate image\ndef load_plate_image(plate_number):\n    \"\"\"Load license plate image if available\"\"\"\n    if pd.isna(plate_number) or plate_number is None:\n        return None\n    plate_path = os.path.join(PLATES_DIR, f\"{str(plate_number).strip()}.png\")\n    if os.path.exists(plate_path):\n        try:\n            return Image.open(plate_path)\n        except:\n            return None\n    return None\n\n# Initialize session state\nif 'is_playing' not in st.session_state:\n    st.session_state.is_playing = False\nif 'current_time_index' not in st.session_state:\n    st.session_state.current_time_index = 0\nif 'reset_flag' not in st.session_state:\n    st.session_state.reset_flag = False\n\n# Load data\ndf = load_data()\nmap_img, map_size = load_map()\n\nif df.empty or map_img is None:\n    st.error(\"Failed to load data or map image. Please check the files.\")\n    st.stop()\n\n# Get map dimensions for scaling\nif map_size:\n    map_width, map_height = map_size\nelse:\n    map_width, map_height = 1000, 1000  # Default dimensions\n\n# Process time column - extract time component\ndf['time_only'] = df['current_time'].dt.time\n\n# Filter data for 6:00 PM to 6:59 PM\nstart_time = time(18, 0)  # 6:00 PM\nend_time = time(18, 59)   # 6:59 PM\n\ndf_filtered = df[\n    (df['time_only'] >= start_time) & \n    (df['time_only'] <= end_time)\n].copy()\n\nif df_filtered.empty:\n    st.warning(\"No data found for 6:00 PM to 6:59 PM\")\n    st.write(\"Sample data:\", df.head())\n    st.stop()\n\n# Sort by time\ndf_filtered = df_filtered.sort_values('current_time').reset_index(drop=True)\n\n# Get unique times for slider (one per minute)\nunique_times = sorted(df_filtered['time_only'].unique())\nunique_datetimes = sorted(df_filtered['current_time'].unique())\n\n# Main layout\nst.title(\"‚úàÔ∏è Sky Harbor Airport - Ride-Hailing Dashboard\")\nst.markdown(\"**Time Range: 6:00 PM - 6:59 PM**\")\n\n# Sidebar for controls and ride details\nwith st.sidebar:\n    st.header(\"üéÆ Controls\")\n    \n    # Time slider\n    if len(unique_times) > 0:\n        # Create time labels for display\n        time_labels = [t.strftime('%H:%M') for t in unique_times]\n        \n        time_index = st.slider(\n            \"Select Time (Minutes)\",\n            min_value=0,\n            max_value=len(unique_times) - 1,\n            value=st.session_state.current_time_index,\n            format=\"%s\",\n            help=f\"Time range: {unique_times[0].strftime('%H:%M')} to {unique_times[-1].strftime('%H:%M')}\"\n        )\n        st.session_state.current_time_index = time_index\n        \n        # Display selected time\n        selected_time = unique_times[time_index]\n        st.write(f\"**Selected Time:** {selected_time.strftime('%H:%M:%S')}\")\n    else:\n        st.warning(\"No time data available\")\n        time_index = 0\n    \n    st.divider()\n    \n    # Control buttons\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        if st.button(\"‚ñ∂Ô∏è Start\", use_container_width=True, type=\"primary\"):\n            st.session_state.is_playing = True\n            st.rerun()\n    \n    with col2:\n        if st.button(\"‚è∏Ô∏è Stop\", use_container_width=True):\n            st.session_state.is_playing = False\n            st.rerun()\n    \n    if st.button(\"üîÑ Reset\", use_container_width=True):\n        st.session_state.current_time_index = 0\n        st.session_state.is_playing = False\n        st.session_state.reset_flag = True\n        st.rerun()\n    \n    st.divider()\n    \n    # Display current time metric\n    if len(unique_times) > 0 and time_index < len(unique_times):\n        current_time = unique_times[time_index]\n        st.metric(\"Current Time\", current_time.strftime(\"%H:%M:%S\"))\n    \n    st.divider()\n    st.header(\"üìã Ride Details\")\n    \n    # Get current time data\n    if len(unique_times) > 0 and time_index < len(unique_times):\n        current_time = unique_times[time_index]\n        current_data = df_filtered[df_filtered['time_only'] == current_time]\n        \n        # Filter out rows with NaN positions (empty slots)\n        current_data_active = current_data[\n            current_data['x'].notna() & current_data['y'].notna()\n        ].copy()\n        \n        st.metric(\"Active Slots\", len(current_data_active))\n        st.metric(\"Total Slots\", len(current_data))\n        \n        # Display ride details\n        if len(current_data_active) > 0:\n            for idx, row in current_data_active.iterrows():\n                with st.expander(f\"üöó Slot {int(row['slot_id'])}\", expanded=False):\n                    # Basic information\n                    st.write(f\"**Time:** {row['time_only'].strftime('%H:%M:%S')}\")\n                    st.write(f\"**Slot ID:** {int(row['slot_id'])}\")\n                    st.write(f\"**Position:** ({row['x']:.1f}, {row['y']:.1f})\")\n                    \n                    # License plate image\n                    if pd.notna(row.get('plate_number')):\n                        plate_number = str(row['plate_number']).strip()\n                        plate_img = load_plate_image(plate_number)\n                        if plate_img:\n                            st.image(plate_img, caption=f\"License Plate: {plate_number}\", width=200)\n                        else:\n                            st.write(f\"**License Plate:** {plate_number}\")\n                    \n                    # Additional ride information\n                    if pd.notna(row.get('reservation_id')):\n                        st.write(f\"**Reservation ID:** {row['reservation_id']}\")\n                    if pd.notna(row.get('rider_id')):\n                        st.write(f\"**Rider ID:** {row['rider_id']}\")\n                    if pd.notna(row.get('driver_id')):\n                        st.write(f\"**Driver ID:** {row['driver_id']}\")\n                    if pd.notna(row.get('service')):\n                        st.write(f\"**Service:** {row['service']}\")\n        else:\n            st.info(\"No active slots at this time\")\n\n# Main visualization area\nif len(unique_times) > 0 and time_index < len(unique_times):\n    current_time = unique_times[time_index]\n    current_data = df_filtered[df_filtered['time_only'] == current_time]\n    \n    # Filter active slots (with valid positions)\n    current_data_active = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    # Create visualization\n    fig, ax = plt.subplots(figsize=(14, 12))\n    \n    # Display background map\n    if map_img:\n        ax.imshow(map_img, extent=[0, map_width, map_height, 0], \n                 aspect='auto', alpha=1.0, origin='upper', interpolation='nearest')\n    \n    # Plot parking slots with license plates\n    if len(current_data_active) > 0:\n        for idx, row in current_data_active.iterrows():\n            slot_id = int(row['slot_id'])\n            x = float(row['x'])\n            y = float(row['y'])\n            \n            # Draw parking slot border (scaled based on map size)\n            slot_size = min(map_width, map_height) / 40  # Adaptive slot size\n            \n            # Load license plate image\n            plate_img = None\n            if pd.notna(row.get('plate_number')):\n                plate_number = str(row['plate_number']).strip()\n                plate_img = load_plate_image(plate_number)\n            \n            # Draw border\n            rect = Rectangle((x - slot_size/2, y - slot_size/2), \n                           slot_size, slot_size,\n                           linewidth=2, edgecolor='#FF4444', \n                           facecolor='none', alpha=1.0)\n            ax.add_patch(rect)\n            \n            # Draw license plate image if available\n            if plate_img:\n                # Calculate plate size in data coordinates\n                plate_size_data = slot_size * 0.95\n                \n                # Resize plate image for quality\n                target_pixels = 200\n                plate_img_resized = plate_img.copy()\n                plate_img_resized.thumbnail((target_pixels, target_pixels), Image.Resampling.LANCZOS)\n                \n                # Convert to numpy array\n                plate_array = np.array(plate_img_resized)\n                \n                # Calculate extent for imshow\n                left = x - plate_size_data / 2\n                right = x + plate_size_data / 2\n                bottom = y - plate_size_data / 2\n                top = y + plate_size_data / 2\n                \n                # Display the plate image\n                ax.imshow(plate_array, extent=[left, right, bottom, top], \n                         aspect='auto', alpha=1.0, interpolation='nearest', \n                         origin='upper', zorder=5)\n            \n            # Add slot ID label\n            font_size = max(8, min(map_width, map_height) / 120)\n            label_x = x - slot_size/2 + 3\n            label_y = y - slot_size/2 + 3\n            ax.text(label_x, label_y, str(slot_id), ha='left', va='top', \n                   fontsize=font_size, fontweight='bold', \n                   color='white', rotation=0,\n                   bbox=dict(boxstyle='round,pad=0.2', \n                   facecolor='black', alpha=1.0, edgecolor='red', linewidth=1),\n                   zorder=100)\n    \n    # Set axis limits based on map dimensions\n    ax.set_xlim(0, map_width)\n    ax.set_ylim(map_height, 0)  # Invert Y-axis to match image coordinates\n    \n    ax.set_title(f\"Parking Lot Status - {current_time.strftime('%H:%M:%S')}\", \n                fontsize=20, fontweight='bold', pad=20)\n    ax.set_xlabel(\"X Position\", fontsize=14)\n    ax.set_ylabel(\"Y Position\", fontsize=14)\n    ax.grid(True, alpha=0.2, linestyle='--', linewidth=0.5)\n    \n    # Add legend\n    from matplotlib.patches import Patch\n    legend_elements = [\n        Patch(facecolor='none', edgecolor='#FF4444', linewidth=2, label='Occupied Slot'),\n    ]\n    ax.legend(handles=legend_elements, loc='upper right', fontsize=11, framealpha=1.0)\n    \n    plt.tight_layout()\n    st.pyplot(fig, use_container_width=True)\n    \n    # Auto-play functionality\n    if st.session_state.is_playing:\n        if st.session_state.current_time_index < len(unique_times) - 1:\n            # Show playing status\n            status_placeholder = st.empty()\n            status_placeholder.info(\"‚è© Playing animation...\")\n            # Small delay before rerun\n            import time as time_module\n            time_module.sleep(0.5)  # 0.5 second delay between frames\n            st.session_state.current_time_index += 1\n            st.rerun()\n        else:\n            st.session_state.is_playing = False\n            st.success(\"‚úÖ Reached end of time range\")\n\nelse:\n    st.warning(\"No data available for visualization\")\n\n"},{"path":"mini-project-3-team-tiger/frontend/app.js","size":20114,"mtime":1765320594690,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: true,\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        const data = await response.json();\n        \n        if (data.error || !data.timestamps) return;\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Start animation if playing\n        if (animationState.isPlaying) {\n            startAnimation();\n        } else {\n            // Just load current frame\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    timeSlider.addEventListener('input', (e) => {\n        const minute = parseInt(e.target.value);\n        const hour = 18; // 6 PM\n        const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        timeSliderValue.textContent = timeString;\n        \n        // Find matching timestamp\n        if (animationState.timestamps.length > 0) {\n            const targetTime = new Date(`2025-09-17T${timeString}:00`);\n            const closestIndex = animationState.timestamps.findIndex(ts => {\n                const tsDate = new Date(ts);\n                return tsDate.getHours() === hour && tsDate.getMinutes() === minute;\n            });\n            \n            if (closestIndex >= 0) {\n                animationState.currentTimeIndex = closestIndex;\n                updateMapVisualizationForTime(animationState.timestamps[closestIndex]);\n            }\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        // Process all slots and draw them\n        const slotPromises = data.slots.map(async (slot) => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Load and draw license plate image if available\n                if (slot.plate_number) {\n                    const plateImg = await loadPlateImage(slot.plate_number);\n                    if (plateImg) {\n                        // Draw license plate image\n                        const plateSize = slotSize * 0.9;\n                        mapContext.drawImage(\n                            plateImg,\n                            x - plateSize / 2,\n                            y - plateSize / 2,\n                            plateSize,\n                            plateSize\n                        );\n                    }\n                }\n                \n                // Draw slot ID label (on top)\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        });\n        \n        // Wait for all slots to be drawn\n        await Promise.all(slotPromises);\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"},{"path":"mini-project-3-team-tiger/frontend/index.html","size":6669,"mtime":1765320594690,"ext":"html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Sky Harbor Airport - Ride-Hailing Dashboard</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <!-- Header -->\n        <header class=\"header\">\n            <h1>‚úàÔ∏è Sky Harbor Airport</h1>\n            <h2>Ride-Hailing Display Dashboard</h2>\n        </header>\n\n        <!-- Terminal Selection Tabs -->\n        <div class=\"terminal-tabs\">\n            <button class=\"tab-button active\" data-terminal=\"Terminal 3\">Terminal 3</button>\n            <button class=\"tab-button\" data-terminal=\"Terminal 4\">Terminal 4</button>\n        </div>\n\n        <!-- Terminal Guidance Banner -->\n        <div id=\"guidance-banner\" class=\"guidance-banner\">\n            <div class=\"banner-content\">\n                <span class=\"banner-icon\">üìç</span>\n                <span id=\"guidance-message\" class=\"guidance-message\">Loading guidance...</span>\n            </div>\n            <div class=\"banner-details\">\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Zone:</span>\n                    <span id=\"zone-name\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Walking Time:</span>\n                    <span id=\"walking-time\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Estimated Wait:</span>\n                    <span id=\"estimated-wait\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Available Slots:</span>\n                    <span id=\"available-slots\" class=\"detail-value\">-</span>\n                </div>\n            </div>\n        </div>\n\n        <!-- Price & Wait Forecast Section -->\n        <div class=\"forecast-section\">\n            <h3>Price & Wait Forecast (15-30 min horizon)</h3>\n            \n            <div class=\"forecast-cards\">\n                <!-- Price Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">üí∞</span>\n                        <span class=\"card-title\">Price Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"price-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"price-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Wait Time Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">‚è±Ô∏è</span>\n                        <span class=\"card-title\">Wait Time Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"wait-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"wait-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- Map Visualization -->\n        <div class=\"map-section\">\n            <div class=\"map-header\">\n                <h3>Live Map View - Parking Lot Status (6:00 PM - 6:59 PM)</h3>\n                <div class=\"animation-controls\">\n                    <button id=\"play-pause-btn\" class=\"control-btn\">‚è∏Ô∏è Pause</button>\n                    <button id=\"speed-down-btn\" class=\"control-btn\">‚è™ Slow</button>\n                    <span id=\"speed-indicator\" class=\"speed-indicator\">1x</span>\n                    <button id=\"speed-up-btn\" class=\"control-btn\">‚è© Fast</button>\n                    <button id=\"reset-btn\" class=\"control-btn\">üîÑ Reset</button>\n                </div>\n            </div>\n            <div class=\"time-display\">\n                <span id=\"current-time-display\">Time: --:--:--</span>\n            </div>\n            <div class=\"time-slider-container\">\n                <label for=\"time-slider\">Select Time:</label>\n                <input type=\"range\" id=\"time-slider\" min=\"0\" max=\"59\" value=\"0\" class=\"time-slider\">\n                <span id=\"time-slider-value\">18:00</span>\n            </div>\n            <div class=\"map-container\">\n                <img id=\"map-image\" src=\"../assets/map.png\" alt=\"Airport Map\" class=\"map-image\">\n                <canvas id=\"map-overlay\" class=\"map-overlay\"></canvas>\n            </div>\n        </div>\n\n        <!-- Status Footer -->\n        <footer class=\"status-footer\">\n            <div class=\"status-item\">\n                <span class=\"status-label\">Last Updated:</span>\n                <span id=\"last-updated\" class=\"status-value\">-</span>\n            </div>\n            <div class=\"status-item\">\n                <span class=\"status-label\">API Status:</span>\n                <span id=\"api-status\" class=\"status-value\">Checking...</span>\n            </div>\n        </footer>\n    </div>\n\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n"},{"path":"mini-project-3-team-tiger/frontend/styles.css","size":8977,"mtime":1765320594690,"ext":"css","content":"/* Sky Harbor Airport Ride-Hailing Dashboard Styles */\n/* UI/UX Specialist: Responsive and visually appealing interface */\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1400px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 20px;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\n    overflow: hidden;\n}\n\n/* Header */\n.header {\n    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);\n    color: white;\n    padding: 30px;\n    text-align: center;\n}\n\n.header h1 {\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n    font-weight: 700;\n}\n\n.header h2 {\n    font-size: 1.3rem;\n    font-weight: 300;\n    opacity: 0.9;\n}\n\n/* Terminal Tabs */\n.terminal-tabs {\n    display: flex;\n    gap: 10px;\n    padding: 20px;\n    background: #f5f5f5;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.tab-button {\n    flex: 1;\n    padding: 15px 30px;\n    font-size: 1.1rem;\n    font-weight: 600;\n    border: none;\n    border-radius: 10px;\n    background: white;\n    color: #666;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.tab-button:hover {\n    background: #e3f2fd;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);\n}\n\n.tab-button.active {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);\n}\n\n/* Guidance Banner */\n.guidance-banner {\n    margin: 20px;\n    padding: 25px;\n    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);\n    border-radius: 15px;\n    color: white;\n    box-shadow: 0 5px 20px rgba(79, 172, 254, 0.3);\n    animation: slideIn 0.5s ease;\n}\n\n@keyframes slideIn {\n    from {\n        opacity: 0;\n        transform: translateY(-20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.banner-content {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    margin-bottom: 15px;\n}\n\n.banner-icon {\n    font-size: 2rem;\n}\n\n.guidance-message {\n    font-size: 1.4rem;\n    font-weight: 600;\n    flex: 1;\n}\n\n.banner-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n    gap: 15px;\n    margin-top: 15px;\n    padding-top: 15px;\n    border-top: 1px solid rgba(255, 255, 255, 0.3);\n}\n\n.detail-item {\n    display: flex;\n    flex-direction: column;\n    gap: 5px;\n}\n\n.detail-label {\n    font-size: 0.9rem;\n    opacity: 0.9;\n}\n\n.detail-value {\n    font-size: 1.2rem;\n    font-weight: 700;\n}\n\n/* Forecast Section */\n.forecast-section {\n    padding: 30px;\n    background: #fafafa;\n}\n\n.forecast-section h3 {\n    font-size: 1.8rem;\n    margin-bottom: 25px;\n    color: #333;\n    text-align: center;\n}\n\n.forecast-cards {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 25px;\n}\n\n.forecast-card {\n    background: white;\n    border-radius: 15px;\n    padding: 25px;\n    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n    transition: transform 0.3s ease, box-shadow 0.3s ease;\n}\n\n.forecast-card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);\n}\n\n.card-header {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #f0f0f0;\n}\n\n.card-icon {\n    font-size: 1.8rem;\n}\n\n.card-title {\n    font-size: 1.3rem;\n    font-weight: 600;\n    color: #333;\n}\n\n.card-content {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n}\n\n.current-value, .forecast-value {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.value-label {\n    font-size: 0.95rem;\n    color: #666;\n}\n\n.value-amount {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: #2a5298;\n}\n\n/* Trend Badge */\n.trend-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px 15px;\n    border-radius: 20px;\n    font-weight: 600;\n    font-size: 0.9rem;\n    width: fit-content;\n}\n\n.trend-badge.flat {\n    background: #e0e0e0;\n    color: #666;\n}\n\n.trend-badge.up {\n    background: #ffebee;\n    color: #c62828;\n}\n\n.trend-badge.down {\n    background: #e8f5e9;\n    color: #2e7d32;\n}\n\n.trend-icon {\n    font-size: 1.2rem;\n}\n\n.trend-badge.up .trend-icon::before {\n    content: \"‚Üë\";\n}\n\n.trend-badge.down .trend-icon::before {\n    content: \"‚Üì\";\n}\n\n.trend-badge.flat .trend-icon::before {\n    content: \"‚Üí\";\n}\n\n/* Sparkline Container */\n.sparkline-container {\n    margin-top: 10px;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n/* Map Section */\n.map-section {\n    padding: 30px;\n    background: white;\n}\n\n.map-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 15px;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.map-section h3 {\n    font-size: 1.8rem;\n    margin: 0;\n    color: #333;\n}\n\n.animation-controls {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.control-btn {\n    padding: 8px 16px;\n    font-size: 0.9rem;\n    font-weight: 600;\n    border: none;\n    border-radius: 8px;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.control-btn:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 10px rgba(102, 126, 234, 0.3);\n}\n\n.control-btn:active {\n    transform: translateY(0);\n}\n\n.speed-indicator {\n    padding: 8px 12px;\n    font-weight: 700;\n    color: #333;\n    background: #f0f0f0;\n    border-radius: 8px;\n    min-width: 40px;\n    text-align: center;\n}\n\n.time-display {\n    text-align: center;\n    margin-bottom: 15px;\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: #2a5298;\n    padding: 10px;\n    background: #e3f2fd;\n    border-radius: 8px;\n}\n\n.time-slider-container {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    margin-bottom: 20px;\n    padding: 15px;\n    background: #f5f5f5;\n    border-radius: 8px;\n}\n\n.time-slider-container label {\n    font-weight: 600;\n    color: #333;\n}\n\n.time-slider {\n    flex: 1;\n    height: 8px;\n    border-radius: 5px;\n    background: #ddd;\n    outline: none;\n    -webkit-appearance: none;\n}\n\n.time-slider::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    appearance: none;\n    width: 20px;\n    height: 20px;\n    border-radius: 50%;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    cursor: pointer;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n}\n\n.time-slider::-moz-range-thumb {\n    width: 20px;\n    height: 20px;\n    border-radius: 50%;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    cursor: pointer;\n    border: none;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n}\n\n#time-slider-value {\n    font-weight: 700;\n    color: #2a5298;\n    min-width: 50px;\n    text-align: center;\n}\n\n.map-container {\n    position: relative;\n    width: 100%;\n    max-width: 1000px;\n    margin: 0 auto;\n    border-radius: 15px;\n    overflow: hidden;\n    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);\n}\n\n.map-image {\n    width: 100%;\n    height: auto;\n    display: block;\n}\n\n.map-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n}\n\n/* Status Footer */\n.status-footer {\n    display: flex;\n    justify-content: space-around;\n    padding: 20px;\n    background: #f5f5f5;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n    gap: 20px;\n}\n\n.status-item {\n    display: flex;\n    gap: 10px;\n    align-items: center;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #666;\n}\n\n.status-value {\n    color: #333;\n    font-weight: 500;\n}\n\n.status-value.success {\n    color: #2e7d32;\n}\n\n.status-value.error {\n    color: #c62828;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 1.8rem;\n    }\n\n    .header h2 {\n        font-size: 1rem;\n    }\n\n    .guidance-message {\n        font-size: 1.1rem;\n    }\n\n    .forecast-cards {\n        grid-template-columns: 1fr;\n    }\n\n    .banner-details {\n        grid-template-columns: 1fr;\n    }\n\n    .terminal-tabs {\n        flex-direction: column;\n    }\n\n    .tab-button {\n        width: 100%;\n    }\n}\n\n@media (max-width: 480px) {\n    body {\n        padding: 10px;\n    }\n\n    .container {\n        border-radius: 10px;\n    }\n\n    .header {\n        padding: 20px;\n    }\n\n    .forecast-section,\n    .map-section {\n        padding: 20px;\n    }\n}\n\n/* Loading Animation */\n@keyframes pulse {\n    0%, 100% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0.5;\n    }\n}\n\n.loading {\n    animation: pulse 1.5s ease-in-out infinite;\n}\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:55:33.400Z","tree_hash":"1e1e4127d43d1bacfa387882313f7ee60393a0304847ef0b91e163f2e4606edf","added":[{"path":"mini-project-3-team-tiger/test_backend.py","size":1815,"mtime":1765320930962,"ext":"py","content":"#!/usr/bin/env python3\n\"\"\"Quick test script to verify backend setup\"\"\"\n\nimport sys\nimport os\n\n# Add backend to path\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), 'backend'))\n\ntry:\n    from app import app, get_data, DATA_FILE\n    import pandas as pd\n    \n    print(\"‚úì Backend imports successful\")\n    print(f\"‚úì Data file path: {DATA_FILE}\")\n    print(f\"‚úì Data file exists: {os.path.exists(DATA_FILE)}\")\n    \n    # Test data loading\n    df = get_data()\n    print(f\"‚úì Data loaded: {len(df)} rows\")\n    print(f\"‚úì Columns: {list(df.columns)}\")\n    \n    # Test unique timestamps\n    if not df.empty:\n        unique_times = sorted(df['current_time'].unique())\n        print(f\"‚úì Unique timestamps: {len(unique_times)}\")\n        print(f\"‚úì Time range: {unique_times[0]} to {unique_times[-1]}\")\n        \n        # Test filtering for 6 PM\n        df['time_only'] = df['current_time'].dt.time\n        from datetime import time\n        df_filtered = df[(df['time_only'] >= time(18, 0)) & (df['time_only'] <= time(18, 59))]\n        print(f\"‚úì 6 PM data: {len(df_filtered)} rows\")\n        \n        if len(df_filtered) > 0:\n            sample = df_filtered[df_filtered['x'].notna() & df_filtered['y'].notna()].head(1)\n            if len(sample) > 0:\n                print(f\"‚úì Sample slot: ID={sample.iloc[0]['slot_id']}, x={sample.iloc[0]['x']}, y={sample.iloc[0]['y']}\")\n                if pd.notna(sample.iloc[0].get('plate_number')):\n                    print(f\"‚úì Sample plate: {sample.iloc[0]['plate_number']}\")\n    \n    print(\"\\n‚úì All tests passed! Backend should work.\")\n    print(\"\\nTo start the backend server:\")\n    print(\"  cd backend\")\n    print(\"  python3 app.py\")\n    \nexcept Exception as e:\n    print(f\"‚úó Error: {e}\")\n    import traceback\n    traceback.print_exc()\n    sys.exit(1)\n\n"}],"modified":[{"path":"mini-project-3-team-tiger/test_backend.py","size":1815,"mtime":1765320930962,"ext":"py","content":"#!/usr/bin/env python3\n\"\"\"Quick test script to verify backend setup\"\"\"\n\nimport sys\nimport os\n\n# Add backend to path\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), 'backend'))\n\ntry:\n    from app import app, get_data, DATA_FILE\n    import pandas as pd\n    \n    print(\"‚úì Backend imports successful\")\n    print(f\"‚úì Data file path: {DATA_FILE}\")\n    print(f\"‚úì Data file exists: {os.path.exists(DATA_FILE)}\")\n    \n    # Test data loading\n    df = get_data()\n    print(f\"‚úì Data loaded: {len(df)} rows\")\n    print(f\"‚úì Columns: {list(df.columns)}\")\n    \n    # Test unique timestamps\n    if not df.empty:\n        unique_times = sorted(df['current_time'].unique())\n        print(f\"‚úì Unique timestamps: {len(unique_times)}\")\n        print(f\"‚úì Time range: {unique_times[0]} to {unique_times[-1]}\")\n        \n        # Test filtering for 6 PM\n        df['time_only'] = df['current_time'].dt.time\n        from datetime import time\n        df_filtered = df[(df['time_only'] >= time(18, 0)) & (df['time_only'] <= time(18, 59))]\n        print(f\"‚úì 6 PM data: {len(df_filtered)} rows\")\n        \n        if len(df_filtered) > 0:\n            sample = df_filtered[df_filtered['x'].notna() & df_filtered['y'].notna()].head(1)\n            if len(sample) > 0:\n                print(f\"‚úì Sample slot: ID={sample.iloc[0]['slot_id']}, x={sample.iloc[0]['x']}, y={sample.iloc[0]['y']}\")\n                if pd.notna(sample.iloc[0].get('plate_number')):\n                    print(f\"‚úì Sample plate: {sample.iloc[0]['plate_number']}\")\n    \n    print(\"\\n‚úì All tests passed! Backend should work.\")\n    print(\"\\nTo start the backend server:\")\n    print(\"  cd backend\")\n    print(\"  python3 app.py\")\n    \nexcept Exception as e:\n    print(f\"‚úó Error: {e}\")\n    import traceback\n    traceback.print_exc()\n    sys.exit(1)\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:55:43.405Z","tree_hash":"6d95ca463b7aee1795d82108f798d1ee5e926c2629906385664172a8bed8bf5a","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":20152,"mtime":1765320940467,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: false, // Start paused, user can click play\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        const data = await response.json();\n        \n        if (data.error || !data.timestamps) return;\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Start animation if playing\n        if (animationState.isPlaying) {\n            startAnimation();\n        } else {\n            // Just load current frame\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    timeSlider.addEventListener('input', (e) => {\n        const minute = parseInt(e.target.value);\n        const hour = 18; // 6 PM\n        const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        timeSliderValue.textContent = timeString;\n        \n        // Find matching timestamp\n        if (animationState.timestamps.length > 0) {\n            const targetTime = new Date(`2025-09-17T${timeString}:00`);\n            const closestIndex = animationState.timestamps.findIndex(ts => {\n                const tsDate = new Date(ts);\n                return tsDate.getHours() === hour && tsDate.getMinutes() === minute;\n            });\n            \n            if (closestIndex >= 0) {\n                animationState.currentTimeIndex = closestIndex;\n                updateMapVisualizationForTime(animationState.timestamps[closestIndex]);\n            }\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        // Process all slots and draw them\n        const slotPromises = data.slots.map(async (slot) => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Load and draw license plate image if available\n                if (slot.plate_number) {\n                    const plateImg = await loadPlateImage(slot.plate_number);\n                    if (plateImg) {\n                        // Draw license plate image\n                        const plateSize = slotSize * 0.9;\n                        mapContext.drawImage(\n                            plateImg,\n                            x - plateSize / 2,\n                            y - plateSize / 2,\n                            plateSize,\n                            plateSize\n                        );\n                    }\n                }\n                \n                // Draw slot ID label (on top)\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        });\n        \n        // Wait for all slots to be drawn\n        await Promise.all(slotPromises);\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:55:48.405Z","tree_hash":"43a26a493b92b513eb46d125e1667b5bde8ac5a5f7ba9cb2878f6e9dd4988e6d","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":20833,"mtime":1765320946223,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: false, // Start paused, user can click play\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error || !data.timestamps || data.timestamps.length === 0) {\n            console.error('No timestamps available:', data);\n            return;\n        }\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Update slider max value\n        const timeSlider = document.getElementById('time-slider');\n        if (timeSlider) {\n            timeSlider.max = data.timestamps.length - 1;\n        }\n        \n        // Load first frame\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n        \n        console.log(`Loaded ${data.timestamps.length} timestamps`);\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n        console.error('Make sure the backend server is running on http://localhost:5001');\n        document.getElementById('current-time-display').textContent = \n            'Error: Cannot connect to backend. Make sure server is running.';\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    timeSlider.addEventListener('input', (e) => {\n        const minute = parseInt(e.target.value);\n        const hour = 18; // 6 PM\n        const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        timeSliderValue.textContent = timeString;\n        \n        // Find matching timestamp\n        if (animationState.timestamps.length > 0) {\n            const targetTime = new Date(`2025-09-17T${timeString}:00`);\n            const closestIndex = animationState.timestamps.findIndex(ts => {\n                const tsDate = new Date(ts);\n                return tsDate.getHours() === hour && tsDate.getMinutes() === minute;\n            });\n            \n            if (closestIndex >= 0) {\n                animationState.currentTimeIndex = closestIndex;\n                updateMapVisualizationForTime(animationState.timestamps[closestIndex]);\n            }\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        // Process all slots and draw them\n        const slotPromises = data.slots.map(async (slot) => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Load and draw license plate image if available\n                if (slot.plate_number) {\n                    const plateImg = await loadPlateImage(slot.plate_number);\n                    if (plateImg) {\n                        // Draw license plate image\n                        const plateSize = slotSize * 0.9;\n                        mapContext.drawImage(\n                            plateImg,\n                            x - plateSize / 2,\n                            y - plateSize / 2,\n                            plateSize,\n                            plateSize\n                        );\n                    }\n                }\n                \n                // Draw slot ID label (on top)\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        });\n        \n        // Wait for all slots to be drawn\n        await Promise.all(slotPromises);\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:55:53.409Z","tree_hash":"a4fa064194b38a75097bbd7120202ce6db14b82acf831b88eeed1a6624cc6b3d","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":20694,"mtime":1765320951957,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: false, // Start paused, user can click play\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error || !data.timestamps || data.timestamps.length === 0) {\n            console.error('No timestamps available:', data);\n            return;\n        }\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Update slider max value\n        const timeSlider = document.getElementById('time-slider');\n        if (timeSlider) {\n            timeSlider.max = data.timestamps.length - 1;\n        }\n        \n        // Load first frame\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n        \n        console.log(`Loaded ${data.timestamps.length} timestamps`);\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n        console.error('Make sure the backend server is running on http://localhost:5001');\n        document.getElementById('current-time-display').textContent = \n            'Error: Cannot connect to backend. Make sure server is running.';\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    if (!timeSlider || !timeSliderValue) {\n        console.error('Time slider elements not found');\n        return;\n    }\n    \n    timeSlider.addEventListener('input', (e) => {\n        const index = parseInt(e.target.value);\n        \n        if (animationState.timestamps.length > 0 && index >= 0 && index < animationState.timestamps.length) {\n            animationState.currentTimeIndex = index;\n            const timestamp = animationState.timestamps[index];\n            const timeObj = new Date(timestamp);\n            const timeString = `${timeObj.getHours().toString().padStart(2, '0')}:${timeObj.getMinutes().toString().padStart(2, '0')}`;\n            timeSliderValue.textContent = timeString;\n            updateMapVisualizationForTime(timestamp);\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        // Process all slots and draw them\n        const slotPromises = data.slots.map(async (slot) => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Load and draw license plate image if available\n                if (slot.plate_number) {\n                    const plateImg = await loadPlateImage(slot.plate_number);\n                    if (plateImg) {\n                        // Draw license plate image\n                        const plateSize = slotSize * 0.9;\n                        mapContext.drawImage(\n                            plateImg,\n                            x - plateSize / 2,\n                            y - plateSize / 2,\n                            plateSize,\n                            plateSize\n                        );\n                    }\n                }\n                \n                // Draw slot ID label (on top)\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        });\n        \n        // Wait for all slots to be drawn\n        await Promise.all(slotPromises);\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:56:08.536Z","tree_hash":"c331a45ae3d64d550cde06aa2c7b0acfc77de93352afaa563b4620eaaa5c0660","added":[{"path":"mini-project-3-team-tiger/TROUBLESHOOTING.md","size":0,"mtime":1765320968149,"ext":"md","content":"# Troubleshooting Guide\n\n## Quick Checklist\n\n### 1. Is the backend running?\n\n**Check:**\n```bash\ncurl http://localhost:5001/api/health\n```\n\n**Should return:** `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n**If not working:**\n```bash\ncd mini-project-3-team-tiger/backend\npython3 app.py\n```\n\nYou should see:\n```\nStarting Backend API Server...\nData file: /Users/.../assets/ride_hailing.xlsx\n * Running on http://0.0.0.0:5001\n```\n\n### 2. Is the frontend using a web server?\n\n**IMPORTANT:** You cannot open `index.html` directly (file://). You MUST use a web server.\n\n**Start a web server:**\n```bash\ncd mini-project-3-team-tiger/frontend\npython3 -m http.server 8000\n```\n\nThen open: `http://localhost:8000`\n\n### 3. Check browser console\n\n1. Open browser Developer Tools (F12 or Cmd+Option+I)\n2. Go to Console tab\n3. Look for errors\n\n**Common errors:**\n- `Failed to fetch` ‚Üí Backend not running\n- `CORS error` ‚Üí Not using a web server (opened file:// directly)\n- `Cannot read property` ‚Üí JavaScript error, check console\n\n### 4. Test backend endpoints manually\n\n```bash\n# Test health\ncurl http://localhost:5001/api/health\n\n# Test timestamps\ncurl http://localhost:5001/api/data/timestamps\n\n# Test specific time\ncurl \"http://localhost:5001/api/data/time/2025-09-17T18:00:00\"\n```\n\n### 5. Verify files exist\n\n```bash\ncd mini-project-3-team-tiger\nls assets/map.png          # Should exist\nls assets/ride_hailing.xlsx # Should exist\nls assets/plates/          # Should have 100 PNG files\n```\n\n### 6. Common Issues\n\n#### Map not showing\n- Check browser console for errors\n- Verify `map.png` exists in `assets/` folder\n- Check that backend is running\n\n#### License plates not showing\n- Check browser console for 404 errors on plate images\n- Verify plate images exist in `assets/plates/` folder\n- Check that plate numbers in data match filenames\n\n#### Animation not working\n- Check that timestamps loaded (see console)\n- Click \"Play\" button to start animation\n- Use time slider to navigate manually\n\n#### \"Unable to load guidance\" error\n- Backend not running\n- Wrong port (should be 5001, not 5000)\n- CORS issue (not using web server)\n\n## Step-by-Step Startup\n\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd /Users/felixisaac123/Desktop/MiniProject3/mini-project-3-team-tiger/backend\n   python3 app.py\n   ```\n   Keep this running!\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd /Users/felixisaac123/Desktop/MiniProject3/mini-project-3-team-tiger/frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Go to `http://localhost:8000`\n   - Open Developer Tools (F12)\n   - Check Console tab for any errors\n\n## Still Not Working?\n\nRun the test script:\n```bash\ncd mini-project-3-team-tiger\npython3 test_backend.py\n```\n\nThis will verify:\n- All dependencies are installed\n- Data file can be loaded\n- Backend code is correct\n\nIf test passes but frontend doesn't work, the issue is likely:\n- Backend not running\n- Frontend not using web server\n- Browser cache (try hard refresh: Cmd+Shift+R)\n\n"}],"modified":[{"path":"mini-project-3-team-tiger/TROUBLESHOOTING.md","size":3021,"mtime":1765320968283,"ext":"md","content":"# Troubleshooting Guide\n\n## Quick Checklist\n\n### 1. Is the backend running?\n\n**Check:**\n```bash\ncurl http://localhost:5001/api/health\n```\n\n**Should return:** `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n**If not working:**\n```bash\ncd mini-project-3-team-tiger/backend\npython3 app.py\n```\n\nYou should see:\n```\nStarting Backend API Server...\nData file: /Users/.../assets/ride_hailing.xlsx\n * Running on http://0.0.0.0:5001\n```\n\n### 2. Is the frontend using a web server?\n\n**IMPORTANT:** You cannot open `index.html` directly (file://). You MUST use a web server.\n\n**Start a web server:**\n```bash\ncd mini-project-3-team-tiger/frontend\npython3 -m http.server 8000\n```\n\nThen open: `http://localhost:8000`\n\n### 3. Check browser console\n\n1. Open browser Developer Tools (F12 or Cmd+Option+I)\n2. Go to Console tab\n3. Look for errors\n\n**Common errors:**\n- `Failed to fetch` ‚Üí Backend not running\n- `CORS error` ‚Üí Not using a web server (opened file:// directly)\n- `Cannot read property` ‚Üí JavaScript error, check console\n\n### 4. Test backend endpoints manually\n\n```bash\n# Test health\ncurl http://localhost:5001/api/health\n\n# Test timestamps\ncurl http://localhost:5001/api/data/timestamps\n\n# Test specific time\ncurl \"http://localhost:5001/api/data/time/2025-09-17T18:00:00\"\n```\n\n### 5. Verify files exist\n\n```bash\ncd mini-project-3-team-tiger\nls assets/map.png          # Should exist\nls assets/ride_hailing.xlsx # Should exist\nls assets/plates/          # Should have 100 PNG files\n```\n\n### 6. Common Issues\n\n#### Map not showing\n- Check browser console for errors\n- Verify `map.png` exists in `assets/` folder\n- Check that backend is running\n\n#### License plates not showing\n- Check browser console for 404 errors on plate images\n- Verify plate images exist in `assets/plates/` folder\n- Check that plate numbers in data match filenames\n\n#### Animation not working\n- Check that timestamps loaded (see console)\n- Click \"Play\" button to start animation\n- Use time slider to navigate manually\n\n#### \"Unable to load guidance\" error\n- Backend not running\n- Wrong port (should be 5001, not 5000)\n- CORS issue (not using web server)\n\n## Step-by-Step Startup\n\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd /Users/felixisaac123/Desktop/MiniProject3/mini-project-3-team-tiger/backend\n   python3 app.py\n   ```\n   Keep this running!\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd /Users/felixisaac123/Desktop/MiniProject3/mini-project-3-team-tiger/frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Go to `http://localhost:8000`\n   - Open Developer Tools (F12)\n   - Check Console tab for any errors\n\n## Still Not Working?\n\nRun the test script:\n```bash\ncd mini-project-3-team-tiger\npython3 test_backend.py\n```\n\nThis will verify:\n- All dependencies are installed\n- Data file can be loaded\n- Backend code is correct\n\nIf test passes but frontend doesn't work, the issue is likely:\n- Backend not running\n- Frontend not using web server\n- Browser cache (try hard refresh: Cmd+Shift+R)\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:56:29.634Z","tree_hash":"6374eaa1ce85b1f993cc0718a4371ebcd5a889ee678aa0041c6000b447d33ec1","added":[],"modified":[{"path":"mini-project-3-team-tiger/TROUBLESHOOTING.md","size":3021,"mtime":1765320986392,"ext":"md","content":"# Troubleshooting Guide\n\n## Quick Checklist\n\n### 1. Is the backend running?\n\n**Check:**\n```bash\ncurl http://localhost:5001/api/health\n```\n\n**Should return:** `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n**If not working:**\n```bash\ncd mini-project-3-team-tiger/backend\npython3 app.py\n```\n\nYou should see:\n```\nStarting Backend API Server...\nData file: /Users/.../assets/ride_hailing.xlsx\n * Running on http://0.0.0.0:5001\n```\n\n### 2. Is the frontend using a web server?\n\n**IMPORTANT:** You cannot open `index.html` directly (file://). You MUST use a web server.\n\n**Start a web server:**\n```bash\ncd mini-project-3-team-tiger/frontend\npython3 -m http.server 8000\n```\n\nThen open: `http://localhost:8000`\n\n### 3. Check browser console\n\n1. Open browser Developer Tools (F12 or Cmd+Option+I)\n2. Go to Console tab\n3. Look for errors\n\n**Common errors:**\n- `Failed to fetch` ‚Üí Backend not running\n- `CORS error` ‚Üí Not using a web server (opened file:// directly)\n- `Cannot read property` ‚Üí JavaScript error, check console\n\n### 4. Test backend endpoints manually\n\n```bash\n# Test health\ncurl http://localhost:5001/api/health\n\n# Test timestamps\ncurl http://localhost:5001/api/data/timestamps\n\n# Test specific time\ncurl \"http://localhost:5001/api/data/time/2025-09-17T18:00:00\"\n```\n\n### 5. Verify files exist\n\n```bash\ncd mini-project-3-team-tiger\nls assets/map.png          # Should exist\nls assets/ride_hailing.xlsx # Should exist\nls assets/plates/          # Should have 100 PNG files\n```\n\n### 6. Common Issues\n\n#### Map not showing\n- Check browser console for errors\n- Verify `map.png` exists in `assets/` folder\n- Check that backend is running\n\n#### License plates not showing\n- Check browser console for 404 errors on plate images\n- Verify plate images exist in `assets/plates/` folder\n- Check that plate numbers in data match filenames\n\n#### Animation not working\n- Check that timestamps loaded (see console)\n- Click \"Play\" button to start animation\n- Use time slider to navigate manually\n\n#### \"Unable to load guidance\" error\n- Backend not running\n- Wrong port (should be 5001, not 5000)\n- CORS issue (not using web server)\n\n## Step-by-Step Startup\n\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd /Users/felixisaac123/Desktop/MiniProject3/mini-project-3-team-tiger/backend\n   python3 app.py\n   ```\n   Keep this running!\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd /Users/felixisaac123/Desktop/MiniProject3/mini-project-3-team-tiger/frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Go to `http://localhost:8000`\n   - Open Developer Tools (F12)\n   - Check Console tab for any errors\n\n## Still Not Working?\n\nRun the test script:\n```bash\ncd mini-project-3-team-tiger\npython3 test_backend.py\n```\n\nThis will verify:\n- All dependencies are installed\n- Data file can be loaded\n- Backend code is correct\n\nIf test passes but frontend doesn't work, the issue is likely:\n- Backend not running\n- Frontend not using web server\n- Browser cache (try hard refresh: Cmd+Shift+R)\n\n"},{"path":"mini-project-3-team-tiger/frontend/app.js","size":20694,"mtime":1765320986392,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: false, // Start paused, user can click play\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    mapImageEl.addEventListener('load', () => {\n        mapImage = mapImageEl;\n        mapOverlay.width = mapImageEl.offsetWidth;\n        mapOverlay.height = mapImageEl.offsetHeight;\n        mapContext = mapOverlay.getContext('2d');\n        updateMapVisualization();\n    });\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage) {\n            mapOverlay.width = mapImage.offsetWidth;\n            mapOverlay.height = mapImage.offsetHeight;\n            updateMapVisualization();\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error || !data.timestamps || data.timestamps.length === 0) {\n            console.error('No timestamps available:', data);\n            return;\n        }\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Update slider max value\n        const timeSlider = document.getElementById('time-slider');\n        if (timeSlider) {\n            timeSlider.max = data.timestamps.length - 1;\n        }\n        \n        // Load first frame\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n        \n        console.log(`Loaded ${data.timestamps.length} timestamps`);\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n        console.error('Make sure the backend server is running on http://localhost:5001');\n        document.getElementById('current-time-display').textContent = \n            'Error: Cannot connect to backend. Make sure server is running.';\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    if (!timeSlider || !timeSliderValue) {\n        console.error('Time slider elements not found');\n        return;\n    }\n    \n    timeSlider.addEventListener('input', (e) => {\n        const index = parseInt(e.target.value);\n        \n        if (animationState.timestamps.length > 0 && index >= 0 && index < animationState.timestamps.length) {\n            animationState.currentTimeIndex = index;\n            const timestamp = animationState.timestamps[index];\n            const timeObj = new Date(timestamp);\n            const timeString = `${timeObj.getHours().toString().padStart(2, '0')}:${timeObj.getMinutes().toString().padStart(2, '0')}`;\n            timeSliderValue.textContent = timeString;\n            updateMapVisualizationForTime(timestamp);\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        // Process all slots and draw them\n        const slotPromises = data.slots.map(async (slot) => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Load and draw license plate image if available\n                if (slot.plate_number) {\n                    const plateImg = await loadPlateImage(slot.plate_number);\n                    if (plateImg) {\n                        // Draw license plate image\n                        const plateSize = slotSize * 0.9;\n                        mapContext.drawImage(\n                            plateImg,\n                            x - plateSize / 2,\n                            y - plateSize / 2,\n                            plateSize,\n                            plateSize\n                        );\n                    }\n                }\n                \n                // Draw slot ID label (on top)\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        });\n        \n        // Wait for all slots to be drawn\n        await Promise.all(slotPromises);\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"},{"path":"mini-project-3-team-tiger/test_backend.py","size":1815,"mtime":1765320986392,"ext":"py","content":"#!/usr/bin/env python3\n\"\"\"Quick test script to verify backend setup\"\"\"\n\nimport sys\nimport os\n\n# Add backend to path\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), 'backend'))\n\ntry:\n    from app import app, get_data, DATA_FILE\n    import pandas as pd\n    \n    print(\"‚úì Backend imports successful\")\n    print(f\"‚úì Data file path: {DATA_FILE}\")\n    print(f\"‚úì Data file exists: {os.path.exists(DATA_FILE)}\")\n    \n    # Test data loading\n    df = get_data()\n    print(f\"‚úì Data loaded: {len(df)} rows\")\n    print(f\"‚úì Columns: {list(df.columns)}\")\n    \n    # Test unique timestamps\n    if not df.empty:\n        unique_times = sorted(df['current_time'].unique())\n        print(f\"‚úì Unique timestamps: {len(unique_times)}\")\n        print(f\"‚úì Time range: {unique_times[0]} to {unique_times[-1]}\")\n        \n        # Test filtering for 6 PM\n        df['time_only'] = df['current_time'].dt.time\n        from datetime import time\n        df_filtered = df[(df['time_only'] >= time(18, 0)) & (df['time_only'] <= time(18, 59))]\n        print(f\"‚úì 6 PM data: {len(df_filtered)} rows\")\n        \n        if len(df_filtered) > 0:\n            sample = df_filtered[df_filtered['x'].notna() & df_filtered['y'].notna()].head(1)\n            if len(sample) > 0:\n                print(f\"‚úì Sample slot: ID={sample.iloc[0]['slot_id']}, x={sample.iloc[0]['x']}, y={sample.iloc[0]['y']}\")\n                if pd.notna(sample.iloc[0].get('plate_number')):\n                    print(f\"‚úì Sample plate: {sample.iloc[0]['plate_number']}\")\n    \n    print(\"\\n‚úì All tests passed! Backend should work.\")\n    print(\"\\nTo start the backend server:\")\n    print(\"  cd backend\")\n    print(\"  python3 app.py\")\n    \nexcept Exception as e:\n    print(f\"‚úó Error: {e}\")\n    import traceback\n    traceback.print_exc()\n    sys.exit(1)\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:58:28.547Z","tree_hash":"7d742161273b6f37680479cc48341cff2338dedfb80c1272f9b0521bdf1ec2ba","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":21796,"mtime":1765321103569,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: false, // Start paused, user can click play\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    if (!mapImageEl || !mapOverlay) {\n        console.error('Map elements not found');\n        return;\n    }\n    \n    // Handle image load\n    const handleImageLoad = () => {\n        mapImage = mapImageEl;\n        // Set canvas size to match image\n        mapOverlay.width = mapImageEl.offsetWidth || mapImageEl.naturalWidth;\n        mapOverlay.height = mapImageEl.offsetHeight || mapImageEl.naturalHeight;\n        mapContext = mapOverlay.getContext('2d');\n        console.log('Map image loaded, canvas size:', mapOverlay.width, 'x', mapOverlay.height);\n        \n        // Load initial visualization once timestamps are loaded\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    };\n    \n    // Check if image is already loaded\n    if (mapImageEl.complete && mapImageEl.naturalHeight !== 0) {\n        handleImageLoad();\n    } else {\n        mapImageEl.addEventListener('load', handleImageLoad);\n        mapImageEl.addEventListener('error', () => {\n            console.error('Failed to load map image. Check path:', mapImageEl.src);\n        });\n    }\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage && mapOverlay) {\n            mapOverlay.width = mapImage.offsetWidth || mapImage.naturalWidth;\n            mapOverlay.height = mapImage.offsetHeight || mapImage.naturalHeight;\n            // Redraw current frame\n            if (animationState.timestamps.length > 0) {\n                updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n            }\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error || !data.timestamps || data.timestamps.length === 0) {\n            console.error('No timestamps available:', data);\n            return;\n        }\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Update slider max value\n        const timeSlider = document.getElementById('time-slider');\n        if (timeSlider) {\n            timeSlider.max = data.timestamps.length - 1;\n        }\n        \n        // Load first frame\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n        \n        console.log(`Loaded ${data.timestamps.length} timestamps`);\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n        console.error('Make sure the backend server is running on http://localhost:5001');\n        document.getElementById('current-time-display').textContent = \n            'Error: Cannot connect to backend. Make sure server is running.';\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    if (!timeSlider || !timeSliderValue) {\n        console.error('Time slider elements not found');\n        return;\n    }\n    \n    timeSlider.addEventListener('input', (e) => {\n        const index = parseInt(e.target.value);\n        \n        if (animationState.timestamps.length > 0 && index >= 0 && index < animationState.timestamps.length) {\n            animationState.currentTimeIndex = index;\n            const timestamp = animationState.timestamps[index];\n            const timeObj = new Date(timestamp);\n            const timeString = `${timeObj.getHours().toString().padStart(2, '0')}:${timeObj.getMinutes().toString().padStart(2, '0')}`;\n            timeSliderValue.textContent = timeString;\n            updateMapVisualizationForTime(timestamp);\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        document.getElementById('current-time-display').textContent = \n            `Time: ${timeObj.toLocaleTimeString()}`;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots with license plates\n        // Process all slots and draw them\n        const slotPromises = data.slots.map(async (slot) => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                \n                // Draw slot border\n                mapContext.strokeStyle = '#FF4444';\n                mapContext.lineWidth = 2;\n                mapContext.strokeRect(\n                    x - slotSize / 2,\n                    y - slotSize / 2,\n                    slotSize,\n                    slotSize\n                );\n                \n                // Load and draw license plate image if available\n                if (slot.plate_number) {\n                    const plateImg = await loadPlateImage(slot.plate_number);\n                    if (plateImg) {\n                        // Draw license plate image\n                        const plateSize = slotSize * 0.9;\n                        mapContext.drawImage(\n                            plateImg,\n                            x - plateSize / 2,\n                            y - plateSize / 2,\n                            plateSize,\n                            plateSize\n                        );\n                    }\n                }\n                \n                // Draw slot ID label (on top)\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.strokeStyle = '#000000';\n                mapContext.lineWidth = 3;\n                mapContext.font = 'bold 12px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.textBaseline = 'top';\n                mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n            }\n        });\n        \n        // Wait for all slots to be drawn\n        await Promise.all(slotPromises);\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:58:43.532Z","tree_hash":"35b9173ad60cd885b423c4d574650f5173264d8903d4459cbb8aa6beef0de36b","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":23306,"mtime":1765321121350,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: false, // Start paused, user can click play\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    if (!mapImageEl || !mapOverlay) {\n        console.error('Map elements not found');\n        return;\n    }\n    \n    // Handle image load\n    const handleImageLoad = () => {\n        mapImage = mapImageEl;\n        // Set canvas size to match image\n        mapOverlay.width = mapImageEl.offsetWidth || mapImageEl.naturalWidth;\n        mapOverlay.height = mapImageEl.offsetHeight || mapImageEl.naturalHeight;\n        mapContext = mapOverlay.getContext('2d');\n        console.log('Map image loaded, canvas size:', mapOverlay.width, 'x', mapOverlay.height);\n        \n        // Load initial visualization once timestamps are loaded\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    };\n    \n    // Check if image is already loaded\n    if (mapImageEl.complete && mapImageEl.naturalHeight !== 0) {\n        handleImageLoad();\n    } else {\n        mapImageEl.addEventListener('load', handleImageLoad);\n        mapImageEl.addEventListener('error', () => {\n            console.error('Failed to load map image. Check path:', mapImageEl.src);\n        });\n    }\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage && mapOverlay) {\n            mapOverlay.width = mapImage.offsetWidth || mapImage.naturalWidth;\n            mapOverlay.height = mapImage.offsetHeight || mapImage.naturalHeight;\n            // Redraw current frame\n            if (animationState.timestamps.length > 0) {\n                updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n            }\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error || !data.timestamps || data.timestamps.length === 0) {\n            console.error('No timestamps available:', data);\n            return;\n        }\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Update slider max value\n        const timeSlider = document.getElementById('time-slider');\n        if (timeSlider) {\n            timeSlider.max = data.timestamps.length - 1;\n        }\n        \n        // Load first frame\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n        \n        console.log(`Loaded ${data.timestamps.length} timestamps`);\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n        console.error('Make sure the backend server is running on http://localhost:5001');\n        document.getElementById('current-time-display').textContent = \n            'Error: Cannot connect to backend. Make sure server is running.';\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    if (!timeSlider || !timeSliderValue) {\n        console.error('Time slider elements not found');\n        return;\n    }\n    \n    timeSlider.addEventListener('input', (e) => {\n        const index = parseInt(e.target.value);\n        \n        if (animationState.timestamps.length > 0 && index >= 0 && index < animationState.timestamps.length) {\n            animationState.currentTimeIndex = index;\n            const timestamp = animationState.timestamps[index];\n            const timeObj = new Date(timestamp);\n            const timeString = `${timeObj.getHours().toString().padStart(2, '0')}:${timeObj.getMinutes().toString().padStart(2, '0')}`;\n            timeSliderValue.textContent = timeString;\n            updateMapVisualizationForTime(timestamp);\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) {\n        console.warn('Map context or image not ready yet');\n        return;\n    }\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('API error:', data.error);\n            return;\n        }\n        \n        if (!data.slots || data.slots.length === 0) {\n            console.log('No slots data for this timestamp');\n            // Still clear and show empty map\n        }\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        const timeDisplay = document.getElementById('current-time-display');\n        if (timeDisplay) {\n            timeDisplay.textContent = `Time: ${timeObj.toLocaleTimeString()}`;\n        }\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width || 1000;\n        const mapHeight = mapImage.naturalHeight || mapImage.height || 1000;\n        const canvasWidth = mapContext.canvas.width;\n        const canvasHeight = mapContext.canvas.height;\n        const scaleX = canvasWidth / mapWidth;\n        const scaleY = canvasHeight / mapHeight;\n        \n        console.log('Drawing map:', {\n            mapSize: `${mapWidth}x${mapHeight}`,\n            canvasSize: `${canvasWidth}x${canvasHeight}`,\n            scale: `${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`,\n            slots: data.slots ? data.slots.length : 0\n        });\n        \n        // Draw active slots with license plates\n        if (data.slots && data.slots.length > 0) {\n            // First pass: draw all slot borders\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                    \n                    // Draw slot border\n                    mapContext.strokeStyle = '#FF4444';\n                    mapContext.lineWidth = 2;\n                    mapContext.strokeRect(\n                        x - slotSize / 2,\n                        y - slotSize / 2,\n                        slotSize,\n                        slotSize\n                    );\n                }\n            }\n            \n            // Second pass: load and draw license plates (async)\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY);\n                    \n                    // Load and draw license plate image if available\n                    if (slot.plate_number) {\n                        const plateImg = await loadPlateImage(slot.plate_number);\n                        if (plateImg) {\n                            // Draw license plate image\n                            const plateSize = slotSize * 0.9;\n                            mapContext.drawImage(\n                                plateImg,\n                                x - plateSize / 2,\n                                y - plateSize / 2,\n                                plateSize,\n                                plateSize\n                            );\n                        }\n                    }\n                    \n                    // Draw slot ID label (on top)\n                    mapContext.fillStyle = '#FFFFFF';\n                    mapContext.strokeStyle = '#000000';\n                    mapContext.lineWidth = 3;\n                    mapContext.font = 'bold 12px Arial';\n                    mapContext.textAlign = 'center';\n                    mapContext.textBaseline = 'top';\n                    mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                    mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n                }\n            }\n        }\n        \n        console.log('Map visualization updated');\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n        console.error('Error details:', error.message);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:58:48.534Z","tree_hash":"ec4d34055d9033b3b0d36b9acb112a11f89c5a57bcbed0ec2c89a127d158260d","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":23568,"mtime":1765321124324,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: false, // Start paused, user can click play\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    if (!mapImageEl || !mapOverlay) {\n        console.error('Map elements not found');\n        return;\n    }\n    \n    // Handle image load\n    const handleImageLoad = () => {\n        mapImage = mapImageEl;\n        // Set canvas size to match image\n        mapOverlay.width = mapImageEl.offsetWidth || mapImageEl.naturalWidth;\n        mapOverlay.height = mapImageEl.offsetHeight || mapImageEl.naturalHeight;\n        mapContext = mapOverlay.getContext('2d');\n        console.log('Map image loaded, canvas size:', mapOverlay.width, 'x', mapOverlay.height);\n        \n        // Load initial visualization once timestamps are loaded\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    };\n    \n    // Check if image is already loaded\n    if (mapImageEl.complete && mapImageEl.naturalHeight !== 0) {\n        handleImageLoad();\n    } else {\n        mapImageEl.addEventListener('load', handleImageLoad);\n        mapImageEl.addEventListener('error', () => {\n            console.error('Failed to load map image. Check path:', mapImageEl.src);\n        });\n    }\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage && mapOverlay) {\n            mapOverlay.width = mapImage.offsetWidth || mapImage.naturalWidth;\n            mapOverlay.height = mapImage.offsetHeight || mapImage.naturalHeight;\n            // Redraw current frame\n            if (animationState.timestamps.length > 0) {\n                updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n            }\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error || !data.timestamps || data.timestamps.length === 0) {\n            console.error('No timestamps available:', data);\n            return;\n        }\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Update slider max value\n        const timeSlider = document.getElementById('time-slider');\n        if (timeSlider) {\n            timeSlider.max = data.timestamps.length - 1;\n        }\n        \n        // Load first frame (wait a bit for map to be ready)\n        if (animationState.timestamps.length > 0) {\n            setTimeout(() => {\n                if (mapContext && mapImage) {\n                    updateMapVisualizationForTime(animationState.timestamps[0]);\n                } else {\n                    console.warn('Map not ready, will retry when image loads');\n                }\n            }, 100);\n        }\n        \n        console.log(`Loaded ${data.timestamps.length} timestamps`);\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n        console.error('Make sure the backend server is running on http://localhost:5001');\n        document.getElementById('current-time-display').textContent = \n            'Error: Cannot connect to backend. Make sure server is running.';\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    if (!timeSlider || !timeSliderValue) {\n        console.error('Time slider elements not found');\n        return;\n    }\n    \n    timeSlider.addEventListener('input', (e) => {\n        const index = parseInt(e.target.value);\n        \n        if (animationState.timestamps.length > 0 && index >= 0 && index < animationState.timestamps.length) {\n            animationState.currentTimeIndex = index;\n            const timestamp = animationState.timestamps[index];\n            const timeObj = new Date(timestamp);\n            const timeString = `${timeObj.getHours().toString().padStart(2, '0')}:${timeObj.getMinutes().toString().padStart(2, '0')}`;\n            timeSliderValue.textContent = timeString;\n            updateMapVisualizationForTime(timestamp);\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) {\n        console.warn('Map context or image not ready yet');\n        return;\n    }\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('API error:', data.error);\n            return;\n        }\n        \n        if (!data.slots || data.slots.length === 0) {\n            console.log('No slots data for this timestamp');\n            // Still clear and show empty map\n        }\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        const timeDisplay = document.getElementById('current-time-display');\n        if (timeDisplay) {\n            timeDisplay.textContent = `Time: ${timeObj.toLocaleTimeString()}`;\n        }\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width || 1000;\n        const mapHeight = mapImage.naturalHeight || mapImage.height || 1000;\n        const canvasWidth = mapContext.canvas.width;\n        const canvasHeight = mapContext.canvas.height;\n        const scaleX = canvasWidth / mapWidth;\n        const scaleY = canvasHeight / mapHeight;\n        \n        console.log('Drawing map:', {\n            mapSize: `${mapWidth}x${mapHeight}`,\n            canvasSize: `${canvasWidth}x${canvasHeight}`,\n            scale: `${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`,\n            slots: data.slots ? data.slots.length : 0\n        });\n        \n        // Draw active slots with license plates\n        if (data.slots && data.slots.length > 0) {\n            // First pass: draw all slot borders\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                    \n                    // Draw slot border\n                    mapContext.strokeStyle = '#FF4444';\n                    mapContext.lineWidth = 2;\n                    mapContext.strokeRect(\n                        x - slotSize / 2,\n                        y - slotSize / 2,\n                        slotSize,\n                        slotSize\n                    );\n                }\n            }\n            \n            // Second pass: load and draw license plates (async)\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY);\n                    \n                    // Load and draw license plate image if available\n                    if (slot.plate_number) {\n                        const plateImg = await loadPlateImage(slot.plate_number);\n                        if (plateImg) {\n                            // Draw license plate image\n                            const plateSize = slotSize * 0.9;\n                            mapContext.drawImage(\n                                plateImg,\n                                x - plateSize / 2,\n                                y - plateSize / 2,\n                                plateSize,\n                                plateSize\n                            );\n                        }\n                    }\n                    \n                    // Draw slot ID label (on top)\n                    mapContext.fillStyle = '#FFFFFF';\n                    mapContext.strokeStyle = '#000000';\n                    mapContext.lineWidth = 3;\n                    mapContext.font = 'bold 12px Arial';\n                    mapContext.textAlign = 'center';\n                    mapContext.textBaseline = 'top';\n                    mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                    mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n                }\n            }\n        }\n        \n        console.log('Map visualization updated');\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n        console.error('Error details:', error.message);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T22:59:08.541Z","tree_hash":"439d3566176753a9d7ef90decb6ce7ea7ebbe56bfae694dcafeb7f5b0f896d8c","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":23568,"mtime":1765321145917,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: false, // Start paused, user can click play\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    if (!mapImageEl || !mapOverlay) {\n        console.error('Map elements not found');\n        return;\n    }\n    \n    // Handle image load\n    const handleImageLoad = () => {\n        mapImage = mapImageEl;\n        // Set canvas size to match image\n        mapOverlay.width = mapImageEl.offsetWidth || mapImageEl.naturalWidth;\n        mapOverlay.height = mapImageEl.offsetHeight || mapImageEl.naturalHeight;\n        mapContext = mapOverlay.getContext('2d');\n        console.log('Map image loaded, canvas size:', mapOverlay.width, 'x', mapOverlay.height);\n        \n        // Load initial visualization once timestamps are loaded\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    };\n    \n    // Check if image is already loaded\n    if (mapImageEl.complete && mapImageEl.naturalHeight !== 0) {\n        handleImageLoad();\n    } else {\n        mapImageEl.addEventListener('load', handleImageLoad);\n        mapImageEl.addEventListener('error', () => {\n            console.error('Failed to load map image. Check path:', mapImageEl.src);\n        });\n    }\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage && mapOverlay) {\n            mapOverlay.width = mapImage.offsetWidth || mapImage.naturalWidth;\n            mapOverlay.height = mapImage.offsetHeight || mapImage.naturalHeight;\n            // Redraw current frame\n            if (animationState.timestamps.length > 0) {\n                updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n            }\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error || !data.timestamps || data.timestamps.length === 0) {\n            console.error('No timestamps available:', data);\n            return;\n        }\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Update slider max value\n        const timeSlider = document.getElementById('time-slider');\n        if (timeSlider) {\n            timeSlider.max = data.timestamps.length - 1;\n        }\n        \n        // Load first frame (wait a bit for map to be ready)\n        if (animationState.timestamps.length > 0) {\n            setTimeout(() => {\n                if (mapContext && mapImage) {\n                    updateMapVisualizationForTime(animationState.timestamps[0]);\n                } else {\n                    console.warn('Map not ready, will retry when image loads');\n                }\n            }, 100);\n        }\n        \n        console.log(`Loaded ${data.timestamps.length} timestamps`);\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n        console.error('Make sure the backend server is running on http://localhost:5001');\n        document.getElementById('current-time-display').textContent = \n            'Error: Cannot connect to backend. Make sure server is running.';\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    if (!timeSlider || !timeSliderValue) {\n        console.error('Time slider elements not found');\n        return;\n    }\n    \n    timeSlider.addEventListener('input', (e) => {\n        const index = parseInt(e.target.value);\n        \n        if (animationState.timestamps.length > 0 && index >= 0 && index < animationState.timestamps.length) {\n            animationState.currentTimeIndex = index;\n            const timestamp = animationState.timestamps[index];\n            const timeObj = new Date(timestamp);\n            const timeString = `${timeObj.getHours().toString().padStart(2, '0')}:${timeObj.getMinutes().toString().padStart(2, '0')}`;\n            timeSliderValue.textContent = timeString;\n            updateMapVisualizationForTime(timestamp);\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) {\n        console.warn('Map context or image not ready yet');\n        return;\n    }\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('API error:', data.error);\n            return;\n        }\n        \n        if (!data.slots || data.slots.length === 0) {\n            console.log('No slots data for this timestamp');\n            // Still clear and show empty map\n        }\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        const timeDisplay = document.getElementById('current-time-display');\n        if (timeDisplay) {\n            timeDisplay.textContent = `Time: ${timeObj.toLocaleTimeString()}`;\n        }\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width || 1000;\n        const mapHeight = mapImage.naturalHeight || mapImage.height || 1000;\n        const canvasWidth = mapContext.canvas.width;\n        const canvasHeight = mapContext.canvas.height;\n        const scaleX = canvasWidth / mapWidth;\n        const scaleY = canvasHeight / mapHeight;\n        \n        console.log('Drawing map:', {\n            mapSize: `${mapWidth}x${mapHeight}`,\n            canvasSize: `${canvasWidth}x${canvasHeight}`,\n            scale: `${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`,\n            slots: data.slots ? data.slots.length : 0\n        });\n        \n        // Draw active slots with license plates\n        if (data.slots && data.slots.length > 0) {\n            // First pass: draw all slot borders\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                    \n                    // Draw slot border\n                    mapContext.strokeStyle = '#FF4444';\n                    mapContext.lineWidth = 2;\n                    mapContext.strokeRect(\n                        x - slotSize / 2,\n                        y - slotSize / 2,\n                        slotSize,\n                        slotSize\n                    );\n                }\n            }\n            \n            // Second pass: load and draw license plates (async)\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY);\n                    \n                    // Load and draw license plate image if available\n                    if (slot.plate_number) {\n                        const plateImg = await loadPlateImage(slot.plate_number);\n                        if (plateImg) {\n                            // Draw license plate image\n                            const plateSize = slotSize * 0.9;\n                            mapContext.drawImage(\n                                plateImg,\n                                x - plateSize / 2,\n                                y - plateSize / 2,\n                                plateSize,\n                                plateSize\n                            );\n                        }\n                    }\n                    \n                    // Draw slot ID label (on top)\n                    mapContext.fillStyle = '#FFFFFF';\n                    mapContext.strokeStyle = '#000000';\n                    mapContext.lineWidth = 3;\n                    mapContext.font = 'bold 12px Arial';\n                    mapContext.textAlign = 'center';\n                    mapContext.textBaseline = 'top';\n                    mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                    mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n                }\n            }\n        }\n        \n        console.log('Map visualization updated');\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n        console.error('Error details:', error.message);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T23:02:58.722Z","tree_hash":"18bad7eeecf30b5cad2c7fa27322bfa636e972f9a1052aac50faed33a3e59409","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/index.html","size":6788,"mtime":1765321378081,"ext":"html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Sky Harbor Airport - Ride-Hailing Dashboard</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <!-- Header -->\n        <header class=\"header\">\n            <h1>‚úàÔ∏è Sky Harbor Airport</h1>\n            <h2>Ride-Hailing Display Dashboard</h2>\n        </header>\n\n        <!-- Terminal Selection Tabs -->\n        <div class=\"terminal-tabs\">\n            <button class=\"tab-button active\" data-terminal=\"Terminal 3\">Terminal 3</button>\n            <button class=\"tab-button\" data-terminal=\"Terminal 4\">Terminal 4</button>\n        </div>\n\n        <!-- Terminal Guidance Banner -->\n        <div id=\"guidance-banner\" class=\"guidance-banner\">\n            <div class=\"banner-content\">\n                <span class=\"banner-icon\">üìç</span>\n                <span id=\"guidance-message\" class=\"guidance-message\">Loading guidance...</span>\n            </div>\n            <div class=\"banner-details\">\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Zone:</span>\n                    <span id=\"zone-name\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Walking Time:</span>\n                    <span id=\"walking-time\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Estimated Wait:</span>\n                    <span id=\"estimated-wait\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Available Slots:</span>\n                    <span id=\"available-slots\" class=\"detail-value\">-</span>\n                </div>\n            </div>\n        </div>\n\n        <!-- Price & Wait Forecast Section -->\n        <div class=\"forecast-section\">\n            <h3>Price & Wait Forecast (15-30 min horizon)</h3>\n            \n            <div class=\"forecast-cards\">\n                <!-- Price Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">üí∞</span>\n                        <span class=\"card-title\">Price Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"price-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"price-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Wait Time Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">‚è±Ô∏è</span>\n                        <span class=\"card-title\">Wait Time Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"wait-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"wait-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- Map Visualization -->\n        <div class=\"map-section\">\n            <div class=\"map-header\">\n                <h3>Live Map View - Parking Lot Status (6:00 PM - 6:59 PM)</h3>\n                <div class=\"animation-controls\">\n                    <button id=\"play-pause-btn\" class=\"control-btn\">‚è∏Ô∏è Pause</button>\n                    <button id=\"speed-down-btn\" class=\"control-btn\">‚è™ Slow</button>\n                    <span id=\"speed-indicator\" class=\"speed-indicator\">1x</span>\n                    <button id=\"speed-up-btn\" class=\"control-btn\">‚è© Fast</button>\n                    <button id=\"reset-btn\" class=\"control-btn\">üîÑ Reset</button>\n                </div>\n            </div>\n            <div class=\"time-display\">\n                <span id=\"current-time-display\">Time: --:--:--</span>\n            </div>\n            <div class=\"time-slider-container\">\n                <label for=\"time-slider\">Select Time:</label>\n                <input type=\"range\" id=\"time-slider\" min=\"0\" max=\"59\" value=\"0\" class=\"time-slider\">\n                <span id=\"time-slider-value\">18:00</span>\n            </div>\n            <div class=\"map-container\">\n                <img id=\"map-image\" src=\"../assets/map.png\" alt=\"Airport Map\" class=\"map-image\" \n                     onerror=\"console.error('Failed to load map image. Path:', this.src); this.style.display='none';\">\n                <canvas id=\"map-overlay\" class=\"map-overlay\"></canvas>\n            </div>\n        </div>\n\n        <!-- Status Footer -->\n        <footer class=\"status-footer\">\n            <div class=\"status-item\">\n                <span class=\"status-label\">Last Updated:</span>\n                <span id=\"last-updated\" class=\"status-value\">-</span>\n            </div>\n            <div class=\"status-item\">\n                <span class=\"status-label\">API Status:</span>\n                <span id=\"api-status\" class=\"status-value\">Checking...</span>\n            </div>\n        </footer>\n    </div>\n\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T23:03:03.721Z","tree_hash":"cc0e70a1e682c01a4faab165beb7972dce3b4cefcf75c94a789e9dd2e0b38f69","added":[{"path":"mini-project-3-team-tiger/frontend/start_server.sh","size":318,"mtime":1765321382495,"ext":"sh","content":"#!/bin/bash\n# Start frontend web server\n# This script ensures the server runs from the correct directory\n\ncd \"$(dirname \"$0\")\"\necho \"Starting frontend web server...\"\necho \"Serving from: $(pwd)\"\necho \"\"\necho \"Open your browser to: http://localhost:8000\"\necho \"Press Ctrl+C to stop\"\necho \"\"\npython3 -m http.server 8000\n\n"}],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":25381,"mtime":1765321380979,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: false, // Start paused, user can click play\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    if (!mapImageEl || !mapOverlay) {\n        console.error('Map elements not found');\n        return;\n    }\n    \n    console.log('Setting up map canvas. Image src:', mapImageEl.src);\n    \n    // Handle image load\n    const handleImageLoad = () => {\n        mapImage = mapImageEl;\n        // Set canvas size to match image\n        const imgWidth = mapImageEl.naturalWidth || mapImageEl.offsetWidth || 1000;\n        const imgHeight = mapImageEl.naturalHeight || mapImageEl.offsetHeight || 1000;\n        \n        mapOverlay.width = imgWidth;\n        mapOverlay.height = imgHeight;\n        mapContext = mapOverlay.getContext('2d');\n        \n        console.log('Map image loaded successfully!');\n        console.log('Image dimensions:', imgWidth, 'x', imgHeight);\n        console.log('Canvas dimensions:', mapOverlay.width, 'x', mapOverlay.height);\n        \n        // Load initial visualization once timestamps are loaded\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    };\n    \n    // Handle image load error\n    const handleImageError = () => {\n        console.error('Failed to load map image!');\n        console.error('Attempted path:', mapImageEl.src);\n        console.error('Current URL:', window.location.href);\n        console.error('Try checking:');\n        console.error('  1. Is the server running from the frontend/ directory?');\n        console.error('  2. Does ../assets/map.png exist relative to frontend/?');\n        console.error('  3. Check browser Network tab for 404 errors');\n        \n        // Show error message on page\n        const mapContainer = document.querySelector('.map-container');\n        if (mapContainer) {\n            const errorDiv = document.createElement('div');\n            errorDiv.style.cssText = 'padding: 20px; background: #ffebee; color: #c62828; border-radius: 8px; margin: 10px;';\n            errorDiv.innerHTML = `\n                <strong>Error loading map image</strong><br>\n                Path: ${mapImageEl.src}<br>\n                <small>Check browser console (F12) for details. Make sure you're running a web server from the frontend/ directory.</small>\n            `;\n            mapContainer.appendChild(errorDiv);\n        }\n    };\n    \n    // Check if image is already loaded\n    if (mapImageEl.complete && mapImageEl.naturalHeight !== 0) {\n        console.log('Image already loaded');\n        handleImageLoad();\n    } else {\n        mapImageEl.addEventListener('load', handleImageLoad);\n        mapImageEl.addEventListener('error', handleImageError);\n        \n        // Force reload if src is set\n        if (mapImageEl.src && !mapImageEl.src.includes('data:')) {\n            console.log('Waiting for image to load...');\n        }\n    }\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage && mapOverlay) {\n            const imgWidth = mapImage.naturalWidth || mapImage.offsetWidth || 1000;\n            const imgHeight = mapImage.naturalHeight || mapImage.offsetHeight || 1000;\n            mapOverlay.width = imgWidth;\n            mapOverlay.height = imgHeight;\n            // Redraw current frame\n            if (animationState.timestamps.length > 0 && animationState.currentTimeIndex < animationState.timestamps.length) {\n                updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n            }\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error || !data.timestamps || data.timestamps.length === 0) {\n            console.error('No timestamps available:', data);\n            return;\n        }\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Update slider max value\n        const timeSlider = document.getElementById('time-slider');\n        if (timeSlider) {\n            timeSlider.max = data.timestamps.length - 1;\n        }\n        \n        // Load first frame (wait a bit for map to be ready)\n        if (animationState.timestamps.length > 0) {\n            setTimeout(() => {\n                if (mapContext && mapImage) {\n                    updateMapVisualizationForTime(animationState.timestamps[0]);\n                } else {\n                    console.warn('Map not ready, will retry when image loads');\n                }\n            }, 100);\n        }\n        \n        console.log(`Loaded ${data.timestamps.length} timestamps`);\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n        console.error('Make sure the backend server is running on http://localhost:5001');\n        document.getElementById('current-time-display').textContent = \n            'Error: Cannot connect to backend. Make sure server is running.';\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    if (!timeSlider || !timeSliderValue) {\n        console.error('Time slider elements not found');\n        return;\n    }\n    \n    timeSlider.addEventListener('input', (e) => {\n        const index = parseInt(e.target.value);\n        \n        if (animationState.timestamps.length > 0 && index >= 0 && index < animationState.timestamps.length) {\n            animationState.currentTimeIndex = index;\n            const timestamp = animationState.timestamps[index];\n            const timeObj = new Date(timestamp);\n            const timeString = `${timeObj.getHours().toString().padStart(2, '0')}:${timeObj.getMinutes().toString().padStart(2, '0')}`;\n            timeSliderValue.textContent = timeString;\n            updateMapVisualizationForTime(timestamp);\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `../assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) {\n        console.warn('Map context or image not ready yet');\n        return;\n    }\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('API error:', data.error);\n            return;\n        }\n        \n        if (!data.slots || data.slots.length === 0) {\n            console.log('No slots data for this timestamp');\n            // Still clear and show empty map\n        }\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        const timeDisplay = document.getElementById('current-time-display');\n        if (timeDisplay) {\n            timeDisplay.textContent = `Time: ${timeObj.toLocaleTimeString()}`;\n        }\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width || 1000;\n        const mapHeight = mapImage.naturalHeight || mapImage.height || 1000;\n        const canvasWidth = mapContext.canvas.width;\n        const canvasHeight = mapContext.canvas.height;\n        const scaleX = canvasWidth / mapWidth;\n        const scaleY = canvasHeight / mapHeight;\n        \n        console.log('Drawing map:', {\n            mapSize: `${mapWidth}x${mapHeight}`,\n            canvasSize: `${canvasWidth}x${canvasHeight}`,\n            scale: `${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`,\n            slots: data.slots ? data.slots.length : 0\n        });\n        \n        // Draw active slots with license plates\n        if (data.slots && data.slots.length > 0) {\n            // First pass: draw all slot borders\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                    \n                    // Draw slot border\n                    mapContext.strokeStyle = '#FF4444';\n                    mapContext.lineWidth = 2;\n                    mapContext.strokeRect(\n                        x - slotSize / 2,\n                        y - slotSize / 2,\n                        slotSize,\n                        slotSize\n                    );\n                }\n            }\n            \n            // Second pass: load and draw license plates (async)\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY);\n                    \n                    // Load and draw license plate image if available\n                    if (slot.plate_number) {\n                        const plateImg = await loadPlateImage(slot.plate_number);\n                        if (plateImg) {\n                            // Draw license plate image\n                            const plateSize = slotSize * 0.9;\n                            mapContext.drawImage(\n                                plateImg,\n                                x - plateSize / 2,\n                                y - plateSize / 2,\n                                plateSize,\n                                plateSize\n                            );\n                        }\n                    }\n                    \n                    // Draw slot ID label (on top)\n                    mapContext.fillStyle = '#FFFFFF';\n                    mapContext.strokeStyle = '#000000';\n                    mapContext.lineWidth = 3;\n                    mapContext.font = 'bold 12px Arial';\n                    mapContext.textAlign = 'center';\n                    mapContext.textBaseline = 'top';\n                    mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                    mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n                }\n            }\n        }\n        \n        console.log('Map visualization updated');\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n        console.error('Error details:', error.message);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T23:03:18.717Z","tree_hash":"10f7135d799e3c04b4eafe7f82da98933598ac35b7c30a8f63dd9b315df4537d","added":[{"path":"mini-project-3-team-tiger/start_frontend.sh","size":362,"mtime":1765321393775,"ext":"sh","content":"#!/bin/bash\n# Start frontend web server from project root\n# This allows access to both frontend/ and assets/ directories\n\ncd \"$(dirname \"$0\")\"\necho \"Starting frontend web server from project root...\"\necho \"Serving from: $(pwd)\"\necho \"\"\necho \"Open your browser to: http://localhost:8000/frontend/\"\necho \"Press Ctrl+C to stop\"\necho \"\"\npython3 -m http.server 8000\n\n"}],"modified":[{"path":"mini-project-3-team-tiger/frontend/index.html","size":6786,"mtime":1765321396156,"ext":"html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Sky Harbor Airport - Ride-Hailing Dashboard</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <!-- Header -->\n        <header class=\"header\">\n            <h1>‚úàÔ∏è Sky Harbor Airport</h1>\n            <h2>Ride-Hailing Display Dashboard</h2>\n        </header>\n\n        <!-- Terminal Selection Tabs -->\n        <div class=\"terminal-tabs\">\n            <button class=\"tab-button active\" data-terminal=\"Terminal 3\">Terminal 3</button>\n            <button class=\"tab-button\" data-terminal=\"Terminal 4\">Terminal 4</button>\n        </div>\n\n        <!-- Terminal Guidance Banner -->\n        <div id=\"guidance-banner\" class=\"guidance-banner\">\n            <div class=\"banner-content\">\n                <span class=\"banner-icon\">üìç</span>\n                <span id=\"guidance-message\" class=\"guidance-message\">Loading guidance...</span>\n            </div>\n            <div class=\"banner-details\">\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Zone:</span>\n                    <span id=\"zone-name\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Walking Time:</span>\n                    <span id=\"walking-time\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Estimated Wait:</span>\n                    <span id=\"estimated-wait\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Available Slots:</span>\n                    <span id=\"available-slots\" class=\"detail-value\">-</span>\n                </div>\n            </div>\n        </div>\n\n        <!-- Price & Wait Forecast Section -->\n        <div class=\"forecast-section\">\n            <h3>Price & Wait Forecast (15-30 min horizon)</h3>\n            \n            <div class=\"forecast-cards\">\n                <!-- Price Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">üí∞</span>\n                        <span class=\"card-title\">Price Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"price-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"price-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Wait Time Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">‚è±Ô∏è</span>\n                        <span class=\"card-title\">Wait Time Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"wait-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"wait-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- Map Visualization -->\n        <div class=\"map-section\">\n            <div class=\"map-header\">\n                <h3>Live Map View - Parking Lot Status (6:00 PM - 6:59 PM)</h3>\n                <div class=\"animation-controls\">\n                    <button id=\"play-pause-btn\" class=\"control-btn\">‚è∏Ô∏è Pause</button>\n                    <button id=\"speed-down-btn\" class=\"control-btn\">‚è™ Slow</button>\n                    <span id=\"speed-indicator\" class=\"speed-indicator\">1x</span>\n                    <button id=\"speed-up-btn\" class=\"control-btn\">‚è© Fast</button>\n                    <button id=\"reset-btn\" class=\"control-btn\">üîÑ Reset</button>\n                </div>\n            </div>\n            <div class=\"time-display\">\n                <span id=\"current-time-display\">Time: --:--:--</span>\n            </div>\n            <div class=\"time-slider-container\">\n                <label for=\"time-slider\">Select Time:</label>\n                <input type=\"range\" id=\"time-slider\" min=\"0\" max=\"59\" value=\"0\" class=\"time-slider\">\n                <span id=\"time-slider-value\">18:00</span>\n            </div>\n            <div class=\"map-container\">\n                <img id=\"map-image\" src=\"/assets/map.png\" alt=\"Airport Map\" class=\"map-image\" \n                     onerror=\"console.error('Failed to load map image. Path:', this.src); this.style.display='none';\">\n                <canvas id=\"map-overlay\" class=\"map-overlay\"></canvas>\n            </div>\n        </div>\n\n        <!-- Status Footer -->\n        <footer class=\"status-footer\">\n            <div class=\"status-item\">\n                <span class=\"status-label\">Last Updated:</span>\n                <span id=\"last-updated\" class=\"status-value\">-</span>\n            </div>\n            <div class=\"status-item\">\n                <span class=\"status-label\">API Status:</span>\n                <span id=\"api-status\" class=\"status-value\">Checking...</span>\n            </div>\n        </footer>\n    </div>\n\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n"},{"path":"mini-project-3-team-tiger/frontend/app.js","size":25379,"mtime":1765321397282,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: false, // Start paused, user can click play\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    if (!mapImageEl || !mapOverlay) {\n        console.error('Map elements not found');\n        return;\n    }\n    \n    console.log('Setting up map canvas. Image src:', mapImageEl.src);\n    \n    // Handle image load\n    const handleImageLoad = () => {\n        mapImage = mapImageEl;\n        // Set canvas size to match image\n        const imgWidth = mapImageEl.naturalWidth || mapImageEl.offsetWidth || 1000;\n        const imgHeight = mapImageEl.naturalHeight || mapImageEl.offsetHeight || 1000;\n        \n        mapOverlay.width = imgWidth;\n        mapOverlay.height = imgHeight;\n        mapContext = mapOverlay.getContext('2d');\n        \n        console.log('Map image loaded successfully!');\n        console.log('Image dimensions:', imgWidth, 'x', imgHeight);\n        console.log('Canvas dimensions:', mapOverlay.width, 'x', mapOverlay.height);\n        \n        // Load initial visualization once timestamps are loaded\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    };\n    \n    // Handle image load error\n    const handleImageError = () => {\n        console.error('Failed to load map image!');\n        console.error('Attempted path:', mapImageEl.src);\n        console.error('Current URL:', window.location.href);\n        console.error('Try checking:');\n        console.error('  1. Is the server running from the frontend/ directory?');\n        console.error('  2. Does ../assets/map.png exist relative to frontend/?');\n        console.error('  3. Check browser Network tab for 404 errors');\n        \n        // Show error message on page\n        const mapContainer = document.querySelector('.map-container');\n        if (mapContainer) {\n            const errorDiv = document.createElement('div');\n            errorDiv.style.cssText = 'padding: 20px; background: #ffebee; color: #c62828; border-radius: 8px; margin: 10px;';\n            errorDiv.innerHTML = `\n                <strong>Error loading map image</strong><br>\n                Path: ${mapImageEl.src}<br>\n                <small>Check browser console (F12) for details. Make sure you're running a web server from the frontend/ directory.</small>\n            `;\n            mapContainer.appendChild(errorDiv);\n        }\n    };\n    \n    // Check if image is already loaded\n    if (mapImageEl.complete && mapImageEl.naturalHeight !== 0) {\n        console.log('Image already loaded');\n        handleImageLoad();\n    } else {\n        mapImageEl.addEventListener('load', handleImageLoad);\n        mapImageEl.addEventListener('error', handleImageError);\n        \n        // Force reload if src is set\n        if (mapImageEl.src && !mapImageEl.src.includes('data:')) {\n            console.log('Waiting for image to load...');\n        }\n    }\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage && mapOverlay) {\n            const imgWidth = mapImage.naturalWidth || mapImage.offsetWidth || 1000;\n            const imgHeight = mapImage.naturalHeight || mapImage.offsetHeight || 1000;\n            mapOverlay.width = imgWidth;\n            mapOverlay.height = imgHeight;\n            // Redraw current frame\n            if (animationState.timestamps.length > 0 && animationState.currentTimeIndex < animationState.timestamps.length) {\n                updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n            }\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error || !data.timestamps || data.timestamps.length === 0) {\n            console.error('No timestamps available:', data);\n            return;\n        }\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Update slider max value\n        const timeSlider = document.getElementById('time-slider');\n        if (timeSlider) {\n            timeSlider.max = data.timestamps.length - 1;\n        }\n        \n        // Load first frame (wait a bit for map to be ready)\n        if (animationState.timestamps.length > 0) {\n            setTimeout(() => {\n                if (mapContext && mapImage) {\n                    updateMapVisualizationForTime(animationState.timestamps[0]);\n                } else {\n                    console.warn('Map not ready, will retry when image loads');\n                }\n            }, 100);\n        }\n        \n        console.log(`Loaded ${data.timestamps.length} timestamps`);\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n        console.error('Make sure the backend server is running on http://localhost:5001');\n        document.getElementById('current-time-display').textContent = \n            'Error: Cannot connect to backend. Make sure server is running.';\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    if (!timeSlider || !timeSliderValue) {\n        console.error('Time slider elements not found');\n        return;\n    }\n    \n    timeSlider.addEventListener('input', (e) => {\n        const index = parseInt(e.target.value);\n        \n        if (animationState.timestamps.length > 0 && index >= 0 && index < animationState.timestamps.length) {\n            animationState.currentTimeIndex = index;\n            const timestamp = animationState.timestamps[index];\n            const timeObj = new Date(timestamp);\n            const timeString = `${timeObj.getHours().toString().padStart(2, '0')}:${timeObj.getMinutes().toString().padStart(2, '0')}`;\n            timeSliderValue.textContent = timeString;\n            updateMapVisualizationForTime(timestamp);\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `/assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) {\n        console.warn('Map context or image not ready yet');\n        return;\n    }\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('API error:', data.error);\n            return;\n        }\n        \n        if (!data.slots || data.slots.length === 0) {\n            console.log('No slots data for this timestamp');\n            // Still clear and show empty map\n        }\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        const timeDisplay = document.getElementById('current-time-display');\n        if (timeDisplay) {\n            timeDisplay.textContent = `Time: ${timeObj.toLocaleTimeString()}`;\n        }\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width || 1000;\n        const mapHeight = mapImage.naturalHeight || mapImage.height || 1000;\n        const canvasWidth = mapContext.canvas.width;\n        const canvasHeight = mapContext.canvas.height;\n        const scaleX = canvasWidth / mapWidth;\n        const scaleY = canvasHeight / mapHeight;\n        \n        console.log('Drawing map:', {\n            mapSize: `${mapWidth}x${mapHeight}`,\n            canvasSize: `${canvasWidth}x${canvasHeight}`,\n            scale: `${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`,\n            slots: data.slots ? data.slots.length : 0\n        });\n        \n        // Draw active slots with license plates\n        if (data.slots && data.slots.length > 0) {\n            // First pass: draw all slot borders\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                    \n                    // Draw slot border\n                    mapContext.strokeStyle = '#FF4444';\n                    mapContext.lineWidth = 2;\n                    mapContext.strokeRect(\n                        x - slotSize / 2,\n                        y - slotSize / 2,\n                        slotSize,\n                        slotSize\n                    );\n                }\n            }\n            \n            // Second pass: load and draw license plates (async)\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY);\n                    \n                    // Load and draw license plate image if available\n                    if (slot.plate_number) {\n                        const plateImg = await loadPlateImage(slot.plate_number);\n                        if (plateImg) {\n                            // Draw license plate image\n                            const plateSize = slotSize * 0.9;\n                            mapContext.drawImage(\n                                plateImg,\n                                x - plateSize / 2,\n                                y - plateSize / 2,\n                                plateSize,\n                                plateSize\n                            );\n                        }\n                    }\n                    \n                    // Draw slot ID label (on top)\n                    mapContext.fillStyle = '#FFFFFF';\n                    mapContext.strokeStyle = '#000000';\n                    mapContext.lineWidth = 3;\n                    mapContext.font = 'bold 12px Arial';\n                    mapContext.textAlign = 'center';\n                    mapContext.textBaseline = 'top';\n                    mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                    mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n                }\n            }\n        }\n        \n        console.log('Map visualization updated');\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n        console.error('Error details:', error.message);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T23:03:33.945Z","tree_hash":"e3945dace3a07e0a7515bb2c347568c83d3f04aab7fd72669328e140fe3ed2de","added":[],"modified":[{"path":"mini-project-3-team-tiger/README.md","size":7603,"mtime":1765321412432,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ dashboard.py         # Streamlit dashboard (standalone)\n‚îú‚îÄ‚îÄ requirements.txt    # Python dependencies for Streamlit\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Option 1: Streamlit Dashboard (Recommended - Standalone)\n\nThe Streamlit dashboard is a complete standalone solution that doesn't require separate backend/frontend setup.\n\n1. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n2. Run the Streamlit dashboard:\n   ```bash\n   streamlit run dashboard.py\n   ```\n   \n   The dashboard will automatically open in your browser at `http://localhost:8501`\n\n### Option 2: Flask Backend + HTML Frontend\n\nIf you prefer the separate backend/frontend architecture:\n\n#### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   The API will be available at `http://localhost:5001`\n\n#### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n### Streamlit Dashboard (Easiest)\n```bash\nstreamlit run dashboard.py\n```\n\n### Flask + HTML Frontend\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5001\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   \n   **IMPORTANT:** Run the server from the project root (not from frontend/):\n   ```bash\n   cd /Users/felixisaac123/Desktop/MiniProject3/mini-project-3-team-tiger\n   python3 -m http.server 8000\n   ```\n   \n   Or use the startup script:\n   ```bash\n   ./start_frontend.sh\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000/frontend/`\n   - **Note:** The URL must include `/frontend/` at the end!\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5001/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nThe backend uses port 5001 by default to avoid conflicts with macOS AirPlay Receiver (which uses port 5000). If port 5001 is also in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5002, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T23:03:43.733Z","tree_hash":"47c5e068b186ed632fd83d28f281e94e39da862ffd0985d571b1df3f95930782","added":[],"modified":[{"path":"mini-project-3-team-tiger/frontend/app.js","size":25379,"mtime":1765321423526,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: false, // Start paused, user can click play\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    if (!mapImageEl || !mapOverlay) {\n        console.error('Map elements not found');\n        return;\n    }\n    \n    console.log('Setting up map canvas. Image src:', mapImageEl.src);\n    \n    // Handle image load\n    const handleImageLoad = () => {\n        mapImage = mapImageEl;\n        // Set canvas size to match image\n        const imgWidth = mapImageEl.naturalWidth || mapImageEl.offsetWidth || 1000;\n        const imgHeight = mapImageEl.naturalHeight || mapImageEl.offsetHeight || 1000;\n        \n        mapOverlay.width = imgWidth;\n        mapOverlay.height = imgHeight;\n        mapContext = mapOverlay.getContext('2d');\n        \n        console.log('Map image loaded successfully!');\n        console.log('Image dimensions:', imgWidth, 'x', imgHeight);\n        console.log('Canvas dimensions:', mapOverlay.width, 'x', mapOverlay.height);\n        \n        // Load initial visualization once timestamps are loaded\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    };\n    \n    // Handle image load error\n    const handleImageError = () => {\n        console.error('Failed to load map image!');\n        console.error('Attempted path:', mapImageEl.src);\n        console.error('Current URL:', window.location.href);\n        console.error('Try checking:');\n        console.error('  1. Is the server running from the frontend/ directory?');\n        console.error('  2. Does ../assets/map.png exist relative to frontend/?');\n        console.error('  3. Check browser Network tab for 404 errors');\n        \n        // Show error message on page\n        const mapContainer = document.querySelector('.map-container');\n        if (mapContainer) {\n            const errorDiv = document.createElement('div');\n            errorDiv.style.cssText = 'padding: 20px; background: #ffebee; color: #c62828; border-radius: 8px; margin: 10px;';\n            errorDiv.innerHTML = `\n                <strong>Error loading map image</strong><br>\n                Path: ${mapImageEl.src}<br>\n                <small>Check browser console (F12) for details. Make sure you're running a web server from the frontend/ directory.</small>\n            `;\n            mapContainer.appendChild(errorDiv);\n        }\n    };\n    \n    // Check if image is already loaded\n    if (mapImageEl.complete && mapImageEl.naturalHeight !== 0) {\n        console.log('Image already loaded');\n        handleImageLoad();\n    } else {\n        mapImageEl.addEventListener('load', handleImageLoad);\n        mapImageEl.addEventListener('error', handleImageError);\n        \n        // Force reload if src is set\n        if (mapImageEl.src && !mapImageEl.src.includes('data:')) {\n            console.log('Waiting for image to load...');\n        }\n    }\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage && mapOverlay) {\n            const imgWidth = mapImage.naturalWidth || mapImage.offsetWidth || 1000;\n            const imgHeight = mapImage.naturalHeight || mapImage.offsetHeight || 1000;\n            mapOverlay.width = imgWidth;\n            mapOverlay.height = imgHeight;\n            // Redraw current frame\n            if (animationState.timestamps.length > 0 && animationState.currentTimeIndex < animationState.timestamps.length) {\n                updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n            }\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error || !data.timestamps || data.timestamps.length === 0) {\n            console.error('No timestamps available:', data);\n            return;\n        }\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Update slider max value\n        const timeSlider = document.getElementById('time-slider');\n        if (timeSlider) {\n            timeSlider.max = data.timestamps.length - 1;\n        }\n        \n        // Load first frame (wait a bit for map to be ready)\n        if (animationState.timestamps.length > 0) {\n            setTimeout(() => {\n                if (mapContext && mapImage) {\n                    updateMapVisualizationForTime(animationState.timestamps[0]);\n                } else {\n                    console.warn('Map not ready, will retry when image loads');\n                }\n            }, 100);\n        }\n        \n        console.log(`Loaded ${data.timestamps.length} timestamps`);\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n        console.error('Make sure the backend server is running on http://localhost:5001');\n        document.getElementById('current-time-display').textContent = \n            'Error: Cannot connect to backend. Make sure server is running.';\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    if (!timeSlider || !timeSliderValue) {\n        console.error('Time slider elements not found');\n        return;\n    }\n    \n    timeSlider.addEventListener('input', (e) => {\n        const index = parseInt(e.target.value);\n        \n        if (animationState.timestamps.length > 0 && index >= 0 && index < animationState.timestamps.length) {\n            animationState.currentTimeIndex = index;\n            const timestamp = animationState.timestamps[index];\n            const timeObj = new Date(timestamp);\n            const timeString = `${timeObj.getHours().toString().padStart(2, '0')}:${timeObj.getMinutes().toString().padStart(2, '0')}`;\n            timeSliderValue.textContent = timeString;\n            updateMapVisualizationForTime(timestamp);\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `/assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) {\n        console.warn('Map context or image not ready yet');\n        return;\n    }\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('API error:', data.error);\n            return;\n        }\n        \n        if (!data.slots || data.slots.length === 0) {\n            console.log('No slots data for this timestamp');\n            // Still clear and show empty map\n        }\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        const timeDisplay = document.getElementById('current-time-display');\n        if (timeDisplay) {\n            timeDisplay.textContent = `Time: ${timeObj.toLocaleTimeString()}`;\n        }\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width || 1000;\n        const mapHeight = mapImage.naturalHeight || mapImage.height || 1000;\n        const canvasWidth = mapContext.canvas.width;\n        const canvasHeight = mapContext.canvas.height;\n        const scaleX = canvasWidth / mapWidth;\n        const scaleY = canvasHeight / mapHeight;\n        \n        console.log('Drawing map:', {\n            mapSize: `${mapWidth}x${mapHeight}`,\n            canvasSize: `${canvasWidth}x${canvasHeight}`,\n            scale: `${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`,\n            slots: data.slots ? data.slots.length : 0\n        });\n        \n        // Draw active slots with license plates\n        if (data.slots && data.slots.length > 0) {\n            // First pass: draw all slot borders\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                    \n                    // Draw slot border\n                    mapContext.strokeStyle = '#FF4444';\n                    mapContext.lineWidth = 2;\n                    mapContext.strokeRect(\n                        x - slotSize / 2,\n                        y - slotSize / 2,\n                        slotSize,\n                        slotSize\n                    );\n                }\n            }\n            \n            // Second pass: load and draw license plates (async)\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY);\n                    \n                    // Load and draw license plate image if available\n                    if (slot.plate_number) {\n                        const plateImg = await loadPlateImage(slot.plate_number);\n                        if (plateImg) {\n                            // Draw license plate image\n                            const plateSize = slotSize * 0.9;\n                            mapContext.drawImage(\n                                plateImg,\n                                x - plateSize / 2,\n                                y - plateSize / 2,\n                                plateSize,\n                                plateSize\n                            );\n                        }\n                    }\n                    \n                    // Draw slot ID label (on top)\n                    mapContext.fillStyle = '#FFFFFF';\n                    mapContext.strokeStyle = '#000000';\n                    mapContext.lineWidth = 3;\n                    mapContext.font = 'bold 12px Arial';\n                    mapContext.textAlign = 'center';\n                    mapContext.textBaseline = 'top';\n                    mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                    mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n                }\n            }\n        }\n        \n        console.log('Map visualization updated');\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n        console.error('Error details:', error.message);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"},{"path":"mini-project-3-team-tiger/README.md","size":7603,"mtime":1765321423541,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ dashboard.py         # Streamlit dashboard (standalone)\n‚îú‚îÄ‚îÄ requirements.txt    # Python dependencies for Streamlit\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Option 1: Streamlit Dashboard (Recommended - Standalone)\n\nThe Streamlit dashboard is a complete standalone solution that doesn't require separate backend/frontend setup.\n\n1. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n2. Run the Streamlit dashboard:\n   ```bash\n   streamlit run dashboard.py\n   ```\n   \n   The dashboard will automatically open in your browser at `http://localhost:8501`\n\n### Option 2: Flask Backend + HTML Frontend\n\nIf you prefer the separate backend/frontend architecture:\n\n#### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   The API will be available at `http://localhost:5001`\n\n#### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n### Streamlit Dashboard (Easiest)\n```bash\nstreamlit run dashboard.py\n```\n\n### Flask + HTML Frontend\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5001\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   \n   **IMPORTANT:** Run the server from the project root (not from frontend/):\n   ```bash\n   cd /Users/felixisaac123/Desktop/MiniProject3/mini-project-3-team-tiger\n   python3 -m http.server 8000\n   ```\n   \n   Or use the startup script:\n   ```bash\n   ./start_frontend.sh\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000/frontend/`\n   - **Note:** The URL must include `/frontend/` at the end!\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5001/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nThe backend uses port 5001 by default to avoid conflicts with macOS AirPlay Receiver (which uses port 5000). If port 5001 is also in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5002, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"},{"path":"mini-project-3-team-tiger/frontend/index.html","size":6786,"mtime":1765321423526,"ext":"html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Sky Harbor Airport - Ride-Hailing Dashboard</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <!-- Header -->\n        <header class=\"header\">\n            <h1>‚úàÔ∏è Sky Harbor Airport</h1>\n            <h2>Ride-Hailing Display Dashboard</h2>\n        </header>\n\n        <!-- Terminal Selection Tabs -->\n        <div class=\"terminal-tabs\">\n            <button class=\"tab-button active\" data-terminal=\"Terminal 3\">Terminal 3</button>\n            <button class=\"tab-button\" data-terminal=\"Terminal 4\">Terminal 4</button>\n        </div>\n\n        <!-- Terminal Guidance Banner -->\n        <div id=\"guidance-banner\" class=\"guidance-banner\">\n            <div class=\"banner-content\">\n                <span class=\"banner-icon\">üìç</span>\n                <span id=\"guidance-message\" class=\"guidance-message\">Loading guidance...</span>\n            </div>\n            <div class=\"banner-details\">\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Zone:</span>\n                    <span id=\"zone-name\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Walking Time:</span>\n                    <span id=\"walking-time\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Estimated Wait:</span>\n                    <span id=\"estimated-wait\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Available Slots:</span>\n                    <span id=\"available-slots\" class=\"detail-value\">-</span>\n                </div>\n            </div>\n        </div>\n\n        <!-- Price & Wait Forecast Section -->\n        <div class=\"forecast-section\">\n            <h3>Price & Wait Forecast (15-30 min horizon)</h3>\n            \n            <div class=\"forecast-cards\">\n                <!-- Price Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">üí∞</span>\n                        <span class=\"card-title\">Price Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"price-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"price-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Wait Time Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">‚è±Ô∏è</span>\n                        <span class=\"card-title\">Wait Time Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"wait-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"wait-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- Map Visualization -->\n        <div class=\"map-section\">\n            <div class=\"map-header\">\n                <h3>Live Map View - Parking Lot Status (6:00 PM - 6:59 PM)</h3>\n                <div class=\"animation-controls\">\n                    <button id=\"play-pause-btn\" class=\"control-btn\">‚è∏Ô∏è Pause</button>\n                    <button id=\"speed-down-btn\" class=\"control-btn\">‚è™ Slow</button>\n                    <span id=\"speed-indicator\" class=\"speed-indicator\">1x</span>\n                    <button id=\"speed-up-btn\" class=\"control-btn\">‚è© Fast</button>\n                    <button id=\"reset-btn\" class=\"control-btn\">üîÑ Reset</button>\n                </div>\n            </div>\n            <div class=\"time-display\">\n                <span id=\"current-time-display\">Time: --:--:--</span>\n            </div>\n            <div class=\"time-slider-container\">\n                <label for=\"time-slider\">Select Time:</label>\n                <input type=\"range\" id=\"time-slider\" min=\"0\" max=\"59\" value=\"0\" class=\"time-slider\">\n                <span id=\"time-slider-value\">18:00</span>\n            </div>\n            <div class=\"map-container\">\n                <img id=\"map-image\" src=\"/assets/map.png\" alt=\"Airport Map\" class=\"map-image\" \n                     onerror=\"console.error('Failed to load map image. Path:', this.src); this.style.display='none';\">\n                <canvas id=\"map-overlay\" class=\"map-overlay\"></canvas>\n            </div>\n        </div>\n\n        <!-- Status Footer -->\n        <footer class=\"status-footer\">\n            <div class=\"status-item\">\n                <span class=\"status-label\">Last Updated:</span>\n                <span id=\"last-updated\" class=\"status-value\">-</span>\n            </div>\n            <div class=\"status-item\">\n                <span class=\"status-label\">API Status:</span>\n                <span id=\"api-status\" class=\"status-value\">Checking...</span>\n            </div>\n        </footer>\n    </div>\n\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n"},{"path":"mini-project-3-team-tiger/frontend/start_server.sh","size":318,"mtime":1765321423526,"ext":"sh","content":"#!/bin/bash\n# Start frontend web server\n# This script ensures the server runs from the correct directory\n\ncd \"$(dirname \"$0\")\"\necho \"Starting frontend web server...\"\necho \"Serving from: $(pwd)\"\necho \"\"\necho \"Open your browser to: http://localhost:8000\"\necho \"Press Ctrl+C to stop\"\necho \"\"\npython3 -m http.server 8000\n\n"},{"path":"mini-project-3-team-tiger/start_frontend.sh","size":362,"mtime":1765321423526,"ext":"sh","content":"#!/bin/bash\n# Start frontend web server from project root\n# This allows access to both frontend/ and assets/ directories\n\ncd \"$(dirname \"$0\")\"\necho \"Starting frontend web server from project root...\"\necho \"Serving from: $(pwd)\"\necho \"\"\necho \"Open your browser to: http://localhost:8000/frontend/\"\necho \"Press Ctrl+C to stop\"\necho \"\"\npython3 -m http.server 8000\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2ZlbGl4","ts":"2025-12-09T23:05:58.796Z","tree_hash":"0d160f756ce5e6ba3262e595eb9e78b200737ae22a601684a999488d030eea4e","added":[{"path":".cursorindexingignore","size":110,"mtime":1765316565707,"ext":""},{"path":"mini-project-3-team-tiger/assets/ride_hailing.xlsx","size":49230,"mtime":1765319267338,"ext":"xlsx"},{"path":"mini-project-3-team-tiger/backend/app.py","size":12082,"mtime":1765320135386,"ext":"py","content":"\"\"\"\nBackend API for Ride-Hailing Display/Dashboard at Sky Harbor Airport\nTechnical Lead: Data processing and API routing\n\"\"\"\n\nfrom flask import Flask, jsonify, request\nfrom flask_cors import CORS\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport os\n\napp = Flask(__name__)\nCORS(app)  # Enable CORS for frontend\n\n# Path to data file\nDATA_FILE = os.path.join(os.path.dirname(__file__), '..', 'assets', 'ride_hailing.xlsx')\n\n# Terminal to pickup zone mapping\nTERMINAL_ZONES = {\n    'Terminal 3': {\n        'zone': 'Zone A',\n        'walking_time_minutes': 3,\n        'pickup_coords': {'x': 300, 'y': 200}  # Approximate zone location\n    },\n    'Terminal 4': {\n        'zone': 'Zone B',\n        'walking_time_minutes': 5,\n        'pickup_coords': {'x': 500, 'y': 300}  # Approximate zone location\n    }\n}\n\n# Load and cache data\ndef load_data():\n    \"\"\"Load ride hailing data from Excel file\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Global data cache\n_data_cache = None\n\ndef get_data():\n    \"\"\"Get cached data or load fresh\"\"\"\n    global _data_cache\n    if _data_cache is None:\n        _data_cache = load_data()\n    return _data_cache.copy()\n\n@app.route('/api/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({'status': 'healthy', 'message': 'Backend API is running'})\n\n@app.route('/api/data/current', methods=['GET'])\ndef get_current_data():\n    \"\"\"Get current ride data\"\"\"\n    df = get_data()\n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots (with valid positions)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    result = {\n        'timestamp': latest_time.isoformat(),\n        'total_slots': len(current_data),\n        'active_slots': len(active_slots),\n        'slots': active_slots.to_dict('records')\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/terminal/guidance', methods=['GET'])\ndef get_terminal_guidance():\n    \"\"\"Get terminal-aware pickup guidance\"\"\"\n    terminal = request.args.get('terminal', 'Terminal 3')\n    \n    if terminal not in TERMINAL_ZONES:\n        return jsonify({'error': f'Terminal {terminal} not found'}), 400\n    \n    terminal_info = TERMINAL_ZONES[terminal]\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_time].copy()\n    \n    # Filter active slots in the terminal's zone\n    zone_coords = terminal_info['pickup_coords']\n    zone_x, zone_y = zone_coords['x'], zone_coords['y']\n    \n    # Find nearest available slots (within reasonable distance)\n    active_slots = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    if len(active_slots) > 0:\n        # Calculate distances to zone\n        active_slots['distance'] = np.sqrt(\n            (active_slots['x'] - zone_x)**2 + (active_slots['y'] - zone_y)**2\n        )\n        # Find nearest available slot\n        nearest_slot = active_slots.loc[active_slots['distance'].idxmin()]\n        \n        # Estimate ETA (walking time + wait time)\n        # Wait time based on number of available slots (more slots = less wait)\n        available_count = len(active_slots)\n        estimated_wait_minutes = max(2, 10 - (available_count // 5))  # Simple heuristic\n        \n        total_minutes = terminal_info['walking_time_minutes'] + estimated_wait_minutes\n        \n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': estimated_wait_minutes,\n            'total_minutes': total_minutes,\n            'available_slots': len(active_slots),\n            'nearest_slot_id': int(nearest_slot['slot_id']),\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {total_minutes} minutes.\"\n        }\n    else:\n        result = {\n            'terminal': terminal,\n            'zone': terminal_info['zone'],\n            'walking_time_minutes': terminal_info['walking_time_minutes'],\n            'estimated_wait_minutes': 15,  # Default if no slots\n            'total_minutes': terminal_info['walking_time_minutes'] + 15,\n            'available_slots': 0,\n            'message': f\"From {terminal}: Head to {terminal_info['zone']}. Pickup in {terminal_info['walking_time_minutes'] + 15} minutes.\"\n        }\n    \n    return jsonify(result)\n\n@app.route('/api/forecast/price-wait', methods=['GET'])\ndef get_price_wait_forecast():\n    \"\"\"Get price and wait time forecast (15-30 min horizon)\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get latest timestamp\n    latest_time = df['current_time'].max()\n    \n    # Get data from last 30 minutes for rolling average\n    time_window = timedelta(minutes=30)\n    historical_data = df[df['current_time'] >= (latest_time - time_window)].copy()\n    \n    # Calculate metrics over time windows\n    time_buckets = []\n    for i in range(6):  # 6 buckets of 5 minutes each = 30 minutes\n        bucket_start = latest_time - timedelta(minutes=(6-i)*5)\n        bucket_end = latest_time - timedelta(minutes=(5-i)*5) if i < 5 else latest_time\n        bucket_data = historical_data[\n            (historical_data['current_time'] >= bucket_start) & \n            (historical_data['current_time'] < bucket_end)\n        ]\n        \n        active_slots = bucket_data[\n            bucket_data['x'].notna() & bucket_data['y'].notna()\n        ]\n        \n        # Simulate price based on demand (fewer slots = higher price)\n        # Base price + surge multiplier\n        base_price = 15.0\n        availability_ratio = len(active_slots) / len(bucket_data) if len(bucket_data) > 0 else 0\n        surge_multiplier = max(1.0, 2.0 - availability_ratio)\n        price = base_price * surge_multiplier\n        \n        # Wait time based on availability\n        wait_time = max(2, 15 - (len(active_slots) // 3))\n        \n        time_buckets.append({\n            'time': bucket_start.isoformat(),\n            'price': round(price, 2),\n            'wait_time': wait_time,\n            'availability': len(active_slots)\n        })\n    \n    # Calculate rolling averages and trends\n    prices = [b['price'] for b in time_buckets]\n    wait_times = [b['wait_time'] for b in time_buckets]\n    \n    # Rolling average (last 3 buckets)\n    recent_prices = prices[-3:] if len(prices) >= 3 else prices\n    recent_waits = wait_times[-3:] if len(wait_times) >= 3 else wait_times\n    \n    avg_price = np.mean(recent_prices)\n    avg_wait = np.mean(recent_waits)\n    \n    # Calculate slope/trend (linear regression on last 3 points)\n    if len(recent_prices) >= 2:\n        x = np.arange(len(recent_prices))\n        price_slope = np.polyfit(x, recent_prices, 1)[0]\n        wait_slope = np.polyfit(x, recent_waits, 1)[0]\n    else:\n        price_slope = 0\n        wait_slope = 0\n    \n    # Determine trend direction\n    def get_trend(slope, threshold=0.1):\n        if slope > threshold:\n            return 'up'\n        elif slope < -threshold:\n            return 'down'\n        else:\n            return 'flat'\n    \n    price_trend = get_trend(price_slope, threshold=0.5)\n    wait_trend = get_trend(wait_slope, threshold=0.5)\n    \n    # Forecast for next 15-30 minutes\n    forecast_horizon = 20  # minutes\n    forecast_price = avg_price + (price_slope * 4)  # Extrapolate\n    forecast_wait = avg_wait + (wait_slope * 4)\n    \n    # Ensure reasonable bounds\n    forecast_price = max(10.0, min(50.0, forecast_price))\n    forecast_wait = max(2, min(30, int(forecast_wait)))\n    \n    result = {\n        'current': {\n            'price': round(prices[-1] if prices else avg_price, 2),\n            'wait_time': wait_times[-1] if wait_times else int(avg_wait),\n            'timestamp': latest_time.isoformat()\n        },\n        'forecast': {\n            'price': round(forecast_price, 2),\n            'wait_time': forecast_wait,\n            'horizon_minutes': forecast_horizon\n        },\n        'trends': {\n            'price': {\n                'direction': price_trend,\n                'slope': round(price_slope, 3)\n            },\n            'wait_time': {\n                'direction': wait_trend,\n                'slope': round(wait_slope, 3)\n            }\n        },\n        'historical': time_buckets,\n        'sparkline_data': {\n            'prices': prices,\n            'wait_times': wait_times\n        }\n    }\n    \n    return jsonify(result)\n\n@app.route('/api/data/timeseries', methods=['GET'])\ndef get_timeseries_data():\n    \"\"\"Get time series data for visualization\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    # Get unique timestamps\n    unique_times = sorted(df['current_time'].unique())\n    \n    # Aggregate data by timestamp\n    timeseries = []\n    for timestamp in unique_times:\n        time_data = df[df['current_time'] == timestamp]\n        active_slots = time_data[\n            time_data['x'].notna() & time_data['y'].notna()\n        ]\n        \n        timeseries.append({\n            'timestamp': timestamp.isoformat(),\n            'active_slots': len(active_slots),\n            'total_slots': len(time_data)\n        })\n    \n    return jsonify({\n        'timeseries': timeseries,\n        'total_points': len(timeseries)\n    })\n\n@app.route('/api/data/time/<timestamp>', methods=['GET'])\ndef get_data_by_time(timestamp):\n    \"\"\"Get ride data for a specific timestamp\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    try:\n        # Parse timestamp (accept ISO format or simple format)\n        try:\n            target_time = pd.to_datetime(timestamp)\n        except:\n            # Try parsing as ISO string\n            target_time = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))\n        \n        # Find closest timestamp (exact match preferred)\n        time_data = df[df['current_time'] == target_time].copy()\n        \n        if len(time_data) == 0:\n            # Find closest timestamp\n            unique_times = sorted(df['current_time'].unique())\n            closest_time = min(unique_times, key=lambda x: abs((x - target_time).total_seconds()))\n            time_data = df[df['current_time'] == closest_time].copy()\n            target_time = closest_time\n        \n        # Filter active slots\n        active_slots = time_data[\n            time_data['x'].notna() & time_data['y'].notna()\n        ].copy()\n        \n        result = {\n            'timestamp': target_time.isoformat(),\n            'total_slots': len(time_data),\n            'active_slots': len(active_slots),\n            'slots': active_slots.to_dict('records')\n        }\n        \n        return jsonify(result)\n    except Exception as e:\n        return jsonify({'error': f'Invalid timestamp: {str(e)}'}), 400\n\n@app.route('/api/data/timestamps', methods=['GET'])\ndef get_available_timestamps():\n    \"\"\"Get list of all available timestamps\"\"\"\n    df = get_data()\n    \n    if df.empty:\n        return jsonify({'error': 'No data available'}), 500\n    \n    unique_times = sorted(df['current_time'].unique())\n    \n    return jsonify({\n        'timestamps': [t.isoformat() for t in unique_times],\n        'count': len(unique_times)\n    })\n\nif __name__ == '__main__':\n    print(\"Starting Backend API Server...\")\n    print(f\"Data file: {DATA_FILE}\")\n    # Use port 5001 to avoid conflict with macOS AirPlay Receiver on port 5000\n    app.run(debug=True, port=5001, host='0.0.0.0')\n\n"},{"path":"mini-project-3-team-tiger/backend/start_server.sh","size":302,"mtime":1765319785849,"ext":"sh","content":"#!/bin/bash\n# Backend server startup script\n\ncd \"$(dirname \"$0\")\"\necho \"Starting Backend API Server...\"\necho \"Data file: $(python3 -c \"from app import DATA_FILE; print(DATA_FILE)\")\"\necho \"Server will be available at http://localhost:5000\"\necho \"Press Ctrl+C to stop the server\"\necho \"\"\npython3 app.py\n\n"},{"path":"mini-project-3-team-tiger/backend/requirements.txt","size":76,"mtime":1765319489579,"ext":"txt","content":"flask==3.0.0\nflask-cors==4.0.0\npandas==2.1.3\nnumpy==1.26.2\nopenpyxl==3.1.2\n\n"},{"path":"mini-project-3-team-tiger/TROUBLESHOOTING.md","size":3021,"mtime":1765320986392,"ext":"md","content":"# Troubleshooting Guide\n\n## Quick Checklist\n\n### 1. Is the backend running?\n\n**Check:**\n```bash\ncurl http://localhost:5001/api/health\n```\n\n**Should return:** `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n**If not working:**\n```bash\ncd mini-project-3-team-tiger/backend\npython3 app.py\n```\n\nYou should see:\n```\nStarting Backend API Server...\nData file: /Users/.../assets/ride_hailing.xlsx\n * Running on http://0.0.0.0:5001\n```\n\n### 2. Is the frontend using a web server?\n\n**IMPORTANT:** You cannot open `index.html` directly (file://). You MUST use a web server.\n\n**Start a web server:**\n```bash\ncd mini-project-3-team-tiger/frontend\npython3 -m http.server 8000\n```\n\nThen open: `http://localhost:8000`\n\n### 3. Check browser console\n\n1. Open browser Developer Tools (F12 or Cmd+Option+I)\n2. Go to Console tab\n3. Look for errors\n\n**Common errors:**\n- `Failed to fetch` ‚Üí Backend not running\n- `CORS error` ‚Üí Not using a web server (opened file:// directly)\n- `Cannot read property` ‚Üí JavaScript error, check console\n\n### 4. Test backend endpoints manually\n\n```bash\n# Test health\ncurl http://localhost:5001/api/health\n\n# Test timestamps\ncurl http://localhost:5001/api/data/timestamps\n\n# Test specific time\ncurl \"http://localhost:5001/api/data/time/2025-09-17T18:00:00\"\n```\n\n### 5. Verify files exist\n\n```bash\ncd mini-project-3-team-tiger\nls assets/map.png          # Should exist\nls assets/ride_hailing.xlsx # Should exist\nls assets/plates/          # Should have 100 PNG files\n```\n\n### 6. Common Issues\n\n#### Map not showing\n- Check browser console for errors\n- Verify `map.png` exists in `assets/` folder\n- Check that backend is running\n\n#### License plates not showing\n- Check browser console for 404 errors on plate images\n- Verify plate images exist in `assets/plates/` folder\n- Check that plate numbers in data match filenames\n\n#### Animation not working\n- Check that timestamps loaded (see console)\n- Click \"Play\" button to start animation\n- Use time slider to navigate manually\n\n#### \"Unable to load guidance\" error\n- Backend not running\n- Wrong port (should be 5001, not 5000)\n- CORS issue (not using web server)\n\n## Step-by-Step Startup\n\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd /Users/felixisaac123/Desktop/MiniProject3/mini-project-3-team-tiger/backend\n   python3 app.py\n   ```\n   Keep this running!\n\n2. **Terminal 2 - Start Frontend Server:**\n   ```bash\n   cd /Users/felixisaac123/Desktop/MiniProject3/mini-project-3-team-tiger/frontend\n   python3 -m http.server 8000\n   ```\n\n3. **Open Browser:**\n   - Go to `http://localhost:8000`\n   - Open Developer Tools (F12)\n   - Check Console tab for any errors\n\n## Still Not Working?\n\nRun the test script:\n```bash\ncd mini-project-3-team-tiger\npython3 test_backend.py\n```\n\nThis will verify:\n- All dependencies are installed\n- Data file can be loaded\n- Backend code is correct\n\nIf test passes but frontend doesn't work, the issue is likely:\n- Backend not running\n- Frontend not using web server\n- Browser cache (try hard refresh: Cmd+Shift+R)\n\n"},{"path":"mini-project-3-team-tiger/requirements.txt","size":96,"mtime":1765320409997,"ext":"txt","content":"streamlit==1.28.0\npandas==2.1.3\nnumpy==1.26.2\nopenpyxl==3.1.2\nmatplotlib==3.8.2\nPillow==10.1.0\n\n"},{"path":"mini-project-3-team-tiger/frontend/app.js","size":25379,"mtime":1765321549863,"ext":"js","content":"/**\n * Frontend Application for Ride-Hailing Display/Dashboard\n * UI/UX Specialist: Frontend logic and API integration\n */\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// State management\nlet currentTerminal = 'Terminal 3';\nlet updateInterval = null;\nlet mapContext = null;\nlet mapImage = null;\n\n// Animation state\nlet animationState = {\n    isPlaying: false, // Start paused, user can click play\n    currentTimeIndex: 0,\n    timestamps: [],\n    speed: 1, // 1x, 2x, 4x, 0.5x\n    animationInterval: null,\n    plateImages: {} // Cache for license plate images\n};\n\n// Initialize application\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeApp();\n});\n\nfunction initializeApp() {\n    setupTerminalTabs();\n    setupMapCanvas();\n    setupAnimationControls();\n    setupTimeSlider();\n    checkAPIHealth();\n    loadTimestamps();\n    startAutoUpdate();\n}\n\n// Terminal tab switching\nfunction setupTerminalTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            // Update active state\n            tabButtons.forEach(btn => btn.classList.remove('active'));\n            button.classList.add('active');\n            \n            // Update current terminal\n            currentTerminal = button.dataset.terminal;\n            \n            // Refresh guidance\n            updateTerminalGuidance();\n        });\n    });\n}\n\n// Setup map canvas overlay\nfunction setupMapCanvas() {\n    const mapImageEl = document.getElementById('map-image');\n    const mapOverlay = document.getElementById('map-overlay');\n    \n    if (!mapImageEl || !mapOverlay) {\n        console.error('Map elements not found');\n        return;\n    }\n    \n    console.log('Setting up map canvas. Image src:', mapImageEl.src);\n    \n    // Handle image load\n    const handleImageLoad = () => {\n        mapImage = mapImageEl;\n        // Set canvas size to match image\n        const imgWidth = mapImageEl.naturalWidth || mapImageEl.offsetWidth || 1000;\n        const imgHeight = mapImageEl.naturalHeight || mapImageEl.offsetHeight || 1000;\n        \n        mapOverlay.width = imgWidth;\n        mapOverlay.height = imgHeight;\n        mapContext = mapOverlay.getContext('2d');\n        \n        console.log('Map image loaded successfully!');\n        console.log('Image dimensions:', imgWidth, 'x', imgHeight);\n        console.log('Canvas dimensions:', mapOverlay.width, 'x', mapOverlay.height);\n        \n        // Load initial visualization once timestamps are loaded\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n        }\n    };\n    \n    // Handle image load error\n    const handleImageError = () => {\n        console.error('Failed to load map image!');\n        console.error('Attempted path:', mapImageEl.src);\n        console.error('Current URL:', window.location.href);\n        console.error('Try checking:');\n        console.error('  1. Is the server running from the frontend/ directory?');\n        console.error('  2. Does ../assets/map.png exist relative to frontend/?');\n        console.error('  3. Check browser Network tab for 404 errors');\n        \n        // Show error message on page\n        const mapContainer = document.querySelector('.map-container');\n        if (mapContainer) {\n            const errorDiv = document.createElement('div');\n            errorDiv.style.cssText = 'padding: 20px; background: #ffebee; color: #c62828; border-radius: 8px; margin: 10px;';\n            errorDiv.innerHTML = `\n                <strong>Error loading map image</strong><br>\n                Path: ${mapImageEl.src}<br>\n                <small>Check browser console (F12) for details. Make sure you're running a web server from the frontend/ directory.</small>\n            `;\n            mapContainer.appendChild(errorDiv);\n        }\n    };\n    \n    // Check if image is already loaded\n    if (mapImageEl.complete && mapImageEl.naturalHeight !== 0) {\n        console.log('Image already loaded');\n        handleImageLoad();\n    } else {\n        mapImageEl.addEventListener('load', handleImageLoad);\n        mapImageEl.addEventListener('error', handleImageError);\n        \n        // Force reload if src is set\n        if (mapImageEl.src && !mapImageEl.src.includes('data:')) {\n            console.log('Waiting for image to load...');\n        }\n    }\n    \n    // Handle window resize\n    window.addEventListener('resize', () => {\n        if (mapImage && mapOverlay) {\n            const imgWidth = mapImage.naturalWidth || mapImage.offsetWidth || 1000;\n            const imgHeight = mapImage.naturalHeight || mapImage.offsetHeight || 1000;\n            mapOverlay.width = imgWidth;\n            mapOverlay.height = imgHeight;\n            // Redraw current frame\n            if (animationState.timestamps.length > 0 && animationState.currentTimeIndex < animationState.timestamps.length) {\n                updateMapVisualizationForTime(animationState.timestamps[animationState.currentTimeIndex]);\n            }\n        }\n    });\n}\n\n// Check API health\nasync function checkAPIHealth() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        updateAPIStatus('healthy', 'Connected');\n    } catch (error) {\n        updateAPIStatus('error', 'Disconnected - Start backend server');\n        console.error('API health check failed:', error);\n        console.error('Make sure to run: cd backend && python3 app.py');\n    }\n}\n\n// Update terminal guidance banner\nasync function updateTerminalGuidance() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/terminal/guidance?terminal=${encodeURIComponent(currentTerminal)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Guidance error:', data.error);\n            document.getElementById('guidance-message').textContent = `Error: ${data.error}`;\n            return;\n        }\n        \n        // Update banner message\n        document.getElementById('guidance-message').textContent = data.message;\n        \n        // Update details\n        document.getElementById('zone-name').textContent = data.zone;\n        document.getElementById('walking-time').textContent = `${data.walking_time_minutes} min`;\n        document.getElementById('estimated-wait').textContent = `${data.estimated_wait_minutes} min`;\n        document.getElementById('available-slots').textContent = data.available_slots;\n        \n    } catch (error) {\n        console.error('Failed to fetch terminal guidance:', error);\n        document.getElementById('guidance-message').textContent = 'Unable to load guidance. Make sure the backend server is running on http://localhost:5000';\n        // Show error in details too\n        document.getElementById('zone-name').textContent = 'Error';\n        document.getElementById('walking-time').textContent = '-';\n        document.getElementById('estimated-wait').textContent = '-';\n        document.getElementById('available-slots').textContent = '-';\n    }\n}\n\n// Update price and wait forecast\nasync function updateForecast() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/forecast/price-wait`);\n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('Forecast error:', data.error);\n            return;\n        }\n        \n        // Update price information\n        document.getElementById('current-price').textContent = `$${data.current.price.toFixed(2)}`;\n        document.getElementById('forecast-price').textContent = `$${data.forecast.price.toFixed(2)}`;\n        \n        // Update wait time information\n        document.getElementById('current-wait').textContent = `${data.current.wait_time} min`;\n        document.getElementById('forecast-wait').textContent = `${data.forecast.wait_time} min`;\n        \n        // Update trend badges\n        updateTrendBadge('price-trend-badge', data.trends.price.direction);\n        updateTrendBadge('wait-trend-badge', data.trends.wait_time.direction);\n        \n        // Update sparklines\n        drawSparkline('price-sparkline', data.sparkline_data.prices, '#667eea');\n        drawSparkline('wait-sparkline', data.sparkline_data.wait_times, '#764ba2');\n        \n        // Update last updated timestamp\n        const timestamp = new Date(data.current.timestamp);\n        document.getElementById('last-updated').textContent = timestamp.toLocaleTimeString();\n        \n    } catch (error) {\n        console.error('Failed to fetch forecast:', error);\n    }\n}\n\n// Update trend badge styling\nfunction updateTrendBadge(badgeId, direction) {\n    const badge = document.getElementById(badgeId);\n    badge.className = `trend-badge ${direction}`;\n    \n    const trendText = badge.querySelector('.trend-text');\n    const directionText = {\n        'up': 'Rising',\n        'down': 'Falling',\n        'flat': 'Stable'\n    };\n    trendText.textContent = directionText[direction] || 'Stable';\n}\n\n// Draw sparkline chart\nfunction drawSparkline(canvasId, data, color) {\n    const canvas = document.getElementById(canvasId);\n    if (!canvas || !data || data.length === 0) return;\n    \n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    const padding = 5;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    if (data.length < 2) return;\n    \n    // Calculate scaling\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min || 1; // Avoid division by zero\n    \n    // Draw line\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    const stepX = (width - 2 * padding) / (data.length - 1);\n    \n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        if (index === 0) {\n            ctx.moveTo(x, y);\n        } else {\n            ctx.lineTo(x, y);\n        }\n    });\n    \n    ctx.stroke();\n    \n    // Draw area fill\n    ctx.fillStyle = color;\n    ctx.globalAlpha = 0.2;\n    ctx.lineTo(padding + (data.length - 1) * stepX, height - padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.closePath();\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    \n    // Draw points\n    ctx.fillStyle = color;\n    data.forEach((value, index) => {\n        const x = padding + index * stepX;\n        const normalizedValue = (value - min) / range;\n        const y = padding + (height - 2 * padding) * (1 - normalizedValue);\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n}\n\n// Load available timestamps\nasync function loadTimestamps() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/data/timestamps`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error || !data.timestamps || data.timestamps.length === 0) {\n            console.error('No timestamps available:', data);\n            return;\n        }\n        \n        animationState.timestamps = data.timestamps;\n        animationState.currentTimeIndex = 0;\n        \n        // Update slider max value\n        const timeSlider = document.getElementById('time-slider');\n        if (timeSlider) {\n            timeSlider.max = data.timestamps.length - 1;\n        }\n        \n        // Load first frame (wait a bit for map to be ready)\n        if (animationState.timestamps.length > 0) {\n            setTimeout(() => {\n                if (mapContext && mapImage) {\n                    updateMapVisualizationForTime(animationState.timestamps[0]);\n                } else {\n                    console.warn('Map not ready, will retry when image loads');\n                }\n            }, 100);\n        }\n        \n        console.log(`Loaded ${data.timestamps.length} timestamps`);\n    } catch (error) {\n        console.error('Failed to load timestamps:', error);\n        console.error('Make sure the backend server is running on http://localhost:5001');\n        document.getElementById('current-time-display').textContent = \n            'Error: Cannot connect to backend. Make sure server is running.';\n    }\n}\n\n// Setup animation controls\nfunction setupAnimationControls() {\n    const playPauseBtn = document.getElementById('play-pause-btn');\n    const speedDownBtn = document.getElementById('speed-down-btn');\n    const speedUpBtn = document.getElementById('speed-up-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    \n    playPauseBtn.addEventListener('click', () => {\n        animationState.isPlaying = !animationState.isPlaying;\n        if (animationState.isPlaying) {\n            playPauseBtn.textContent = '‚è∏Ô∏è Pause';\n            startAnimation();\n        } else {\n            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';\n            stopAnimation();\n        }\n    });\n    \n    speedDownBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex > 0) {\n            animationState.speed = speeds[currentIndex - 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    speedUpBtn.addEventListener('click', () => {\n        const speeds = [0.5, 1, 2, 4];\n        const currentIndex = speeds.indexOf(animationState.speed);\n        if (currentIndex < speeds.length - 1) {\n            animationState.speed = speeds[currentIndex + 1];\n            updateSpeedIndicator();\n            if (animationState.isPlaying) {\n                startAnimation(); // Restart with new speed\n            }\n        }\n    });\n    \n    resetBtn.addEventListener('click', () => {\n        animationState.currentTimeIndex = 0;\n        if (animationState.timestamps.length > 0) {\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    });\n}\n\nfunction updateSpeedIndicator() {\n    document.getElementById('speed-indicator').textContent = `${animationState.speed}x`;\n}\n\n// Setup time slider\nfunction setupTimeSlider() {\n    const timeSlider = document.getElementById('time-slider');\n    const timeSliderValue = document.getElementById('time-slider-value');\n    \n    if (!timeSlider || !timeSliderValue) {\n        console.error('Time slider elements not found');\n        return;\n    }\n    \n    timeSlider.addEventListener('input', (e) => {\n        const index = parseInt(e.target.value);\n        \n        if (animationState.timestamps.length > 0 && index >= 0 && index < animationState.timestamps.length) {\n            animationState.currentTimeIndex = index;\n            const timestamp = animationState.timestamps[index];\n            const timeObj = new Date(timestamp);\n            const timeString = `${timeObj.getHours().toString().padStart(2, '0')}:${timeObj.getMinutes().toString().padStart(2, '0')}`;\n            timeSliderValue.textContent = timeString;\n            updateMapVisualizationForTime(timestamp);\n        }\n    });\n}\n\n// Start animation\nfunction startAnimation() {\n    stopAnimation(); // Clear any existing interval\n    \n    if (animationState.timestamps.length === 0) return;\n    \n    const baseDelay = 1000; // 1 second base delay\n    const delay = baseDelay / animationState.speed;\n    \n    animationState.animationInterval = setInterval(() => {\n        if (animationState.currentTimeIndex < animationState.timestamps.length - 1) {\n            animationState.currentTimeIndex++;\n            const timestamp = animationState.timestamps[animationState.currentTimeIndex];\n            updateMapVisualizationForTime(timestamp);\n            \n            // Update slider position\n            const timeObj = new Date(timestamp);\n            const minute = timeObj.getMinutes();\n            document.getElementById('time-slider').value = minute;\n            document.getElementById('time-slider-value').textContent = \n                `${timeObj.getHours().toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n        } else {\n            // Loop back to start\n            animationState.currentTimeIndex = 0;\n            updateMapVisualizationForTime(animationState.timestamps[0]);\n            document.getElementById('time-slider').value = 0;\n            document.getElementById('time-slider-value').textContent = '18:00';\n        }\n    }, delay);\n}\n\n// Stop animation\nfunction stopAnimation() {\n    if (animationState.animationInterval) {\n        clearInterval(animationState.animationInterval);\n        animationState.animationInterval = null;\n    }\n}\n\n// Load license plate image\nasync function loadPlateImage(plateNumber) {\n    if (!plateNumber) return null;\n    \n    // Check cache first\n    if (animationState.plateImages[plateNumber]) {\n        return animationState.plateImages[plateNumber];\n    }\n    \n    try {\n        const img = new Image();\n        img.src = `/assets/plates/${plateNumber}.png`;\n        \n        return new Promise((resolve, reject) => {\n            img.onload = () => {\n                animationState.plateImages[plateNumber] = img;\n                resolve(img);\n            };\n            img.onerror = () => {\n                resolve(null); // Return null if image doesn't exist\n            };\n        });\n    } catch (error) {\n        return null;\n    }\n}\n\n// Update map visualization for a specific time\nasync function updateMapVisualizationForTime(timestamp) {\n    if (!mapContext || !mapImage) {\n        console.warn('Map context or image not ready yet');\n        return;\n    }\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/time/${encodeURIComponent(timestamp)}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error) {\n            console.error('API error:', data.error);\n            return;\n        }\n        \n        if (!data.slots || data.slots.length === 0) {\n            console.log('No slots data for this timestamp');\n            // Still clear and show empty map\n        }\n        \n        // Update time display\n        const timeObj = new Date(data.timestamp);\n        const timeDisplay = document.getElementById('current-time-display');\n        if (timeDisplay) {\n            timeDisplay.textContent = `Time: ${timeObj.toLocaleTimeString()}`;\n        }\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width || 1000;\n        const mapHeight = mapImage.naturalHeight || mapImage.height || 1000;\n        const canvasWidth = mapContext.canvas.width;\n        const canvasHeight = mapContext.canvas.height;\n        const scaleX = canvasWidth / mapWidth;\n        const scaleY = canvasHeight / mapHeight;\n        \n        console.log('Drawing map:', {\n            mapSize: `${mapWidth}x${mapHeight}`,\n            canvasSize: `${canvasWidth}x${canvasHeight}`,\n            scale: `${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`,\n            slots: data.slots ? data.slots.length : 0\n        });\n        \n        // Draw active slots with license plates\n        if (data.slots && data.slots.length > 0) {\n            // First pass: draw all slot borders\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY); // Adaptive slot size\n                    \n                    // Draw slot border\n                    mapContext.strokeStyle = '#FF4444';\n                    mapContext.lineWidth = 2;\n                    mapContext.strokeRect(\n                        x - slotSize / 2,\n                        y - slotSize / 2,\n                        slotSize,\n                        slotSize\n                    );\n                }\n            }\n            \n            // Second pass: load and draw license plates (async)\n            for (const slot of data.slots) {\n                if (slot.x != null && slot.y != null) {\n                    const x = slot.x * scaleX;\n                    const y = slot.y * scaleY;\n                    const slotSize = 40 * Math.min(scaleX, scaleY);\n                    \n                    // Load and draw license plate image if available\n                    if (slot.plate_number) {\n                        const plateImg = await loadPlateImage(slot.plate_number);\n                        if (plateImg) {\n                            // Draw license plate image\n                            const plateSize = slotSize * 0.9;\n                            mapContext.drawImage(\n                                plateImg,\n                                x - plateSize / 2,\n                                y - plateSize / 2,\n                                plateSize,\n                                plateSize\n                            );\n                        }\n                    }\n                    \n                    // Draw slot ID label (on top)\n                    mapContext.fillStyle = '#FFFFFF';\n                    mapContext.strokeStyle = '#000000';\n                    mapContext.lineWidth = 3;\n                    mapContext.font = 'bold 12px Arial';\n                    mapContext.textAlign = 'center';\n                    mapContext.textBaseline = 'top';\n                    mapContext.strokeText(slot.slot_id, x, y - slotSize / 2 - 15);\n                    mapContext.fillText(slot.slot_id, x, y - slotSize / 2 - 15);\n                }\n            }\n        }\n        \n        console.log('Map visualization updated');\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n        console.error('Error details:', error.message);\n    }\n}\n\n// Update map visualization (legacy function for non-animated updates)\nasync function updateMapVisualization() {\n    // If animation is active, don't update here\n    if (animationState.isPlaying && animationState.timestamps.length > 0) {\n        return;\n    }\n    \n    // Otherwise use current data\n    if (!mapContext || !mapImage) return;\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/data/current`);\n        const data = await response.json();\n        \n        if (data.error || !data.slots) return;\n        \n        // Clear canvas\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        \n        // Get map dimensions\n        const mapWidth = mapImage.naturalWidth || mapImage.width;\n        const mapHeight = mapImage.naturalHeight || mapImage.height;\n        const scaleX = mapContext.canvas.width / mapWidth;\n        const scaleY = mapContext.canvas.height / mapHeight;\n        \n        // Draw active slots\n        data.slots.forEach(slot => {\n            if (slot.x != null && slot.y != null) {\n                const x = slot.x * scaleX;\n                const y = slot.y * scaleY;\n                \n                // Draw slot marker\n                mapContext.fillStyle = '#FF4444';\n                mapContext.beginPath();\n                mapContext.arc(x, y, 8, 0, 2 * Math.PI);\n                mapContext.fill();\n                \n                // Draw border\n                mapContext.strokeStyle = '#FFFFFF';\n                mapContext.lineWidth = 2;\n                mapContext.stroke();\n                \n                // Draw slot ID\n                mapContext.fillStyle = '#FFFFFF';\n                mapContext.font = 'bold 10px Arial';\n                mapContext.textAlign = 'center';\n                mapContext.fillText(slot.slot_id, x, y - 12);\n            }\n        });\n        \n    } catch (error) {\n        console.error('Failed to update map visualization:', error);\n    }\n}\n\n// Update API status display\nfunction updateAPIStatus(status, message) {\n    const statusEl = document.getElementById('api-status');\n    statusEl.textContent = message;\n    statusEl.className = `status-value ${status === 'healthy' ? 'success' : 'error'}`;\n}\n\n// Start auto-update cycle\nfunction startAutoUpdate() {\n    // Initial update\n    updateTerminalGuidance();\n    updateForecast();\n    updateMapVisualization();\n    \n    // Set up interval (update every 5 seconds)\n    updateInterval = setInterval(() => {\n        updateTerminalGuidance();\n        updateForecast();\n        updateMapVisualization();\n    }, 5000);\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (updateInterval) {\n        clearInterval(updateInterval);\n    }\n    stopAnimation();\n});\n\n"},{"path":"mini-project-3-team-tiger/frontend/start_server.sh","size":319,"mtime":1765321549862,"ext":"sh","content":"#!/bin/bash\n# Start frontend web server\n# This script ensures the server runs from the correct directory\n\ncd \"$(dirname \"$0\")\"\necho \"Starting frontend web server...\"\necho \"Serving from: $(pwd)\"\necho \"\"\necho \"Open your browser to: http://localhost:8000\"\necho \"Press Ctrl+C to stop\"\necho \"\"\npython3 -m http.server 8000\n\n\n"},{"path":"mini-project-3-team-tiger/frontend/styles.css","size":8977,"mtime":1765320594690,"ext":"css","content":"/* Sky Harbor Airport Ride-Hailing Dashboard Styles */\n/* UI/UX Specialist: Responsive and visually appealing interface */\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1400px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 20px;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\n    overflow: hidden;\n}\n\n/* Header */\n.header {\n    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);\n    color: white;\n    padding: 30px;\n    text-align: center;\n}\n\n.header h1 {\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n    font-weight: 700;\n}\n\n.header h2 {\n    font-size: 1.3rem;\n    font-weight: 300;\n    opacity: 0.9;\n}\n\n/* Terminal Tabs */\n.terminal-tabs {\n    display: flex;\n    gap: 10px;\n    padding: 20px;\n    background: #f5f5f5;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.tab-button {\n    flex: 1;\n    padding: 15px 30px;\n    font-size: 1.1rem;\n    font-weight: 600;\n    border: none;\n    border-radius: 10px;\n    background: white;\n    color: #666;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.tab-button:hover {\n    background: #e3f2fd;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);\n}\n\n.tab-button.active {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);\n}\n\n/* Guidance Banner */\n.guidance-banner {\n    margin: 20px;\n    padding: 25px;\n    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);\n    border-radius: 15px;\n    color: white;\n    box-shadow: 0 5px 20px rgba(79, 172, 254, 0.3);\n    animation: slideIn 0.5s ease;\n}\n\n@keyframes slideIn {\n    from {\n        opacity: 0;\n        transform: translateY(-20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.banner-content {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    margin-bottom: 15px;\n}\n\n.banner-icon {\n    font-size: 2rem;\n}\n\n.guidance-message {\n    font-size: 1.4rem;\n    font-weight: 600;\n    flex: 1;\n}\n\n.banner-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n    gap: 15px;\n    margin-top: 15px;\n    padding-top: 15px;\n    border-top: 1px solid rgba(255, 255, 255, 0.3);\n}\n\n.detail-item {\n    display: flex;\n    flex-direction: column;\n    gap: 5px;\n}\n\n.detail-label {\n    font-size: 0.9rem;\n    opacity: 0.9;\n}\n\n.detail-value {\n    font-size: 1.2rem;\n    font-weight: 700;\n}\n\n/* Forecast Section */\n.forecast-section {\n    padding: 30px;\n    background: #fafafa;\n}\n\n.forecast-section h3 {\n    font-size: 1.8rem;\n    margin-bottom: 25px;\n    color: #333;\n    text-align: center;\n}\n\n.forecast-cards {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 25px;\n}\n\n.forecast-card {\n    background: white;\n    border-radius: 15px;\n    padding: 25px;\n    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n    transition: transform 0.3s ease, box-shadow 0.3s ease;\n}\n\n.forecast-card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);\n}\n\n.card-header {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #f0f0f0;\n}\n\n.card-icon {\n    font-size: 1.8rem;\n}\n\n.card-title {\n    font-size: 1.3rem;\n    font-weight: 600;\n    color: #333;\n}\n\n.card-content {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n}\n\n.current-value, .forecast-value {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.value-label {\n    font-size: 0.95rem;\n    color: #666;\n}\n\n.value-amount {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: #2a5298;\n}\n\n/* Trend Badge */\n.trend-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px 15px;\n    border-radius: 20px;\n    font-weight: 600;\n    font-size: 0.9rem;\n    width: fit-content;\n}\n\n.trend-badge.flat {\n    background: #e0e0e0;\n    color: #666;\n}\n\n.trend-badge.up {\n    background: #ffebee;\n    color: #c62828;\n}\n\n.trend-badge.down {\n    background: #e8f5e9;\n    color: #2e7d32;\n}\n\n.trend-icon {\n    font-size: 1.2rem;\n}\n\n.trend-badge.up .trend-icon::before {\n    content: \"‚Üë\";\n}\n\n.trend-badge.down .trend-icon::before {\n    content: \"‚Üì\";\n}\n\n.trend-badge.flat .trend-icon::before {\n    content: \"‚Üí\";\n}\n\n/* Sparkline Container */\n.sparkline-container {\n    margin-top: 10px;\n    padding: 10px;\n    background: #f8f9fa;\n    border-radius: 8px;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n/* Map Section */\n.map-section {\n    padding: 30px;\n    background: white;\n}\n\n.map-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 15px;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.map-section h3 {\n    font-size: 1.8rem;\n    margin: 0;\n    color: #333;\n}\n\n.animation-controls {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.control-btn {\n    padding: 8px 16px;\n    font-size: 0.9rem;\n    font-weight: 600;\n    border: none;\n    border-radius: 8px;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.control-btn:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 10px rgba(102, 126, 234, 0.3);\n}\n\n.control-btn:active {\n    transform: translateY(0);\n}\n\n.speed-indicator {\n    padding: 8px 12px;\n    font-weight: 700;\n    color: #333;\n    background: #f0f0f0;\n    border-radius: 8px;\n    min-width: 40px;\n    text-align: center;\n}\n\n.time-display {\n    text-align: center;\n    margin-bottom: 15px;\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: #2a5298;\n    padding: 10px;\n    background: #e3f2fd;\n    border-radius: 8px;\n}\n\n.time-slider-container {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    margin-bottom: 20px;\n    padding: 15px;\n    background: #f5f5f5;\n    border-radius: 8px;\n}\n\n.time-slider-container label {\n    font-weight: 600;\n    color: #333;\n}\n\n.time-slider {\n    flex: 1;\n    height: 8px;\n    border-radius: 5px;\n    background: #ddd;\n    outline: none;\n    -webkit-appearance: none;\n}\n\n.time-slider::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    appearance: none;\n    width: 20px;\n    height: 20px;\n    border-radius: 50%;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    cursor: pointer;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n}\n\n.time-slider::-moz-range-thumb {\n    width: 20px;\n    height: 20px;\n    border-radius: 50%;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    cursor: pointer;\n    border: none;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n}\n\n#time-slider-value {\n    font-weight: 700;\n    color: #2a5298;\n    min-width: 50px;\n    text-align: center;\n}\n\n.map-container {\n    position: relative;\n    width: 100%;\n    max-width: 1000px;\n    margin: 0 auto;\n    border-radius: 15px;\n    overflow: hidden;\n    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);\n}\n\n.map-image {\n    width: 100%;\n    height: auto;\n    display: block;\n}\n\n.map-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n}\n\n/* Status Footer */\n.status-footer {\n    display: flex;\n    justify-content: space-around;\n    padding: 20px;\n    background: #f5f5f5;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n    gap: 20px;\n}\n\n.status-item {\n    display: flex;\n    gap: 10px;\n    align-items: center;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #666;\n}\n\n.status-value {\n    color: #333;\n    font-weight: 500;\n}\n\n.status-value.success {\n    color: #2e7d32;\n}\n\n.status-value.error {\n    color: #c62828;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 1.8rem;\n    }\n\n    .header h2 {\n        font-size: 1rem;\n    }\n\n    .guidance-message {\n        font-size: 1.1rem;\n    }\n\n    .forecast-cards {\n        grid-template-columns: 1fr;\n    }\n\n    .banner-details {\n        grid-template-columns: 1fr;\n    }\n\n    .terminal-tabs {\n        flex-direction: column;\n    }\n\n    .tab-button {\n        width: 100%;\n    }\n}\n\n@media (max-width: 480px) {\n    body {\n        padding: 10px;\n    }\n\n    .container {\n        border-radius: 10px;\n    }\n\n    .header {\n        padding: 20px;\n    }\n\n    .forecast-section,\n    .map-section {\n        padding: 20px;\n    }\n}\n\n/* Loading Animation */\n@keyframes pulse {\n    0%, 100% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0.5;\n    }\n}\n\n.loading {\n    animation: pulse 1.5s ease-in-out infinite;\n}\n\n"},{"path":"mini-project-3-team-tiger/frontend/index.html","size":6786,"mtime":1765321549862,"ext":"html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Sky Harbor Airport - Ride-Hailing Dashboard</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <!-- Header -->\n        <header class=\"header\">\n            <h1>‚úàÔ∏è Sky Harbor Airport</h1>\n            <h2>Ride-Hailing Display Dashboard</h2>\n        </header>\n\n        <!-- Terminal Selection Tabs -->\n        <div class=\"terminal-tabs\">\n            <button class=\"tab-button active\" data-terminal=\"Terminal 3\">Terminal 3</button>\n            <button class=\"tab-button\" data-terminal=\"Terminal 4\">Terminal 4</button>\n        </div>\n\n        <!-- Terminal Guidance Banner -->\n        <div id=\"guidance-banner\" class=\"guidance-banner\">\n            <div class=\"banner-content\">\n                <span class=\"banner-icon\">üìç</span>\n                <span id=\"guidance-message\" class=\"guidance-message\">Loading guidance...</span>\n            </div>\n            <div class=\"banner-details\">\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Zone:</span>\n                    <span id=\"zone-name\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Walking Time:</span>\n                    <span id=\"walking-time\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Estimated Wait:</span>\n                    <span id=\"estimated-wait\" class=\"detail-value\">-</span>\n                </div>\n                <div class=\"detail-item\">\n                    <span class=\"detail-label\">Available Slots:</span>\n                    <span id=\"available-slots\" class=\"detail-value\">-</span>\n                </div>\n            </div>\n        </div>\n\n        <!-- Price & Wait Forecast Section -->\n        <div class=\"forecast-section\">\n            <h3>Price & Wait Forecast (15-30 min horizon)</h3>\n            \n            <div class=\"forecast-cards\">\n                <!-- Price Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">üí∞</span>\n                        <span class=\"card-title\">Price Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-price\" class=\"value-amount\">$--</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"price-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"price-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Wait Time Forecast Card -->\n                <div class=\"forecast-card\">\n                    <div class=\"card-header\">\n                        <span class=\"card-icon\">‚è±Ô∏è</span>\n                        <span class=\"card-title\">Wait Time Forecast</span>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"current-value\">\n                            <span class=\"value-label\">Current:</span>\n                            <span id=\"current-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"forecast-value\">\n                            <span class=\"value-label\">Forecast:</span>\n                            <span id=\"forecast-wait\" class=\"value-amount\">-- min</span>\n                        </div>\n                        <div class=\"trend-badge\" id=\"wait-trend-badge\">\n                            <span class=\"trend-icon\">‚Üí</span>\n                            <span class=\"trend-text\">Flat</span>\n                        </div>\n                        <div class=\"sparkline-container\">\n                            <canvas id=\"wait-sparkline\" width=\"200\" height=\"40\"></canvas>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- Map Visualization -->\n        <div class=\"map-section\">\n            <div class=\"map-header\">\n                <h3>Live Map View - Parking Lot Status (6:00 PM - 6:59 PM)</h3>\n                <div class=\"animation-controls\">\n                    <button id=\"play-pause-btn\" class=\"control-btn\">‚è∏Ô∏è Pause</button>\n                    <button id=\"speed-down-btn\" class=\"control-btn\">‚è™ Slow</button>\n                    <span id=\"speed-indicator\" class=\"speed-indicator\">1x</span>\n                    <button id=\"speed-up-btn\" class=\"control-btn\">‚è© Fast</button>\n                    <button id=\"reset-btn\" class=\"control-btn\">üîÑ Reset</button>\n                </div>\n            </div>\n            <div class=\"time-display\">\n                <span id=\"current-time-display\">Time: --:--:--</span>\n            </div>\n            <div class=\"time-slider-container\">\n                <label for=\"time-slider\">Select Time:</label>\n                <input type=\"range\" id=\"time-slider\" min=\"0\" max=\"59\" value=\"0\" class=\"time-slider\">\n                <span id=\"time-slider-value\">18:00</span>\n            </div>\n            <div class=\"map-container\">\n                <img id=\"map-image\" src=\"/assets/map.png\" alt=\"Airport Map\" class=\"map-image\" \n                     onerror=\"console.error('Failed to load map image. Path:', this.src); this.style.display='none';\">\n                <canvas id=\"map-overlay\" class=\"map-overlay\"></canvas>\n            </div>\n        </div>\n\n        <!-- Status Footer -->\n        <footer class=\"status-footer\">\n            <div class=\"status-item\">\n                <span class=\"status-label\">Last Updated:</span>\n                <span id=\"last-updated\" class=\"status-value\">-</span>\n            </div>\n            <div class=\"status-item\">\n                <span class=\"status-label\">API Status:</span>\n                <span id=\"api-status\" class=\"status-value\">Checking...</span>\n            </div>\n        </footer>\n    </div>\n\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n"},{"path":"mini-project-3-team-tiger/test_backend.py","size":1815,"mtime":1765320986392,"ext":"py","content":"#!/usr/bin/env python3\n\"\"\"Quick test script to verify backend setup\"\"\"\n\nimport sys\nimport os\n\n# Add backend to path\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), 'backend'))\n\ntry:\n    from app import app, get_data, DATA_FILE\n    import pandas as pd\n    \n    print(\"‚úì Backend imports successful\")\n    print(f\"‚úì Data file path: {DATA_FILE}\")\n    print(f\"‚úì Data file exists: {os.path.exists(DATA_FILE)}\")\n    \n    # Test data loading\n    df = get_data()\n    print(f\"‚úì Data loaded: {len(df)} rows\")\n    print(f\"‚úì Columns: {list(df.columns)}\")\n    \n    # Test unique timestamps\n    if not df.empty:\n        unique_times = sorted(df['current_time'].unique())\n        print(f\"‚úì Unique timestamps: {len(unique_times)}\")\n        print(f\"‚úì Time range: {unique_times[0]} to {unique_times[-1]}\")\n        \n        # Test filtering for 6 PM\n        df['time_only'] = df['current_time'].dt.time\n        from datetime import time\n        df_filtered = df[(df['time_only'] >= time(18, 0)) & (df['time_only'] <= time(18, 59))]\n        print(f\"‚úì 6 PM data: {len(df_filtered)} rows\")\n        \n        if len(df_filtered) > 0:\n            sample = df_filtered[df_filtered['x'].notna() & df_filtered['y'].notna()].head(1)\n            if len(sample) > 0:\n                print(f\"‚úì Sample slot: ID={sample.iloc[0]['slot_id']}, x={sample.iloc[0]['x']}, y={sample.iloc[0]['y']}\")\n                if pd.notna(sample.iloc[0].get('plate_number')):\n                    print(f\"‚úì Sample plate: {sample.iloc[0]['plate_number']}\")\n    \n    print(\"\\n‚úì All tests passed! Backend should work.\")\n    print(\"\\nTo start the backend server:\")\n    print(\"  cd backend\")\n    print(\"  python3 app.py\")\n    \nexcept Exception as e:\n    print(f\"‚úó Error: {e}\")\n    import traceback\n    traceback.print_exc()\n    sys.exit(1)\n\n"},{"path":"mini-project-3-team-tiger/assets/plates/SPQBUSK.png","size":120662,"mtime":1765319267397,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/MGGNAV.png","size":86897,"mtime":1765319267380,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/map.png","size":110650,"mtime":1765319267335,"ext":"png"},{"path":"mini-project-3-team-tiger/.github/.keep","size":0,"mtime":1765318988809,"ext":""},{"path":"mini-project-3-team-tiger/start_frontend.sh","size":363,"mtime":1765321549862,"ext":"sh","content":"#!/bin/bash\n# Start frontend web server from project root\n# This allows access to both frontend/ and assets/ directories\n\ncd \"$(dirname \"$0\")\"\necho \"Starting frontend web server from project root...\"\necho \"Serving from: $(pwd)\"\necho \"\"\necho \"Open your browser to: http://localhost:8000/frontend/\"\necho \"Press Ctrl+C to stop\"\necho \"\"\npython3 -m http.server 8000\n\n\n"},{"path":"mini-project-3-team-tiger/.gitignore","size":312,"mtime":1765319489603,"ext":""},{"path":"mini-project-3-team-tiger/dashboard.py","size":12077,"mtime":1765320594690,"ext":"py","content":"\"\"\"\nStreamlit Dashboard for Ride-Hailing Display at Sky Harbor Airport\nTime series visualization of parking lot status from 6:00 PM to 6:59 PM\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.patches import Rectangle, Circle, Patch\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport numpy as np\nfrom datetime import datetime, time\nimport os\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Sky Harbor Airport - Ride-Hailing Dashboard\",\n    page_icon=\"‚úàÔ∏è\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Paths\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\nDATA_FILE = os.path.join(BASE_DIR, 'assets', 'ride_hailing.xlsx')\nMAP_FILE = os.path.join(BASE_DIR, 'assets', 'map.png')\nPLATES_DIR = os.path.join(BASE_DIR, 'assets', 'plates')\n\n# Load data\n@st.cache_data\ndef load_data():\n    \"\"\"Load the ride_hailing dataset from the first sheet\"\"\"\n    try:\n        df = pd.read_excel(DATA_FILE, sheet_name=0)\n        df['current_time'] = pd.to_datetime(df['current_time'])\n        return df\n    except Exception as e:\n        st.error(f\"Error loading data: {e}\")\n        return pd.DataFrame()\n\n# Load background image\n@st.cache_data\ndef load_map():\n    \"\"\"Load the map background image\"\"\"\n    try:\n        img = Image.open(MAP_FILE)\n        return img, img.size\n    except Exception as e:\n        st.error(f\"Error loading map: {e}\")\n        return None, None\n\n# Load plate image\ndef load_plate_image(plate_number):\n    \"\"\"Load license plate image if available\"\"\"\n    if pd.isna(plate_number) or plate_number is None:\n        return None\n    plate_path = os.path.join(PLATES_DIR, f\"{str(plate_number).strip()}.png\")\n    if os.path.exists(plate_path):\n        try:\n            return Image.open(plate_path)\n        except:\n            return None\n    return None\n\n# Initialize session state\nif 'is_playing' not in st.session_state:\n    st.session_state.is_playing = False\nif 'current_time_index' not in st.session_state:\n    st.session_state.current_time_index = 0\nif 'reset_flag' not in st.session_state:\n    st.session_state.reset_flag = False\n\n# Load data\ndf = load_data()\nmap_img, map_size = load_map()\n\nif df.empty or map_img is None:\n    st.error(\"Failed to load data or map image. Please check the files.\")\n    st.stop()\n\n# Get map dimensions for scaling\nif map_size:\n    map_width, map_height = map_size\nelse:\n    map_width, map_height = 1000, 1000  # Default dimensions\n\n# Process time column - extract time component\ndf['time_only'] = df['current_time'].dt.time\n\n# Filter data for 6:00 PM to 6:59 PM\nstart_time = time(18, 0)  # 6:00 PM\nend_time = time(18, 59)   # 6:59 PM\n\ndf_filtered = df[\n    (df['time_only'] >= start_time) & \n    (df['time_only'] <= end_time)\n].copy()\n\nif df_filtered.empty:\n    st.warning(\"No data found for 6:00 PM to 6:59 PM\")\n    st.write(\"Sample data:\", df.head())\n    st.stop()\n\n# Sort by time\ndf_filtered = df_filtered.sort_values('current_time').reset_index(drop=True)\n\n# Get unique times for slider (one per minute)\nunique_times = sorted(df_filtered['time_only'].unique())\nunique_datetimes = sorted(df_filtered['current_time'].unique())\n\n# Main layout\nst.title(\"‚úàÔ∏è Sky Harbor Airport - Ride-Hailing Dashboard\")\nst.markdown(\"**Time Range: 6:00 PM - 6:59 PM**\")\n\n# Sidebar for controls and ride details\nwith st.sidebar:\n    st.header(\"üéÆ Controls\")\n    \n    # Time slider\n    if len(unique_times) > 0:\n        # Create time labels for display\n        time_labels = [t.strftime('%H:%M') for t in unique_times]\n        \n        time_index = st.slider(\n            \"Select Time (Minutes)\",\n            min_value=0,\n            max_value=len(unique_times) - 1,\n            value=st.session_state.current_time_index,\n            format=\"%s\",\n            help=f\"Time range: {unique_times[0].strftime('%H:%M')} to {unique_times[-1].strftime('%H:%M')}\"\n        )\n        st.session_state.current_time_index = time_index\n        \n        # Display selected time\n        selected_time = unique_times[time_index]\n        st.write(f\"**Selected Time:** {selected_time.strftime('%H:%M:%S')}\")\n    else:\n        st.warning(\"No time data available\")\n        time_index = 0\n    \n    st.divider()\n    \n    # Control buttons\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        if st.button(\"‚ñ∂Ô∏è Start\", use_container_width=True, type=\"primary\"):\n            st.session_state.is_playing = True\n            st.rerun()\n    \n    with col2:\n        if st.button(\"‚è∏Ô∏è Stop\", use_container_width=True):\n            st.session_state.is_playing = False\n            st.rerun()\n    \n    if st.button(\"üîÑ Reset\", use_container_width=True):\n        st.session_state.current_time_index = 0\n        st.session_state.is_playing = False\n        st.session_state.reset_flag = True\n        st.rerun()\n    \n    st.divider()\n    \n    # Display current time metric\n    if len(unique_times) > 0 and time_index < len(unique_times):\n        current_time = unique_times[time_index]\n        st.metric(\"Current Time\", current_time.strftime(\"%H:%M:%S\"))\n    \n    st.divider()\n    st.header(\"üìã Ride Details\")\n    \n    # Get current time data\n    if len(unique_times) > 0 and time_index < len(unique_times):\n        current_time = unique_times[time_index]\n        current_data = df_filtered[df_filtered['time_only'] == current_time]\n        \n        # Filter out rows with NaN positions (empty slots)\n        current_data_active = current_data[\n            current_data['x'].notna() & current_data['y'].notna()\n        ].copy()\n        \n        st.metric(\"Active Slots\", len(current_data_active))\n        st.metric(\"Total Slots\", len(current_data))\n        \n        # Display ride details\n        if len(current_data_active) > 0:\n            for idx, row in current_data_active.iterrows():\n                with st.expander(f\"üöó Slot {int(row['slot_id'])}\", expanded=False):\n                    # Basic information\n                    st.write(f\"**Time:** {row['time_only'].strftime('%H:%M:%S')}\")\n                    st.write(f\"**Slot ID:** {int(row['slot_id'])}\")\n                    st.write(f\"**Position:** ({row['x']:.1f}, {row['y']:.1f})\")\n                    \n                    # License plate image\n                    if pd.notna(row.get('plate_number')):\n                        plate_number = str(row['plate_number']).strip()\n                        plate_img = load_plate_image(plate_number)\n                        if plate_img:\n                            st.image(plate_img, caption=f\"License Plate: {plate_number}\", width=200)\n                        else:\n                            st.write(f\"**License Plate:** {plate_number}\")\n                    \n                    # Additional ride information\n                    if pd.notna(row.get('reservation_id')):\n                        st.write(f\"**Reservation ID:** {row['reservation_id']}\")\n                    if pd.notna(row.get('rider_id')):\n                        st.write(f\"**Rider ID:** {row['rider_id']}\")\n                    if pd.notna(row.get('driver_id')):\n                        st.write(f\"**Driver ID:** {row['driver_id']}\")\n                    if pd.notna(row.get('service')):\n                        st.write(f\"**Service:** {row['service']}\")\n        else:\n            st.info(\"No active slots at this time\")\n\n# Main visualization area\nif len(unique_times) > 0 and time_index < len(unique_times):\n    current_time = unique_times[time_index]\n    current_data = df_filtered[df_filtered['time_only'] == current_time]\n    \n    # Filter active slots (with valid positions)\n    current_data_active = current_data[\n        current_data['x'].notna() & current_data['y'].notna()\n    ].copy()\n    \n    # Create visualization\n    fig, ax = plt.subplots(figsize=(14, 12))\n    \n    # Display background map\n    if map_img:\n        ax.imshow(map_img, extent=[0, map_width, map_height, 0], \n                 aspect='auto', alpha=1.0, origin='upper', interpolation='nearest')\n    \n    # Plot parking slots with license plates\n    if len(current_data_active) > 0:\n        for idx, row in current_data_active.iterrows():\n            slot_id = int(row['slot_id'])\n            x = float(row['x'])\n            y = float(row['y'])\n            \n            # Draw parking slot border (scaled based on map size)\n            slot_size = min(map_width, map_height) / 40  # Adaptive slot size\n            \n            # Load license plate image\n            plate_img = None\n            if pd.notna(row.get('plate_number')):\n                plate_number = str(row['plate_number']).strip()\n                plate_img = load_plate_image(plate_number)\n            \n            # Draw border\n            rect = Rectangle((x - slot_size/2, y - slot_size/2), \n                           slot_size, slot_size,\n                           linewidth=2, edgecolor='#FF4444', \n                           facecolor='none', alpha=1.0)\n            ax.add_patch(rect)\n            \n            # Draw license plate image if available\n            if plate_img:\n                # Calculate plate size in data coordinates\n                plate_size_data = slot_size * 0.95\n                \n                # Resize plate image for quality\n                target_pixels = 200\n                plate_img_resized = plate_img.copy()\n                plate_img_resized.thumbnail((target_pixels, target_pixels), Image.Resampling.LANCZOS)\n                \n                # Convert to numpy array\n                plate_array = np.array(plate_img_resized)\n                \n                # Calculate extent for imshow\n                left = x - plate_size_data / 2\n                right = x + plate_size_data / 2\n                bottom = y - plate_size_data / 2\n                top = y + plate_size_data / 2\n                \n                # Display the plate image\n                ax.imshow(plate_array, extent=[left, right, bottom, top], \n                         aspect='auto', alpha=1.0, interpolation='nearest', \n                         origin='upper', zorder=5)\n            \n            # Add slot ID label\n            font_size = max(8, min(map_width, map_height) / 120)\n            label_x = x - slot_size/2 + 3\n            label_y = y - slot_size/2 + 3\n            ax.text(label_x, label_y, str(slot_id), ha='left', va='top', \n                   fontsize=font_size, fontweight='bold', \n                   color='white', rotation=0,\n                   bbox=dict(boxstyle='round,pad=0.2', \n                   facecolor='black', alpha=1.0, edgecolor='red', linewidth=1),\n                   zorder=100)\n    \n    # Set axis limits based on map dimensions\n    ax.set_xlim(0, map_width)\n    ax.set_ylim(map_height, 0)  # Invert Y-axis to match image coordinates\n    \n    ax.set_title(f\"Parking Lot Status - {current_time.strftime('%H:%M:%S')}\", \n                fontsize=20, fontweight='bold', pad=20)\n    ax.set_xlabel(\"X Position\", fontsize=14)\n    ax.set_ylabel(\"Y Position\", fontsize=14)\n    ax.grid(True, alpha=0.2, linestyle='--', linewidth=0.5)\n    \n    # Add legend\n    from matplotlib.patches import Patch\n    legend_elements = [\n        Patch(facecolor='none', edgecolor='#FF4444', linewidth=2, label='Occupied Slot'),\n    ]\n    ax.legend(handles=legend_elements, loc='upper right', fontsize=11, framealpha=1.0)\n    \n    plt.tight_layout()\n    st.pyplot(fig, use_container_width=True)\n    \n    # Auto-play functionality\n    if st.session_state.is_playing:\n        if st.session_state.current_time_index < len(unique_times) - 1:\n            # Show playing status\n            status_placeholder = st.empty()\n            status_placeholder.info(\"‚è© Playing animation...\")\n            # Small delay before rerun\n            import time as time_module\n            time_module.sleep(0.5)  # 0.5 second delay between frames\n            st.session_state.current_time_index += 1\n            st.rerun()\n        else:\n            st.session_state.is_playing = False\n            st.success(\"‚úÖ Reached end of time range\")\n\nelse:\n    st.warning(\"No data available for visualization\")\n\n"},{"path":"mini-project-3-team-tiger/README.md","size":7603,"mtime":1765321549863,"ext":"md","content":"# Mini Project 3: Ride-Hailing Display/Dashboard at Sky Harbor Airport\n\n[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n\n## Project Overview\n\nThis project implements a real-time ride-hailing display dashboard for Sky Harbor Airport in Phoenix, featuring terminal-aware pickup guidance and price/wait time forecasting capabilities.\n\n## Features\n\n### 1. Terminal-Aware Pickup Guidance\n- Maps Terminals 3 and 4 to their respective pickup zones\n- Displays walking times and live ETA/availability\n- Shows dynamic banner: \"From Terminal X: Head to Zone Y. Pickup in Z minutes.\"\n- Real-time slot availability tracking\n\n### 2. Price + Wait Forecast (15-30 min horizon)\n- Uses rolling averages and slope calculations to forecast surge pricing and wait times\n- Displays trend badges (up/down/flat) with color coding\n- Provides compact sparkline visualizations\n- Historical data analysis for accurate predictions\n\n## Project Structure\n\n```\nmini-project-3-team-tiger/\n‚îú‚îÄ‚îÄ assets/                 # Data and image assets\n‚îÇ   ‚îú‚îÄ‚îÄ map.png            # Airport map background\n‚îÇ   ‚îú‚îÄ‚îÄ ride_hailing.xlsx  # Ride data\n‚îÇ   ‚îî‚îÄ‚îÄ plates/            # License plate images\n‚îú‚îÄ‚îÄ backend/               # Backend API (Technical Lead)\n‚îÇ   ‚îú‚îÄ‚îÄ app.py            # Flask API server\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt  # Python dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ start_server.sh   # Server startup script\n‚îú‚îÄ‚îÄ frontend/             # Frontend UI (UI/UX Specialist)\n‚îÇ   ‚îú‚îÄ‚îÄ index.html        # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css        # Responsive styling\n‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend logic\n‚îú‚îÄ‚îÄ dashboard.py         # Streamlit dashboard (standalone)\n‚îú‚îÄ‚îÄ requirements.txt    # Python dependencies for Streamlit\n‚îú‚îÄ‚îÄ .gitignore           # Git exclusions\n‚îî‚îÄ‚îÄ README.md           # This file\n```\n\n## Setup Instructions\n\n### Prerequisites\n- Python 3.8 or higher\n- pip (Python package manager)\n- Modern web browser (Chrome, Firefox, Safari, Edge)\n\n### Option 1: Streamlit Dashboard (Recommended - Standalone)\n\nThe Streamlit dashboard is a complete standalone solution that doesn't require separate backend/frontend setup.\n\n1. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n   \n   **Note:** If you get permission errors, you may need to use:\n   ```bash\n   pip3 install --user -r requirements.txt\n   ```\n\n2. Run the Streamlit dashboard:\n   ```bash\n   streamlit run dashboard.py\n   ```\n   \n   The dashboard will automatically open in your browser at `http://localhost:8501`\n\n### Option 2: Flask Backend + HTML Frontend\n\nIf you prefer the separate backend/frontend architecture:\n\n#### Backend Setup\n\n1. Navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. Install dependencies:\n   ```bash\n   pip3 install -r requirements.txt\n   ```\n\n3. Start the backend server:\n   ```bash\n   python3 app.py\n   ```\n   \n   The API will be available at `http://localhost:5001`\n\n#### Frontend Setup\n\n1. The frontend is a static HTML/CSS/JavaScript application. No build step required.\n\n2. **IMPORTANT:** You must use a local web server (not just opening the file directly) due to CORS restrictions.\n\n   **Option A: Python HTTP Server (Recommended)**\n   ```bash\n   cd frontend\n   python3 -m http.server 8000\n   ```\n   Then open `http://localhost:8000` in your browser.\n\n   **Option B: VS Code Live Server**\n   - Install the \"Live Server\" extension\n   - Right-click on `index.html` and select \"Open with Live Server\"\n\n   **Option C: Node.js http-server**\n   ```bash\n   npx http-server frontend -p 8000\n   ```\n\n## Quick Start Guide\n\n### Streamlit Dashboard (Easiest)\n```bash\nstreamlit run dashboard.py\n```\n\n### Flask + HTML Frontend\n1. **Terminal 1 - Start Backend:**\n   ```bash\n   cd backend\n   python3 app.py\n   ```\n   You should see: \"Starting Backend API Server...\" and \"Running on http://0.0.0.0:5001\"\n\n2. **Terminal 2 - Start Frontend Server:**\n   \n   **IMPORTANT:** Run the server from the project root (not from frontend/):\n   ```bash\n   cd /Users/felixisaac123/Desktop/MiniProject3/mini-project-3-team-tiger\n   python3 -m http.server 8000\n   ```\n   \n   Or use the startup script:\n   ```bash\n   ./start_frontend.sh\n   ```\n\n3. **Open Browser:**\n   - Navigate to `http://localhost:8000/frontend/`\n   - **Note:** The URL must include `/frontend/` at the end!\n   - The dashboard should load and connect to the backend automatically\n\n## Troubleshooting\n\n### \"Unable to load guidance\" Error\n\nIf you see this error, it means the frontend cannot connect to the backend. Check:\n\n1. **Is the backend running?**\n   - Look for the Flask server output in your terminal\n   - Should show \"Running on http://0.0.0.0:5000\"\n\n2. **Are you using a web server for the frontend?**\n   - Opening `index.html` directly (file://) will cause CORS errors\n   - You MUST use a local web server (see Frontend Setup above)\n\n3. **Check the browser console:**\n   - Press F12 to open developer tools\n   - Look for errors in the Console tab\n   - Check the Network tab to see if API calls are failing\n\n4. **Test the backend directly:**\n   ```bash\n   curl http://localhost:5001/api/health\n   ```\n   Should return: `{\"status\":\"healthy\",\"message\":\"Backend API is running\"}`\n\n### Backend won't start\n\n- Make sure all dependencies are installed: `pip3 install -r requirements.txt`\n- Check that Python 3.8+ is installed: `python3 --version`\n- Verify the data file exists: `ls assets/ride_hailing.xlsx`\n\n### Port already in use\n\nThe backend uses port 5001 by default to avoid conflicts with macOS AirPlay Receiver (which uses port 5000). If port 5001 is also in use:\n- Change the port in `backend/app.py`: `app.run(debug=True, port=5002, ...)`\n- Update `frontend/app.js`: Change `API_BASE_URL` to use the new port\n\n## API Endpoints\n\n### Health Check\n- `GET /api/health` - Check API status\n\n### Terminal Guidance\n- `GET /api/terminal/guidance?terminal=Terminal 3` - Get pickup guidance for a terminal\n\n### Forecast\n- `GET /api/forecast/price-wait` - Get price and wait time forecast\n\n### Data\n- `GET /api/data/current` - Get current ride data\n- `GET /api/data/timeseries` - Get time series data\n\n## Usage\n\n1. Start the backend server (see Backend Setup)\n2. Start a local web server for the frontend (see Frontend Setup)\n3. Open the frontend URL in your browser\n4. Select a terminal (Terminal 3 or Terminal 4) using the tabs\n5. View the guidance banner with pickup instructions\n6. Monitor price and wait time forecasts with trend indicators\n7. Observe the live map visualization\n\n## Role Separation\n\nThis project maintains strict role separation:\n\n- **Backend (Technical Lead)**: All backend code is in `backend/` directory\n  - Data processing from `ride_hailing.xlsx`\n  - API routing and business logic\n  - Forecasting algorithms\n\n- **Frontend (UI/UX Specialist)**: All frontend code is in `frontend/` directory\n  - Responsive, visually appealing interface\n  - User interaction and visualization\n  - API integration\n\n## Technologies Used\n\n- **Backend**: Flask, Pandas, NumPy\n- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)\n- **Data**: Excel (openpyxl)\n\n## Development Notes\n\n- The dashboard auto-updates every 5 seconds\n- Terminal guidance is calculated based on nearest available slots\n- Forecasts use rolling averages and linear regression for trend analysis\n- Sparklines provide visual trend indicators\n\n## License\n\nThis project is for educational purposes as part of CIS541 Data Visualization course.\n"},{"path":"mini-project-3-team-tiger/assets/plates/C83S708.png","size":251088,"mtime":1765319267346,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/GIX3162.png","size":184369,"mtime":1765319267363,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/KTDPNX4.png","size":87454,"mtime":1765319267374,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/AE2DUT0.png","size":120363,"mtime":1765319267342,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/ZGYDJ5C.png","size":89532,"mtime":1765319267417,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/S3R7YP8.png","size":244654,"mtime":1765319267396,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/S1CWQEC.png","size":89498,"mtime":1765319267394,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/PPX97K.png","size":139610,"mtime":1765319267390,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/BUHUC1.png","size":117532,"mtime":1765319267345,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/B7F5T1Y.png","size":248043,"mtime":1765319267343,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/SQUCQ1.png","size":140293,"mtime":1765319267398,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/R53DE3X.png","size":248527,"mtime":1765319267393,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/XB8PYW.png","size":139192,"mtime":1765319267410,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/YY1PS2.png","size":236611,"mtime":1765319267417,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/JN2DF6.png","size":136942,"mtime":1765319267369,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/DV1K2Z.png","size":177258,"mtime":1765319267356,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/XP82WDL.png","size":243721,"mtime":1765319267415,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/FEEN6D3.png","size":235557,"mtime":1765319267361,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/ALQWNF8.png","size":140989,"mtime":1765319267342,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/BQD3QCC.png","size":139180,"mtime":1765319267344,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/WB28BTE.png","size":88148,"mtime":1765319267407,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/HLTLM1.png","size":130915,"mtime":1765319267366,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/KK5UTE0.png","size":137813,"mtime":1765319267373,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/X7M262S.png","size":143047,"mtime":1765319267409,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/YGYHQM3.png","size":242183,"mtime":1765319267415,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/PJ5RM4.png","size":120211,"mtime":1765319267389,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/BC9EGM.png","size":121179,"mtime":1765319267344,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/UPS7402.png","size":186223,"mtime":1765319267401,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/JXPN4TF.png","size":137857,"mtime":1765319267370,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/WASDD1C.png","size":184748,"mtime":1765319267407,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/H5BFXQR.png","size":120260,"mtime":1765319267365,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/A8EFRA5.png","size":138824,"mtime":1765319267341,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/X9A1NUG.png","size":89290,"mtime":1765319267409,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/M2GC6BR.png","size":142782,"mtime":1765319267379,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/K5RM40X.png","size":184771,"mtime":1765319267372,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/KGYDFK.png","size":85354,"mtime":1765319267373,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/PXAVN0E.png","size":184193,"mtime":1765319267390,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/XFCWC9.png","size":180415,"mtime":1765319267412,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/WEBGFW1.png","size":86011,"mtime":1765319267408,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/EYELGK.png","size":83642,"mtime":1765319267358,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/MHKVP5.png","size":120192,"mtime":1765319267381,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/PKS29HK.png","size":242629,"mtime":1765319267389,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/NSTQGMR.png","size":184318,"mtime":1765319267385,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/UY767S.png","size":138706,"mtime":1765319267402,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/UUNJPK1.png","size":136920,"mtime":1765319267402,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/C7010N.png","size":85146,"mtime":1765319267346,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/CDBEJB.png","size":174697,"mtime":1765319267349,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/DHSQKAQ.png","size":119529,"mtime":1765319267356,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/FWZU4BU.png","size":139706,"mtime":1765319267362,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/E45LPU.png","size":134295,"mtime":1765319267357,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/VBTXTM.png","size":178067,"mtime":1765319267406,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/JUMX3RJ.png","size":248185,"mtime":1765319267370,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/LLTYXL4.png","size":249205,"mtime":1765319267374,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/CUQM88J.png","size":249810,"mtime":1765319267352,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/PCNHBH.png","size":231520,"mtime":1765319267386,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/DA7WK8.png","size":243177,"mtime":1765319267353,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/U7R1JP.png","size":175690,"mtime":1765319267400,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/NADRE5G.png","size":120813,"mtime":1765319267382,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/XNC6FCM.png","size":242314,"mtime":1765319267414,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/PFB594.png","size":232538,"mtime":1765319267388,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/KG6EW2.png","size":89461,"mtime":1765319267372,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/V73Q8J2.png","size":143920,"mtime":1765319267404,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/QEM62SJ.png","size":121752,"mtime":1765319267393,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/F2NJ2W.png","size":118100,"mtime":1765319267359,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/J1ZPXN.png","size":136545,"mtime":1765319267366,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/ZJE033.png","size":239133,"mtime":1765319267418,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/CP5Q4M.png","size":89363,"mtime":1765319267349,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/GP93NR.png","size":140661,"mtime":1765319267364,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/XLCPAU8.png","size":252970,"mtime":1765319267413,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/J2GUWH8.png","size":121270,"mtime":1765319267368,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/RHSDQR.png","size":139565,"mtime":1765319267394,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/NNLXDFC.png","size":238455,"mtime":1765319267383,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/F5SHUBE.png","size":119962,"mtime":1765319267360,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/CSUAPXD.png","size":186309,"mtime":1765319267351,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/B4BR8T.png","size":119963,"mtime":1765319267342,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/ENV245.png","size":136741,"mtime":1765319267357,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/MH6YC8.png","size":89091,"mtime":1765319267380,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/ULSXU1N.png","size":182443,"mtime":1765319267401,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/B5RMPS.png","size":138505,"mtime":1765319267343,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/VEWCKJ.png","size":119745,"mtime":1765319267406,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/LPJW7B.png","size":118817,"mtime":1765319267376,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/VS1CZZ6.png","size":184604,"mtime":1765319267406,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/LWPM9VY.png","size":253706,"mtime":1765319267378,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/D2FBZ7.png","size":135162,"mtime":1765319267352,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/EU11YZ5.png","size":86458,"mtime":1765319267358,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/JAS3UW.png","size":139414,"mtime":1765319267368,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/Q75Q706.png","size":88704,"mtime":1765319267392,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/ZPR5EQ.png","size":240261,"mtime":1765319267419,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/T9GUBH.png","size":232263,"mtime":1765319267398,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/H3NFDTN.png","size":245068,"mtime":1765319267365,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/NVXWSP.png","size":245427,"mtime":1765319267385,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/M1FNYM.png","size":83630,"mtime":1765319267379,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/DD0BVK.png","size":231367,"mtime":1765319267355,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/NCEUQ4.png","size":244976,"mtime":1765319267382,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/FE0MYMN.png","size":119098,"mtime":1765319267361,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/WV610AS.png","size":251834,"mtime":1765319267409,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/C2F6VN.png","size":138807,"mtime":1765319267345,"ext":"png"},{"path":"mini-project-3-team-tiger/assets/plates/D7CN6Q.png","size":141521,"mtime":1765319267353,"ext":"png"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}}]